
HMI_ECU.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003b1c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000ea  00800060  00003b1c  00003bb0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000016  0080014a  0080014a  00003c9a  2**0
                  ALLOC
  3 .stab         00003570  00000000  00000000  00003c9c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000149e  00000000  00000000  0000720c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  000086aa  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  000087ea  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  0000895a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  0000a5a3  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  0000b48e  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  0000c23c  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028d  00000000  00000000  0000c39c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  0000c629  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  0000cdf7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 cd 06 	jmp	0xd9a	; 0xd9a <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 00 07 	jmp	0xe00	; 0xe00 <__vector_9>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ec e1       	ldi	r30, 0x1C	; 28
      68:	fb e3       	ldi	r31, 0x3B	; 59
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	aa 34       	cpi	r26, 0x4A	; 74
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	11 e0       	ldi	r17, 0x01	; 1
      78:	aa e4       	ldi	r26, 0x4A	; 74
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a0 36       	cpi	r26, 0x60	; 96
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 f3 16 	call	0x2de6	; 0x2de6 <main>
      8a:	0c 94 8c 1d 	jmp	0x3b18	; 0x3b18 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 49 03 	call	0x692	; 0x692 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 10 1d 	jmp	0x3a20	; 0x3a20 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a4 e3       	ldi	r26, 0x34	; 52
     128:	b1 e0       	ldi	r27, 0x01	; 1
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 2c 1d 	jmp	0x3a58	; 0x3a58 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 1c 1d 	jmp	0x3a38	; 0x3a38 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 38 1d 	jmp	0x3a70	; 0x3a70 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 1c 1d 	jmp	0x3a38	; 0x3a38 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 38 1d 	jmp	0x3a70	; 0x3a70 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 10 1d 	jmp	0x3a20	; 0x3a20 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	84 e3       	ldi	r24, 0x34	; 52
     496:	91 e0       	ldi	r25, 0x01	; 1
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 2c 1d 	jmp	0x3a58	; 0x3a58 <__epilogue_restores__>

00000632 <__gtsf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 1c 1d 	jmp	0x3a38	; 0x3a38 <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gtsf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gtsf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gtsf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 38 1d 	jmp	0x3a70	; 0x3a70 <__epilogue_restores__+0x18>

00000692 <__gesf2>:
     692:	a8 e1       	ldi	r26, 0x18	; 24
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 1c 1d 	jmp	0x3a38	; 0x3a38 <__prologue_saves__+0x18>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	2d 83       	std	Y+5, r18	; 0x05
     6a8:	3e 83       	std	Y+6, r19	; 0x06
     6aa:	4f 83       	std	Y+7, r20	; 0x07
     6ac:	58 87       	std	Y+8, r21	; 0x08
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	e8 2e       	mov	r14, r24
     6b2:	f1 2c       	mov	r15, r1
     6b4:	ec 0e       	add	r14, r28
     6b6:	fd 1e       	adc	r15, r29
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	b7 01       	movw	r22, r14
     6be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6c2:	8e 01       	movw	r16, r28
     6c4:	0f 5e       	subi	r16, 0xEF	; 239
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	ce 01       	movw	r24, r28
     6ca:	05 96       	adiw	r24, 0x05	; 5
     6cc:	b8 01       	movw	r22, r16
     6ce:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6d2:	89 85       	ldd	r24, Y+9	; 0x09
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	40 f0       	brcs	.+16     	; 0x6e8 <__gesf2+0x56>
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	28 f0       	brcs	.+10     	; 0x6e8 <__gesf2+0x56>
     6de:	c7 01       	movw	r24, r14
     6e0:	b8 01       	movw	r22, r16
     6e2:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     6e6:	01 c0       	rjmp	.+2      	; 0x6ea <__gesf2+0x58>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	68 96       	adiw	r28, 0x18	; 24
     6ec:	e6 e0       	ldi	r30, 0x06	; 6
     6ee:	0c 94 38 1d 	jmp	0x3a70	; 0x3a70 <__epilogue_restores__+0x18>

000006f2 <__ltsf2>:
     6f2:	a8 e1       	ldi	r26, 0x18	; 24
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	ef e7       	ldi	r30, 0x7F	; 127
     6f8:	f3 e0       	ldi	r31, 0x03	; 3
     6fa:	0c 94 1c 1d 	jmp	0x3a38	; 0x3a38 <__prologue_saves__+0x18>
     6fe:	69 83       	std	Y+1, r22	; 0x01
     700:	7a 83       	std	Y+2, r23	; 0x02
     702:	8b 83       	std	Y+3, r24	; 0x03
     704:	9c 83       	std	Y+4, r25	; 0x04
     706:	2d 83       	std	Y+5, r18	; 0x05
     708:	3e 83       	std	Y+6, r19	; 0x06
     70a:	4f 83       	std	Y+7, r20	; 0x07
     70c:	58 87       	std	Y+8, r21	; 0x08
     70e:	89 e0       	ldi	r24, 0x09	; 9
     710:	e8 2e       	mov	r14, r24
     712:	f1 2c       	mov	r15, r1
     714:	ec 0e       	add	r14, r28
     716:	fd 1e       	adc	r15, r29
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	b7 01       	movw	r22, r14
     71e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     722:	8e 01       	movw	r16, r28
     724:	0f 5e       	subi	r16, 0xEF	; 239
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	ce 01       	movw	r24, r28
     72a:	05 96       	adiw	r24, 0x05	; 5
     72c:	b8 01       	movw	r22, r16
     72e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     732:	89 85       	ldd	r24, Y+9	; 0x09
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	40 f0       	brcs	.+16     	; 0x748 <__ltsf2+0x56>
     738:	89 89       	ldd	r24, Y+17	; 0x11
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	28 f0       	brcs	.+10     	; 0x748 <__ltsf2+0x56>
     73e:	c7 01       	movw	r24, r14
     740:	b8 01       	movw	r22, r16
     742:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     746:	01 c0       	rjmp	.+2      	; 0x74a <__ltsf2+0x58>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	68 96       	adiw	r28, 0x18	; 24
     74c:	e6 e0       	ldi	r30, 0x06	; 6
     74e:	0c 94 38 1d 	jmp	0x3a70	; 0x3a70 <__epilogue_restores__+0x18>

00000752 <__fixsfsi>:
     752:	ac e0       	ldi	r26, 0x0C	; 12
     754:	b0 e0       	ldi	r27, 0x00	; 0
     756:	ef ea       	ldi	r30, 0xAF	; 175
     758:	f3 e0       	ldi	r31, 0x03	; 3
     75a:	0c 94 20 1d 	jmp	0x3a40	; 0x3a40 <__prologue_saves__+0x20>
     75e:	69 83       	std	Y+1, r22	; 0x01
     760:	7a 83       	std	Y+2, r23	; 0x02
     762:	8b 83       	std	Y+3, r24	; 0x03
     764:	9c 83       	std	Y+4, r25	; 0x04
     766:	ce 01       	movw	r24, r28
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	be 01       	movw	r22, r28
     76c:	6b 5f       	subi	r22, 0xFB	; 251
     76e:	7f 4f       	sbci	r23, 0xFF	; 255
     770:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     774:	8d 81       	ldd	r24, Y+5	; 0x05
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	61 f1       	breq	.+88     	; 0x7d2 <__fixsfsi+0x80>
     77a:	82 30       	cpi	r24, 0x02	; 2
     77c:	50 f1       	brcs	.+84     	; 0x7d2 <__fixsfsi+0x80>
     77e:	84 30       	cpi	r24, 0x04	; 4
     780:	21 f4       	brne	.+8      	; 0x78a <__fixsfsi+0x38>
     782:	8e 81       	ldd	r24, Y+6	; 0x06
     784:	88 23       	and	r24, r24
     786:	51 f1       	breq	.+84     	; 0x7dc <__fixsfsi+0x8a>
     788:	2e c0       	rjmp	.+92     	; 0x7e6 <__fixsfsi+0x94>
     78a:	2f 81       	ldd	r18, Y+7	; 0x07
     78c:	38 85       	ldd	r19, Y+8	; 0x08
     78e:	37 fd       	sbrc	r19, 7
     790:	20 c0       	rjmp	.+64     	; 0x7d2 <__fixsfsi+0x80>
     792:	6e 81       	ldd	r22, Y+6	; 0x06
     794:	2f 31       	cpi	r18, 0x1F	; 31
     796:	31 05       	cpc	r19, r1
     798:	1c f0       	brlt	.+6      	; 0x7a0 <__fixsfsi+0x4e>
     79a:	66 23       	and	r22, r22
     79c:	f9 f0       	breq	.+62     	; 0x7dc <__fixsfsi+0x8a>
     79e:	23 c0       	rjmp	.+70     	; 0x7e6 <__fixsfsi+0x94>
     7a0:	8e e1       	ldi	r24, 0x1E	; 30
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	82 1b       	sub	r24, r18
     7a6:	93 0b       	sbc	r25, r19
     7a8:	29 85       	ldd	r18, Y+9	; 0x09
     7aa:	3a 85       	ldd	r19, Y+10	; 0x0a
     7ac:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ae:	5c 85       	ldd	r21, Y+12	; 0x0c
     7b0:	04 c0       	rjmp	.+8      	; 0x7ba <__fixsfsi+0x68>
     7b2:	56 95       	lsr	r21
     7b4:	47 95       	ror	r20
     7b6:	37 95       	ror	r19
     7b8:	27 95       	ror	r18
     7ba:	8a 95       	dec	r24
     7bc:	d2 f7       	brpl	.-12     	; 0x7b2 <__fixsfsi+0x60>
     7be:	66 23       	and	r22, r22
     7c0:	b1 f0       	breq	.+44     	; 0x7ee <__fixsfsi+0x9c>
     7c2:	50 95       	com	r21
     7c4:	40 95       	com	r20
     7c6:	30 95       	com	r19
     7c8:	21 95       	neg	r18
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	4f 4f       	sbci	r20, 0xFF	; 255
     7ce:	5f 4f       	sbci	r21, 0xFF	; 255
     7d0:	0e c0       	rjmp	.+28     	; 0x7ee <__fixsfsi+0x9c>
     7d2:	20 e0       	ldi	r18, 0x00	; 0
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	09 c0       	rjmp	.+18     	; 0x7ee <__fixsfsi+0x9c>
     7dc:	2f ef       	ldi	r18, 0xFF	; 255
     7de:	3f ef       	ldi	r19, 0xFF	; 255
     7e0:	4f ef       	ldi	r20, 0xFF	; 255
     7e2:	5f e7       	ldi	r21, 0x7F	; 127
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <__fixsfsi+0x9c>
     7e6:	20 e0       	ldi	r18, 0x00	; 0
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	40 e0       	ldi	r20, 0x00	; 0
     7ec:	50 e8       	ldi	r21, 0x80	; 128
     7ee:	b9 01       	movw	r22, r18
     7f0:	ca 01       	movw	r24, r20
     7f2:	2c 96       	adiw	r28, 0x0c	; 12
     7f4:	e2 e0       	ldi	r30, 0x02	; 2
     7f6:	0c 94 3c 1d 	jmp	0x3a78	; 0x3a78 <__epilogue_restores__+0x20>

000007fa <__pack_f>:
     7fa:	df 92       	push	r13
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
     802:	1f 93       	push	r17
     804:	fc 01       	movw	r30, r24
     806:	e4 80       	ldd	r14, Z+4	; 0x04
     808:	f5 80       	ldd	r15, Z+5	; 0x05
     80a:	06 81       	ldd	r16, Z+6	; 0x06
     80c:	17 81       	ldd	r17, Z+7	; 0x07
     80e:	d1 80       	ldd	r13, Z+1	; 0x01
     810:	80 81       	ld	r24, Z
     812:	82 30       	cpi	r24, 0x02	; 2
     814:	48 f4       	brcc	.+18     	; 0x828 <__pack_f+0x2e>
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	a0 e1       	ldi	r26, 0x10	; 16
     81c:	b0 e0       	ldi	r27, 0x00	; 0
     81e:	e8 2a       	or	r14, r24
     820:	f9 2a       	or	r15, r25
     822:	0a 2b       	or	r16, r26
     824:	1b 2b       	or	r17, r27
     826:	a5 c0       	rjmp	.+330    	; 0x972 <__stack+0x113>
     828:	84 30       	cpi	r24, 0x04	; 4
     82a:	09 f4       	brne	.+2      	; 0x82e <__pack_f+0x34>
     82c:	9f c0       	rjmp	.+318    	; 0x96c <__stack+0x10d>
     82e:	82 30       	cpi	r24, 0x02	; 2
     830:	21 f4       	brne	.+8      	; 0x83a <__pack_f+0x40>
     832:	ee 24       	eor	r14, r14
     834:	ff 24       	eor	r15, r15
     836:	87 01       	movw	r16, r14
     838:	05 c0       	rjmp	.+10     	; 0x844 <__pack_f+0x4a>
     83a:	e1 14       	cp	r14, r1
     83c:	f1 04       	cpc	r15, r1
     83e:	01 05       	cpc	r16, r1
     840:	11 05       	cpc	r17, r1
     842:	19 f4       	brne	.+6      	; 0x84a <__pack_f+0x50>
     844:	e0 e0       	ldi	r30, 0x00	; 0
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	96 c0       	rjmp	.+300    	; 0x976 <__stack+0x117>
     84a:	62 81       	ldd	r22, Z+2	; 0x02
     84c:	73 81       	ldd	r23, Z+3	; 0x03
     84e:	9f ef       	ldi	r25, 0xFF	; 255
     850:	62 38       	cpi	r22, 0x82	; 130
     852:	79 07       	cpc	r23, r25
     854:	0c f0       	brlt	.+2      	; 0x858 <__pack_f+0x5e>
     856:	5b c0       	rjmp	.+182    	; 0x90e <__stack+0xaf>
     858:	22 e8       	ldi	r18, 0x82	; 130
     85a:	3f ef       	ldi	r19, 0xFF	; 255
     85c:	26 1b       	sub	r18, r22
     85e:	37 0b       	sbc	r19, r23
     860:	2a 31       	cpi	r18, 0x1A	; 26
     862:	31 05       	cpc	r19, r1
     864:	2c f0       	brlt	.+10     	; 0x870 <__stack+0x11>
     866:	20 e0       	ldi	r18, 0x00	; 0
     868:	30 e0       	ldi	r19, 0x00	; 0
     86a:	40 e0       	ldi	r20, 0x00	; 0
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	2a c0       	rjmp	.+84     	; 0x8c4 <__stack+0x65>
     870:	b8 01       	movw	r22, r16
     872:	a7 01       	movw	r20, r14
     874:	02 2e       	mov	r0, r18
     876:	04 c0       	rjmp	.+8      	; 0x880 <__stack+0x21>
     878:	76 95       	lsr	r23
     87a:	67 95       	ror	r22
     87c:	57 95       	ror	r21
     87e:	47 95       	ror	r20
     880:	0a 94       	dec	r0
     882:	d2 f7       	brpl	.-12     	; 0x878 <__stack+0x19>
     884:	81 e0       	ldi	r24, 0x01	; 1
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	a0 e0       	ldi	r26, 0x00	; 0
     88a:	b0 e0       	ldi	r27, 0x00	; 0
     88c:	04 c0       	rjmp	.+8      	; 0x896 <__stack+0x37>
     88e:	88 0f       	add	r24, r24
     890:	99 1f       	adc	r25, r25
     892:	aa 1f       	adc	r26, r26
     894:	bb 1f       	adc	r27, r27
     896:	2a 95       	dec	r18
     898:	d2 f7       	brpl	.-12     	; 0x88e <__stack+0x2f>
     89a:	01 97       	sbiw	r24, 0x01	; 1
     89c:	a1 09       	sbc	r26, r1
     89e:	b1 09       	sbc	r27, r1
     8a0:	8e 21       	and	r24, r14
     8a2:	9f 21       	and	r25, r15
     8a4:	a0 23       	and	r26, r16
     8a6:	b1 23       	and	r27, r17
     8a8:	00 97       	sbiw	r24, 0x00	; 0
     8aa:	a1 05       	cpc	r26, r1
     8ac:	b1 05       	cpc	r27, r1
     8ae:	21 f0       	breq	.+8      	; 0x8b8 <__stack+0x59>
     8b0:	81 e0       	ldi	r24, 0x01	; 1
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	a0 e0       	ldi	r26, 0x00	; 0
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	9a 01       	movw	r18, r20
     8ba:	ab 01       	movw	r20, r22
     8bc:	28 2b       	or	r18, r24
     8be:	39 2b       	or	r19, r25
     8c0:	4a 2b       	or	r20, r26
     8c2:	5b 2b       	or	r21, r27
     8c4:	da 01       	movw	r26, r20
     8c6:	c9 01       	movw	r24, r18
     8c8:	8f 77       	andi	r24, 0x7F	; 127
     8ca:	90 70       	andi	r25, 0x00	; 0
     8cc:	a0 70       	andi	r26, 0x00	; 0
     8ce:	b0 70       	andi	r27, 0x00	; 0
     8d0:	80 34       	cpi	r24, 0x40	; 64
     8d2:	91 05       	cpc	r25, r1
     8d4:	a1 05       	cpc	r26, r1
     8d6:	b1 05       	cpc	r27, r1
     8d8:	39 f4       	brne	.+14     	; 0x8e8 <__stack+0x89>
     8da:	27 ff       	sbrs	r18, 7
     8dc:	09 c0       	rjmp	.+18     	; 0x8f0 <__stack+0x91>
     8de:	20 5c       	subi	r18, 0xC0	; 192
     8e0:	3f 4f       	sbci	r19, 0xFF	; 255
     8e2:	4f 4f       	sbci	r20, 0xFF	; 255
     8e4:	5f 4f       	sbci	r21, 0xFF	; 255
     8e6:	04 c0       	rjmp	.+8      	; 0x8f0 <__stack+0x91>
     8e8:	21 5c       	subi	r18, 0xC1	; 193
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	4f 4f       	sbci	r20, 0xFF	; 255
     8ee:	5f 4f       	sbci	r21, 0xFF	; 255
     8f0:	e0 e0       	ldi	r30, 0x00	; 0
     8f2:	f0 e0       	ldi	r31, 0x00	; 0
     8f4:	20 30       	cpi	r18, 0x00	; 0
     8f6:	a0 e0       	ldi	r26, 0x00	; 0
     8f8:	3a 07       	cpc	r19, r26
     8fa:	a0 e0       	ldi	r26, 0x00	; 0
     8fc:	4a 07       	cpc	r20, r26
     8fe:	a0 e4       	ldi	r26, 0x40	; 64
     900:	5a 07       	cpc	r21, r26
     902:	10 f0       	brcs	.+4      	; 0x908 <__stack+0xa9>
     904:	e1 e0       	ldi	r30, 0x01	; 1
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	79 01       	movw	r14, r18
     90a:	8a 01       	movw	r16, r20
     90c:	27 c0       	rjmp	.+78     	; 0x95c <__stack+0xfd>
     90e:	60 38       	cpi	r22, 0x80	; 128
     910:	71 05       	cpc	r23, r1
     912:	64 f5       	brge	.+88     	; 0x96c <__stack+0x10d>
     914:	fb 01       	movw	r30, r22
     916:	e1 58       	subi	r30, 0x81	; 129
     918:	ff 4f       	sbci	r31, 0xFF	; 255
     91a:	d8 01       	movw	r26, r16
     91c:	c7 01       	movw	r24, r14
     91e:	8f 77       	andi	r24, 0x7F	; 127
     920:	90 70       	andi	r25, 0x00	; 0
     922:	a0 70       	andi	r26, 0x00	; 0
     924:	b0 70       	andi	r27, 0x00	; 0
     926:	80 34       	cpi	r24, 0x40	; 64
     928:	91 05       	cpc	r25, r1
     92a:	a1 05       	cpc	r26, r1
     92c:	b1 05       	cpc	r27, r1
     92e:	39 f4       	brne	.+14     	; 0x93e <__stack+0xdf>
     930:	e7 fe       	sbrs	r14, 7
     932:	0d c0       	rjmp	.+26     	; 0x94e <__stack+0xef>
     934:	80 e4       	ldi	r24, 0x40	; 64
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	a0 e0       	ldi	r26, 0x00	; 0
     93a:	b0 e0       	ldi	r27, 0x00	; 0
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__stack+0xe7>
     93e:	8f e3       	ldi	r24, 0x3F	; 63
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	e8 0e       	add	r14, r24
     948:	f9 1e       	adc	r15, r25
     94a:	0a 1f       	adc	r16, r26
     94c:	1b 1f       	adc	r17, r27
     94e:	17 ff       	sbrs	r17, 7
     950:	05 c0       	rjmp	.+10     	; 0x95c <__stack+0xfd>
     952:	16 95       	lsr	r17
     954:	07 95       	ror	r16
     956:	f7 94       	ror	r15
     958:	e7 94       	ror	r14
     95a:	31 96       	adiw	r30, 0x01	; 1
     95c:	87 e0       	ldi	r24, 0x07	; 7
     95e:	16 95       	lsr	r17
     960:	07 95       	ror	r16
     962:	f7 94       	ror	r15
     964:	e7 94       	ror	r14
     966:	8a 95       	dec	r24
     968:	d1 f7       	brne	.-12     	; 0x95e <__stack+0xff>
     96a:	05 c0       	rjmp	.+10     	; 0x976 <__stack+0x117>
     96c:	ee 24       	eor	r14, r14
     96e:	ff 24       	eor	r15, r15
     970:	87 01       	movw	r16, r14
     972:	ef ef       	ldi	r30, 0xFF	; 255
     974:	f0 e0       	ldi	r31, 0x00	; 0
     976:	6e 2f       	mov	r22, r30
     978:	67 95       	ror	r22
     97a:	66 27       	eor	r22, r22
     97c:	67 95       	ror	r22
     97e:	90 2f       	mov	r25, r16
     980:	9f 77       	andi	r25, 0x7F	; 127
     982:	d7 94       	ror	r13
     984:	dd 24       	eor	r13, r13
     986:	d7 94       	ror	r13
     988:	8e 2f       	mov	r24, r30
     98a:	86 95       	lsr	r24
     98c:	49 2f       	mov	r20, r25
     98e:	46 2b       	or	r20, r22
     990:	58 2f       	mov	r21, r24
     992:	5d 29       	or	r21, r13
     994:	b7 01       	movw	r22, r14
     996:	ca 01       	movw	r24, r20
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	df 90       	pop	r13
     9a2:	08 95       	ret

000009a4 <__unpack_f>:
     9a4:	fc 01       	movw	r30, r24
     9a6:	db 01       	movw	r26, r22
     9a8:	40 81       	ld	r20, Z
     9aa:	51 81       	ldd	r21, Z+1	; 0x01
     9ac:	22 81       	ldd	r18, Z+2	; 0x02
     9ae:	62 2f       	mov	r22, r18
     9b0:	6f 77       	andi	r22, 0x7F	; 127
     9b2:	70 e0       	ldi	r23, 0x00	; 0
     9b4:	22 1f       	adc	r18, r18
     9b6:	22 27       	eor	r18, r18
     9b8:	22 1f       	adc	r18, r18
     9ba:	93 81       	ldd	r25, Z+3	; 0x03
     9bc:	89 2f       	mov	r24, r25
     9be:	88 0f       	add	r24, r24
     9c0:	82 2b       	or	r24, r18
     9c2:	28 2f       	mov	r18, r24
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	99 1f       	adc	r25, r25
     9c8:	99 27       	eor	r25, r25
     9ca:	99 1f       	adc	r25, r25
     9cc:	11 96       	adiw	r26, 0x01	; 1
     9ce:	9c 93       	st	X, r25
     9d0:	11 97       	sbiw	r26, 0x01	; 1
     9d2:	21 15       	cp	r18, r1
     9d4:	31 05       	cpc	r19, r1
     9d6:	a9 f5       	brne	.+106    	; 0xa42 <__unpack_f+0x9e>
     9d8:	41 15       	cp	r20, r1
     9da:	51 05       	cpc	r21, r1
     9dc:	61 05       	cpc	r22, r1
     9de:	71 05       	cpc	r23, r1
     9e0:	11 f4       	brne	.+4      	; 0x9e6 <__unpack_f+0x42>
     9e2:	82 e0       	ldi	r24, 0x02	; 2
     9e4:	37 c0       	rjmp	.+110    	; 0xa54 <__unpack_f+0xb0>
     9e6:	82 e8       	ldi	r24, 0x82	; 130
     9e8:	9f ef       	ldi	r25, 0xFF	; 255
     9ea:	13 96       	adiw	r26, 0x03	; 3
     9ec:	9c 93       	st	X, r25
     9ee:	8e 93       	st	-X, r24
     9f0:	12 97       	sbiw	r26, 0x02	; 2
     9f2:	9a 01       	movw	r18, r20
     9f4:	ab 01       	movw	r20, r22
     9f6:	67 e0       	ldi	r22, 0x07	; 7
     9f8:	22 0f       	add	r18, r18
     9fa:	33 1f       	adc	r19, r19
     9fc:	44 1f       	adc	r20, r20
     9fe:	55 1f       	adc	r21, r21
     a00:	6a 95       	dec	r22
     a02:	d1 f7       	brne	.-12     	; 0x9f8 <__unpack_f+0x54>
     a04:	83 e0       	ldi	r24, 0x03	; 3
     a06:	8c 93       	st	X, r24
     a08:	0d c0       	rjmp	.+26     	; 0xa24 <__unpack_f+0x80>
     a0a:	22 0f       	add	r18, r18
     a0c:	33 1f       	adc	r19, r19
     a0e:	44 1f       	adc	r20, r20
     a10:	55 1f       	adc	r21, r21
     a12:	12 96       	adiw	r26, 0x02	; 2
     a14:	8d 91       	ld	r24, X+
     a16:	9c 91       	ld	r25, X
     a18:	13 97       	sbiw	r26, 0x03	; 3
     a1a:	01 97       	sbiw	r24, 0x01	; 1
     a1c:	13 96       	adiw	r26, 0x03	; 3
     a1e:	9c 93       	st	X, r25
     a20:	8e 93       	st	-X, r24
     a22:	12 97       	sbiw	r26, 0x02	; 2
     a24:	20 30       	cpi	r18, 0x00	; 0
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	38 07       	cpc	r19, r24
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	48 07       	cpc	r20, r24
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	58 07       	cpc	r21, r24
     a32:	58 f3       	brcs	.-42     	; 0xa0a <__unpack_f+0x66>
     a34:	14 96       	adiw	r26, 0x04	; 4
     a36:	2d 93       	st	X+, r18
     a38:	3d 93       	st	X+, r19
     a3a:	4d 93       	st	X+, r20
     a3c:	5c 93       	st	X, r21
     a3e:	17 97       	sbiw	r26, 0x07	; 7
     a40:	08 95       	ret
     a42:	2f 3f       	cpi	r18, 0xFF	; 255
     a44:	31 05       	cpc	r19, r1
     a46:	79 f4       	brne	.+30     	; 0xa66 <__unpack_f+0xc2>
     a48:	41 15       	cp	r20, r1
     a4a:	51 05       	cpc	r21, r1
     a4c:	61 05       	cpc	r22, r1
     a4e:	71 05       	cpc	r23, r1
     a50:	19 f4       	brne	.+6      	; 0xa58 <__unpack_f+0xb4>
     a52:	84 e0       	ldi	r24, 0x04	; 4
     a54:	8c 93       	st	X, r24
     a56:	08 95       	ret
     a58:	64 ff       	sbrs	r22, 4
     a5a:	03 c0       	rjmp	.+6      	; 0xa62 <__unpack_f+0xbe>
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	8c 93       	st	X, r24
     a60:	12 c0       	rjmp	.+36     	; 0xa86 <__unpack_f+0xe2>
     a62:	1c 92       	st	X, r1
     a64:	10 c0       	rjmp	.+32     	; 0xa86 <__unpack_f+0xe2>
     a66:	2f 57       	subi	r18, 0x7F	; 127
     a68:	30 40       	sbci	r19, 0x00	; 0
     a6a:	13 96       	adiw	r26, 0x03	; 3
     a6c:	3c 93       	st	X, r19
     a6e:	2e 93       	st	-X, r18
     a70:	12 97       	sbiw	r26, 0x02	; 2
     a72:	83 e0       	ldi	r24, 0x03	; 3
     a74:	8c 93       	st	X, r24
     a76:	87 e0       	ldi	r24, 0x07	; 7
     a78:	44 0f       	add	r20, r20
     a7a:	55 1f       	adc	r21, r21
     a7c:	66 1f       	adc	r22, r22
     a7e:	77 1f       	adc	r23, r23
     a80:	8a 95       	dec	r24
     a82:	d1 f7       	brne	.-12     	; 0xa78 <__unpack_f+0xd4>
     a84:	70 64       	ori	r23, 0x40	; 64
     a86:	14 96       	adiw	r26, 0x04	; 4
     a88:	4d 93       	st	X+, r20
     a8a:	5d 93       	st	X+, r21
     a8c:	6d 93       	st	X+, r22
     a8e:	7c 93       	st	X, r23
     a90:	17 97       	sbiw	r26, 0x07	; 7
     a92:	08 95       	ret

00000a94 <__fpcmp_parts_f>:
     a94:	1f 93       	push	r17
     a96:	dc 01       	movw	r26, r24
     a98:	fb 01       	movw	r30, r22
     a9a:	9c 91       	ld	r25, X
     a9c:	92 30       	cpi	r25, 0x02	; 2
     a9e:	08 f4       	brcc	.+2      	; 0xaa2 <__fpcmp_parts_f+0xe>
     aa0:	47 c0       	rjmp	.+142    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aa2:	80 81       	ld	r24, Z
     aa4:	82 30       	cpi	r24, 0x02	; 2
     aa6:	08 f4       	brcc	.+2      	; 0xaaa <__fpcmp_parts_f+0x16>
     aa8:	43 c0       	rjmp	.+134    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aaa:	94 30       	cpi	r25, 0x04	; 4
     aac:	51 f4       	brne	.+20     	; 0xac2 <__fpcmp_parts_f+0x2e>
     aae:	11 96       	adiw	r26, 0x01	; 1
     ab0:	1c 91       	ld	r17, X
     ab2:	84 30       	cpi	r24, 0x04	; 4
     ab4:	99 f5       	brne	.+102    	; 0xb1c <__fpcmp_parts_f+0x88>
     ab6:	81 81       	ldd	r24, Z+1	; 0x01
     ab8:	68 2f       	mov	r22, r24
     aba:	70 e0       	ldi	r23, 0x00	; 0
     abc:	61 1b       	sub	r22, r17
     abe:	71 09       	sbc	r23, r1
     ac0:	3f c0       	rjmp	.+126    	; 0xb40 <__fpcmp_parts_f+0xac>
     ac2:	84 30       	cpi	r24, 0x04	; 4
     ac4:	21 f0       	breq	.+8      	; 0xace <__fpcmp_parts_f+0x3a>
     ac6:	92 30       	cpi	r25, 0x02	; 2
     ac8:	31 f4       	brne	.+12     	; 0xad6 <__fpcmp_parts_f+0x42>
     aca:	82 30       	cpi	r24, 0x02	; 2
     acc:	b9 f1       	breq	.+110    	; 0xb3c <__fpcmp_parts_f+0xa8>
     ace:	81 81       	ldd	r24, Z+1	; 0x01
     ad0:	88 23       	and	r24, r24
     ad2:	89 f1       	breq	.+98     	; 0xb36 <__fpcmp_parts_f+0xa2>
     ad4:	2d c0       	rjmp	.+90     	; 0xb30 <__fpcmp_parts_f+0x9c>
     ad6:	11 96       	adiw	r26, 0x01	; 1
     ad8:	1c 91       	ld	r17, X
     ada:	11 97       	sbiw	r26, 0x01	; 1
     adc:	82 30       	cpi	r24, 0x02	; 2
     ade:	f1 f0       	breq	.+60     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae0:	81 81       	ldd	r24, Z+1	; 0x01
     ae2:	18 17       	cp	r17, r24
     ae4:	d9 f4       	brne	.+54     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae6:	12 96       	adiw	r26, 0x02	; 2
     ae8:	2d 91       	ld	r18, X+
     aea:	3c 91       	ld	r19, X
     aec:	13 97       	sbiw	r26, 0x03	; 3
     aee:	82 81       	ldd	r24, Z+2	; 0x02
     af0:	93 81       	ldd	r25, Z+3	; 0x03
     af2:	82 17       	cp	r24, r18
     af4:	93 07       	cpc	r25, r19
     af6:	94 f0       	brlt	.+36     	; 0xb1c <__fpcmp_parts_f+0x88>
     af8:	28 17       	cp	r18, r24
     afa:	39 07       	cpc	r19, r25
     afc:	bc f0       	brlt	.+46     	; 0xb2c <__fpcmp_parts_f+0x98>
     afe:	14 96       	adiw	r26, 0x04	; 4
     b00:	8d 91       	ld	r24, X+
     b02:	9d 91       	ld	r25, X+
     b04:	0d 90       	ld	r0, X+
     b06:	bc 91       	ld	r27, X
     b08:	a0 2d       	mov	r26, r0
     b0a:	24 81       	ldd	r18, Z+4	; 0x04
     b0c:	35 81       	ldd	r19, Z+5	; 0x05
     b0e:	46 81       	ldd	r20, Z+6	; 0x06
     b10:	57 81       	ldd	r21, Z+7	; 0x07
     b12:	28 17       	cp	r18, r24
     b14:	39 07       	cpc	r19, r25
     b16:	4a 07       	cpc	r20, r26
     b18:	5b 07       	cpc	r21, r27
     b1a:	18 f4       	brcc	.+6      	; 0xb22 <__fpcmp_parts_f+0x8e>
     b1c:	11 23       	and	r17, r17
     b1e:	41 f0       	breq	.+16     	; 0xb30 <__fpcmp_parts_f+0x9c>
     b20:	0a c0       	rjmp	.+20     	; 0xb36 <__fpcmp_parts_f+0xa2>
     b22:	82 17       	cp	r24, r18
     b24:	93 07       	cpc	r25, r19
     b26:	a4 07       	cpc	r26, r20
     b28:	b5 07       	cpc	r27, r21
     b2a:	40 f4       	brcc	.+16     	; 0xb3c <__fpcmp_parts_f+0xa8>
     b2c:	11 23       	and	r17, r17
     b2e:	19 f0       	breq	.+6      	; 0xb36 <__fpcmp_parts_f+0xa2>
     b30:	61 e0       	ldi	r22, 0x01	; 1
     b32:	70 e0       	ldi	r23, 0x00	; 0
     b34:	05 c0       	rjmp	.+10     	; 0xb40 <__fpcmp_parts_f+0xac>
     b36:	6f ef       	ldi	r22, 0xFF	; 255
     b38:	7f ef       	ldi	r23, 0xFF	; 255
     b3a:	02 c0       	rjmp	.+4      	; 0xb40 <__fpcmp_parts_f+0xac>
     b3c:	60 e0       	ldi	r22, 0x00	; 0
     b3e:	70 e0       	ldi	r23, 0x00	; 0
     b40:	cb 01       	movw	r24, r22
     b42:	1f 91       	pop	r17
     b44:	08 95       	ret

00000b46 <UART_init>:

#include "uart.h"
#include <avr/io.h>
#include "../../General/common_macros.h"

void UART_init(const UART_ConfigType *Config_Ptr) {
     b46:	df 93       	push	r29
     b48:	cf 93       	push	r28
     b4a:	00 d0       	rcall	.+0      	; 0xb4c <UART_init+0x6>
     b4c:	00 d0       	rcall	.+0      	; 0xb4e <UART_init+0x8>
     b4e:	cd b7       	in	r28, 0x3d	; 61
     b50:	de b7       	in	r29, 0x3e	; 62
     b52:	9c 83       	std	Y+4, r25	; 0x04
     b54:	8b 83       	std	Y+3, r24	; 0x03
	uint16 ubrr_value = 0;
     b56:	1a 82       	std	Y+2, r1	; 0x02
     b58:	19 82       	std	Y+1, r1	; 0x01

	// UCSRA - USART Control and Status Register A
	//U2X: Double the USART Transmission Speed
	UCSRA = (1 << U2X);
     b5a:	eb e2       	ldi	r30, 0x2B	; 43
     b5c:	f0 e0       	ldi	r31, 0x00	; 0
     b5e:	82 e0       	ldi	r24, 0x02	; 2
     b60:	80 83       	st	Z, r24
	/*
	 * Bit 4  RXEN: Receiver Enable
	 * Bit 3  TXEN: Transmitter Enable
	 *
	 * */
	UCSRB = (1 << TXEN) | (1 << RXEN);
     b62:	ea e2       	ldi	r30, 0x2A	; 42
     b64:	f0 e0       	ldi	r31, 0x00	; 0
     b66:	88 e1       	ldi	r24, 0x18	; 24
     b68:	80 83       	st	Z, r24
	 *  Bit 2:1  UCSZ1:0: DATA Size)
	 *
	 * */

	//URSEL: Register Select
	SET_BIT(UCSRC, URSEL);
     b6a:	a0 e4       	ldi	r26, 0x40	; 64
     b6c:	b0 e0       	ldi	r27, 0x00	; 0
     b6e:	e0 e4       	ldi	r30, 0x40	; 64
     b70:	f0 e0       	ldi	r31, 0x00	; 0
     b72:	80 81       	ld	r24, Z
     b74:	80 68       	ori	r24, 0x80	; 128
     b76:	8c 93       	st	X, r24
	//Asynchronous Operation
	CLEAR_BIT(UCSRC, UMSEL);
     b78:	a0 e4       	ldi	r26, 0x40	; 64
     b7a:	b0 e0       	ldi	r27, 0x00	; 0
     b7c:	e0 e4       	ldi	r30, 0x40	; 64
     b7e:	f0 e0       	ldi	r31, 0x00	; 0
     b80:	80 81       	ld	r24, Z
     b82:	8f 7b       	andi	r24, 0xBF	; 191
     b84:	8c 93       	st	X, r24

	//Parity Configuration
	UCSRC = (UCSRC & 0XCF) | ((Config_Ptr->parity) << 4);
     b86:	a0 e4       	ldi	r26, 0x40	; 64
     b88:	b0 e0       	ldi	r27, 0x00	; 0
     b8a:	e0 e4       	ldi	r30, 0x40	; 64
     b8c:	f0 e0       	ldi	r31, 0x00	; 0
     b8e:	80 81       	ld	r24, Z
     b90:	28 2f       	mov	r18, r24
     b92:	2f 7c       	andi	r18, 0xCF	; 207
     b94:	eb 81       	ldd	r30, Y+3	; 0x03
     b96:	fc 81       	ldd	r31, Y+4	; 0x04
     b98:	81 81       	ldd	r24, Z+1	; 0x01
     b9a:	88 2f       	mov	r24, r24
     b9c:	90 e0       	ldi	r25, 0x00	; 0
     b9e:	82 95       	swap	r24
     ba0:	92 95       	swap	r25
     ba2:	90 7f       	andi	r25, 0xF0	; 240
     ba4:	98 27       	eor	r25, r24
     ba6:	80 7f       	andi	r24, 0xF0	; 240
     ba8:	98 27       	eor	r25, r24
     baa:	82 2b       	or	r24, r18
     bac:	8c 93       	st	X, r24
	//Stop bit Configuration
	UCSRC = (UCSRC & 0XF7) | ((Config_Ptr->stop_bit) << 3);
     bae:	a0 e4       	ldi	r26, 0x40	; 64
     bb0:	b0 e0       	ldi	r27, 0x00	; 0
     bb2:	e0 e4       	ldi	r30, 0x40	; 64
     bb4:	f0 e0       	ldi	r31, 0x00	; 0
     bb6:	80 81       	ld	r24, Z
     bb8:	28 2f       	mov	r18, r24
     bba:	27 7f       	andi	r18, 0xF7	; 247
     bbc:	eb 81       	ldd	r30, Y+3	; 0x03
     bbe:	fc 81       	ldd	r31, Y+4	; 0x04
     bc0:	82 81       	ldd	r24, Z+2	; 0x02
     bc2:	88 2f       	mov	r24, r24
     bc4:	90 e0       	ldi	r25, 0x00	; 0
     bc6:	88 0f       	add	r24, r24
     bc8:	99 1f       	adc	r25, r25
     bca:	88 0f       	add	r24, r24
     bcc:	99 1f       	adc	r25, r25
     bce:	88 0f       	add	r24, r24
     bd0:	99 1f       	adc	r25, r25
     bd2:	82 2b       	or	r24, r18
     bd4:	8c 93       	st	X, r24
	//Data Size Configuration
	UCSRC = (UCSRC & 0XF9) | ((Config_Ptr->bit_data) << 1);
     bd6:	a0 e4       	ldi	r26, 0x40	; 64
     bd8:	b0 e0       	ldi	r27, 0x00	; 0
     bda:	e0 e4       	ldi	r30, 0x40	; 64
     bdc:	f0 e0       	ldi	r31, 0x00	; 0
     bde:	80 81       	ld	r24, Z
     be0:	28 2f       	mov	r18, r24
     be2:	29 7f       	andi	r18, 0xF9	; 249
     be4:	eb 81       	ldd	r30, Y+3	; 0x03
     be6:	fc 81       	ldd	r31, Y+4	; 0x04
     be8:	80 81       	ld	r24, Z
     bea:	88 2f       	mov	r24, r24
     bec:	90 e0       	ldi	r25, 0x00	; 0
     bee:	88 0f       	add	r24, r24
     bf0:	99 1f       	adc	r25, r25
     bf2:	82 2b       	or	r24, r18
     bf4:	8c 93       	st	X, r24
	//Get Value of Last bit in a 3 bit Number and UCSZ2
	//Easier Solution - Only the 1 appears in 9bit so can do if cond. with it
	UCSRB = (UCSRB & 0XFB) | ((GET_BIT(Config_Ptr->bit_data, 2)) << 2);
     bf6:	aa e2       	ldi	r26, 0x2A	; 42
     bf8:	b0 e0       	ldi	r27, 0x00	; 0
     bfa:	ea e2       	ldi	r30, 0x2A	; 42
     bfc:	f0 e0       	ldi	r31, 0x00	; 0
     bfe:	80 81       	ld	r24, Z
     c00:	98 2f       	mov	r25, r24
     c02:	9b 7f       	andi	r25, 0xFB	; 251
     c04:	eb 81       	ldd	r30, Y+3	; 0x03
     c06:	fc 81       	ldd	r31, Y+4	; 0x04
     c08:	80 81       	ld	r24, Z
     c0a:	84 70       	andi	r24, 0x04	; 4
     c0c:	89 2b       	or	r24, r25
     c0e:	8c 93       	st	X, r24

	ubrr_value = (uint16) (((F_CPU / ((Config_Ptr->baud_rate) * 8UL))) - 1);
     c10:	eb 81       	ldd	r30, Y+3	; 0x03
     c12:	fc 81       	ldd	r31, Y+4	; 0x04
     c14:	83 81       	ldd	r24, Z+3	; 0x03
     c16:	94 81       	ldd	r25, Z+4	; 0x04
     c18:	a5 81       	ldd	r26, Z+5	; 0x05
     c1a:	b6 81       	ldd	r27, Z+6	; 0x06
     c1c:	88 0f       	add	r24, r24
     c1e:	99 1f       	adc	r25, r25
     c20:	aa 1f       	adc	r26, r26
     c22:	bb 1f       	adc	r27, r27
     c24:	88 0f       	add	r24, r24
     c26:	99 1f       	adc	r25, r25
     c28:	aa 1f       	adc	r26, r26
     c2a:	bb 1f       	adc	r27, r27
     c2c:	88 0f       	add	r24, r24
     c2e:	99 1f       	adc	r25, r25
     c30:	aa 1f       	adc	r26, r26
     c32:	bb 1f       	adc	r27, r27
     c34:	9c 01       	movw	r18, r24
     c36:	ad 01       	movw	r20, r26
     c38:	80 e0       	ldi	r24, 0x00	; 0
     c3a:	92 e1       	ldi	r25, 0x12	; 18
     c3c:	aa e7       	ldi	r26, 0x7A	; 122
     c3e:	b0 e0       	ldi	r27, 0x00	; 0
     c40:	bc 01       	movw	r22, r24
     c42:	cd 01       	movw	r24, r26
     c44:	0e 94 ee 1c 	call	0x39dc	; 0x39dc <__udivmodsi4>
     c48:	da 01       	movw	r26, r20
     c4a:	c9 01       	movw	r24, r18
     c4c:	01 97       	sbiw	r24, 0x01	; 1
     c4e:	9a 83       	std	Y+2, r25	; 0x02
     c50:	89 83       	std	Y+1, r24	; 0x01
	/* First 8 bits from the BAUD_PRESCALE inside UBRRL and last 4 bits in UBRRH*/
	UBRRH = ubrr_value >> 8;
     c52:	e0 e4       	ldi	r30, 0x40	; 64
     c54:	f0 e0       	ldi	r31, 0x00	; 0
     c56:	89 81       	ldd	r24, Y+1	; 0x01
     c58:	9a 81       	ldd	r25, Y+2	; 0x02
     c5a:	89 2f       	mov	r24, r25
     c5c:	99 27       	eor	r25, r25
     c5e:	80 83       	st	Z, r24
	UBRRL = ubrr_value;
     c60:	e9 e2       	ldi	r30, 0x29	; 41
     c62:	f0 e0       	ldi	r31, 0x00	; 0
     c64:	89 81       	ldd	r24, Y+1	; 0x01
     c66:	80 83       	st	Z, r24
}
     c68:	0f 90       	pop	r0
     c6a:	0f 90       	pop	r0
     c6c:	0f 90       	pop	r0
     c6e:	0f 90       	pop	r0
     c70:	cf 91       	pop	r28
     c72:	df 91       	pop	r29
     c74:	08 95       	ret

00000c76 <UART_receiveByte>:

uint8 UART_receiveByte(void) {
     c76:	df 93       	push	r29
     c78:	cf 93       	push	r28
     c7a:	cd b7       	in	r28, 0x3d	; 61
     c7c:	de b7       	in	r29, 0x3e	; 62
	/*Bit 7  RXC: USART Receive Complete
	 This flag bit is set when there are unread data in the receive buffer
	 and cleared when the receive buffer is empty (i.e., does not contain any unread data).
	 * */
	while ((BIT_IS_CLEAR(UCSRA, RXC)))
     c7e:	eb e2       	ldi	r30, 0x2B	; 43
     c80:	f0 e0       	ldi	r31, 0x00	; 0
     c82:	80 81       	ld	r24, Z
     c84:	88 23       	and	r24, r24
     c86:	dc f7       	brge	.-10     	; 0xc7e <UART_receiveByte+0x8>
		;
	return UDR;
     c88:	ec e2       	ldi	r30, 0x2C	; 44
     c8a:	f0 e0       	ldi	r31, 0x00	; 0
     c8c:	80 81       	ld	r24, Z
}
     c8e:	cf 91       	pop	r28
     c90:	df 91       	pop	r29
     c92:	08 95       	ret

00000c94 <UART_sendByte>:

void UART_sendByte(uint8 data) {
     c94:	df 93       	push	r29
     c96:	cf 93       	push	r28
     c98:	0f 92       	push	r0
     c9a:	cd b7       	in	r28, 0x3d	; 61
     c9c:	de b7       	in	r29, 0x3e	; 62
     c9e:	89 83       	std	Y+1, r24	; 0x01
	/*Bit 5  UDRE: USART Data Register Empty
	 * The UDRE Flag indicates if the transmit buffer (UDR) is ready to receive new data.
	 * If UDRE is one, the buffer is empty, and therefore ready to be written.
	 * */
	while (BIT_IS_CLEAR(UCSRA, UDRE))
     ca0:	eb e2       	ldi	r30, 0x2B	; 43
     ca2:	f0 e0       	ldi	r31, 0x00	; 0
     ca4:	80 81       	ld	r24, Z
     ca6:	88 2f       	mov	r24, r24
     ca8:	90 e0       	ldi	r25, 0x00	; 0
     caa:	80 72       	andi	r24, 0x20	; 32
     cac:	90 70       	andi	r25, 0x00	; 0
     cae:	00 97       	sbiw	r24, 0x00	; 0
     cb0:	b9 f3       	breq	.-18     	; 0xca0 <UART_sendByte+0xc>
		;
	UDR = data;
     cb2:	ec e2       	ldi	r30, 0x2C	; 44
     cb4:	f0 e0       	ldi	r31, 0x00	; 0
     cb6:	89 81       	ldd	r24, Y+1	; 0x01
     cb8:	80 83       	st	Z, r24
}
     cba:	0f 90       	pop	r0
     cbc:	cf 91       	pop	r28
     cbe:	df 91       	pop	r29
     cc0:	08 95       	ret

00000cc2 <UART_sendString>:

void UART_sendString(const uint8 *str) {
     cc2:	df 93       	push	r29
     cc4:	cf 93       	push	r28
     cc6:	00 d0       	rcall	.+0      	; 0xcc8 <UART_sendString+0x6>
     cc8:	0f 92       	push	r0
     cca:	cd b7       	in	r28, 0x3d	; 61
     ccc:	de b7       	in	r29, 0x3e	; 62
     cce:	9b 83       	std	Y+3, r25	; 0x03
     cd0:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
     cd2:	19 82       	std	Y+1, r1	; 0x01
     cd4:	0e c0       	rjmp	.+28     	; 0xcf2 <UART_sendString+0x30>

	while (str[i] != '\0') {
		UART_sendByte(str[i]);
     cd6:	89 81       	ldd	r24, Y+1	; 0x01
     cd8:	28 2f       	mov	r18, r24
     cda:	30 e0       	ldi	r19, 0x00	; 0
     cdc:	8a 81       	ldd	r24, Y+2	; 0x02
     cde:	9b 81       	ldd	r25, Y+3	; 0x03
     ce0:	fc 01       	movw	r30, r24
     ce2:	e2 0f       	add	r30, r18
     ce4:	f3 1f       	adc	r31, r19
     ce6:	80 81       	ld	r24, Z
     ce8:	0e 94 4a 06 	call	0xc94	; 0xc94 <UART_sendByte>
		i++;
     cec:	89 81       	ldd	r24, Y+1	; 0x01
     cee:	8f 5f       	subi	r24, 0xFF	; 255
     cf0:	89 83       	std	Y+1, r24	; 0x01
}

void UART_sendString(const uint8 *str) {
	uint8 i = 0;

	while (str[i] != '\0') {
     cf2:	89 81       	ldd	r24, Y+1	; 0x01
     cf4:	28 2f       	mov	r18, r24
     cf6:	30 e0       	ldi	r19, 0x00	; 0
     cf8:	8a 81       	ldd	r24, Y+2	; 0x02
     cfa:	9b 81       	ldd	r25, Y+3	; 0x03
     cfc:	fc 01       	movw	r30, r24
     cfe:	e2 0f       	add	r30, r18
     d00:	f3 1f       	adc	r31, r19
     d02:	80 81       	ld	r24, Z
     d04:	88 23       	and	r24, r24
     d06:	39 f7       	brne	.-50     	; 0xcd6 <UART_sendString+0x14>
		UART_sendByte(str[i]);
		i++;
	}
}
     d08:	0f 90       	pop	r0
     d0a:	0f 90       	pop	r0
     d0c:	0f 90       	pop	r0
     d0e:	cf 91       	pop	r28
     d10:	df 91       	pop	r29
     d12:	08 95       	ret

00000d14 <UART_receiveString>:

void UART_receiveString(uint8 *Str) {
     d14:	0f 93       	push	r16
     d16:	1f 93       	push	r17
     d18:	df 93       	push	r29
     d1a:	cf 93       	push	r28
     d1c:	00 d0       	rcall	.+0      	; 0xd1e <UART_receiveString+0xa>
     d1e:	0f 92       	push	r0
     d20:	cd b7       	in	r28, 0x3d	; 61
     d22:	de b7       	in	r29, 0x3e	; 62
     d24:	9b 83       	std	Y+3, r25	; 0x03
     d26:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
     d28:	19 82       	std	Y+1, r1	; 0x01

	/* Receive the first byte */
	Str[i] = UART_receiveByte();
     d2a:	89 81       	ldd	r24, Y+1	; 0x01
     d2c:	28 2f       	mov	r18, r24
     d2e:	30 e0       	ldi	r19, 0x00	; 0
     d30:	8a 81       	ldd	r24, Y+2	; 0x02
     d32:	9b 81       	ldd	r25, Y+3	; 0x03
     d34:	8c 01       	movw	r16, r24
     d36:	02 0f       	add	r16, r18
     d38:	13 1f       	adc	r17, r19
     d3a:	0e 94 3b 06 	call	0xc76	; 0xc76 <UART_receiveByte>
     d3e:	f8 01       	movw	r30, r16
     d40:	80 83       	st	Z, r24
     d42:	0f c0       	rjmp	.+30     	; 0xd62 <UART_receiveString+0x4e>

	/* Receive the whole string until the '#' */
	while (Str[i] != '#') {
		i++;
     d44:	89 81       	ldd	r24, Y+1	; 0x01
     d46:	8f 5f       	subi	r24, 0xFF	; 255
     d48:	89 83       	std	Y+1, r24	; 0x01
		Str[i] = UART_receiveByte();
     d4a:	89 81       	ldd	r24, Y+1	; 0x01
     d4c:	28 2f       	mov	r18, r24
     d4e:	30 e0       	ldi	r19, 0x00	; 0
     d50:	8a 81       	ldd	r24, Y+2	; 0x02
     d52:	9b 81       	ldd	r25, Y+3	; 0x03
     d54:	8c 01       	movw	r16, r24
     d56:	02 0f       	add	r16, r18
     d58:	13 1f       	adc	r17, r19
     d5a:	0e 94 3b 06 	call	0xc76	; 0xc76 <UART_receiveByte>
     d5e:	f8 01       	movw	r30, r16
     d60:	80 83       	st	Z, r24

	/* Receive the first byte */
	Str[i] = UART_receiveByte();

	/* Receive the whole string until the '#' */
	while (Str[i] != '#') {
     d62:	89 81       	ldd	r24, Y+1	; 0x01
     d64:	28 2f       	mov	r18, r24
     d66:	30 e0       	ldi	r19, 0x00	; 0
     d68:	8a 81       	ldd	r24, Y+2	; 0x02
     d6a:	9b 81       	ldd	r25, Y+3	; 0x03
     d6c:	fc 01       	movw	r30, r24
     d6e:	e2 0f       	add	r30, r18
     d70:	f3 1f       	adc	r31, r19
     d72:	80 81       	ld	r24, Z
     d74:	83 32       	cpi	r24, 0x23	; 35
     d76:	31 f7       	brne	.-52     	; 0xd44 <UART_receiveString+0x30>
		i++;
		Str[i] = UART_receiveByte();
	}

	/* After receiving the whole string plus the '#', replace the '#' with '\0' */
	Str[i] = '\0';
     d78:	89 81       	ldd	r24, Y+1	; 0x01
     d7a:	28 2f       	mov	r18, r24
     d7c:	30 e0       	ldi	r19, 0x00	; 0
     d7e:	8a 81       	ldd	r24, Y+2	; 0x02
     d80:	9b 81       	ldd	r25, Y+3	; 0x03
     d82:	fc 01       	movw	r30, r24
     d84:	e2 0f       	add	r30, r18
     d86:	f3 1f       	adc	r31, r19
     d88:	10 82       	st	Z, r1
}
     d8a:	0f 90       	pop	r0
     d8c:	0f 90       	pop	r0
     d8e:	0f 90       	pop	r0
     d90:	cf 91       	pop	r28
     d92:	df 91       	pop	r29
     d94:	1f 91       	pop	r17
     d96:	0f 91       	pop	r16
     d98:	08 95       	ret

00000d9a <__vector_7>:

/*******************************************************************************
 *                       Interrupt Service Routines                            *
 *******************************************************************************/

ISR(TIMER1_COMPA_vect) {
     d9a:	1f 92       	push	r1
     d9c:	0f 92       	push	r0
     d9e:	0f b6       	in	r0, 0x3f	; 63
     da0:	0f 92       	push	r0
     da2:	11 24       	eor	r1, r1
     da4:	2f 93       	push	r18
     da6:	3f 93       	push	r19
     da8:	4f 93       	push	r20
     daa:	5f 93       	push	r21
     dac:	6f 93       	push	r22
     dae:	7f 93       	push	r23
     db0:	8f 93       	push	r24
     db2:	9f 93       	push	r25
     db4:	af 93       	push	r26
     db6:	bf 93       	push	r27
     db8:	ef 93       	push	r30
     dba:	ff 93       	push	r31
     dbc:	df 93       	push	r29
     dbe:	cf 93       	push	r28
     dc0:	cd b7       	in	r28, 0x3d	; 61
     dc2:	de b7       	in	r29, 0x3e	; 62
	if (g_callBackPtr != NULL_PTR) {
     dc4:	80 91 4a 01 	lds	r24, 0x014A
     dc8:	90 91 4b 01 	lds	r25, 0x014B
     dcc:	00 97       	sbiw	r24, 0x00	; 0
     dce:	29 f0       	breq	.+10     	; 0xdda <__vector_7+0x40>
		(*g_callBackPtr)(); /* another method to call the function using pointer to function g_callBackPtr(); */
     dd0:	e0 91 4a 01 	lds	r30, 0x014A
     dd4:	f0 91 4b 01 	lds	r31, 0x014B
     dd8:	09 95       	icall
	}
}
     dda:	cf 91       	pop	r28
     ddc:	df 91       	pop	r29
     dde:	ff 91       	pop	r31
     de0:	ef 91       	pop	r30
     de2:	bf 91       	pop	r27
     de4:	af 91       	pop	r26
     de6:	9f 91       	pop	r25
     de8:	8f 91       	pop	r24
     dea:	7f 91       	pop	r23
     dec:	6f 91       	pop	r22
     dee:	5f 91       	pop	r21
     df0:	4f 91       	pop	r20
     df2:	3f 91       	pop	r19
     df4:	2f 91       	pop	r18
     df6:	0f 90       	pop	r0
     df8:	0f be       	out	0x3f, r0	; 63
     dfa:	0f 90       	pop	r0
     dfc:	1f 90       	pop	r1
     dfe:	18 95       	reti

00000e00 <__vector_9>:

ISR(TIMER1_OVF_vect) {
     e00:	1f 92       	push	r1
     e02:	0f 92       	push	r0
     e04:	0f b6       	in	r0, 0x3f	; 63
     e06:	0f 92       	push	r0
     e08:	11 24       	eor	r1, r1
     e0a:	2f 93       	push	r18
     e0c:	3f 93       	push	r19
     e0e:	4f 93       	push	r20
     e10:	5f 93       	push	r21
     e12:	6f 93       	push	r22
     e14:	7f 93       	push	r23
     e16:	8f 93       	push	r24
     e18:	9f 93       	push	r25
     e1a:	af 93       	push	r26
     e1c:	bf 93       	push	r27
     e1e:	ef 93       	push	r30
     e20:	ff 93       	push	r31
     e22:	df 93       	push	r29
     e24:	cf 93       	push	r28
     e26:	cd b7       	in	r28, 0x3d	; 61
     e28:	de b7       	in	r29, 0x3e	; 62
	if (g_callBackPtr != NULL_PTR) {
     e2a:	80 91 4a 01 	lds	r24, 0x014A
     e2e:	90 91 4b 01 	lds	r25, 0x014B
     e32:	00 97       	sbiw	r24, 0x00	; 0
     e34:	29 f0       	breq	.+10     	; 0xe40 <__vector_9+0x40>
		(*g_callBackPtr)();
     e36:	e0 91 4a 01 	lds	r30, 0x014A
     e3a:	f0 91 4b 01 	lds	r31, 0x014B
     e3e:	09 95       	icall
	}
}
     e40:	cf 91       	pop	r28
     e42:	df 91       	pop	r29
     e44:	ff 91       	pop	r31
     e46:	ef 91       	pop	r30
     e48:	bf 91       	pop	r27
     e4a:	af 91       	pop	r26
     e4c:	9f 91       	pop	r25
     e4e:	8f 91       	pop	r24
     e50:	7f 91       	pop	r23
     e52:	6f 91       	pop	r22
     e54:	5f 91       	pop	r21
     e56:	4f 91       	pop	r20
     e58:	3f 91       	pop	r19
     e5a:	2f 91       	pop	r18
     e5c:	0f 90       	pop	r0
     e5e:	0f be       	out	0x3f, r0	; 63
     e60:	0f 90       	pop	r0
     e62:	1f 90       	pop	r1
     e64:	18 95       	reti

00000e66 <Timer1_init>:

void Timer1_init(const Timer1_ConfigType *Config_Ptr) {
     e66:	df 93       	push	r29
     e68:	cf 93       	push	r28
     e6a:	00 d0       	rcall	.+0      	; 0xe6c <Timer1_init+0x6>
     e6c:	cd b7       	in	r28, 0x3d	; 61
     e6e:	de b7       	in	r29, 0x3e	; 62
     e70:	9a 83       	std	Y+2, r25	; 0x02
     e72:	89 83       	std	Y+1, r24	; 0x01

	// Put Initial Value to TCNT1
	TCNT1 = Config_Ptr->initial_value;
     e74:	ac e4       	ldi	r26, 0x4C	; 76
     e76:	b0 e0       	ldi	r27, 0x00	; 0
     e78:	e9 81       	ldd	r30, Y+1	; 0x01
     e7a:	fa 81       	ldd	r31, Y+2	; 0x02
     e7c:	80 81       	ld	r24, Z
     e7e:	91 81       	ldd	r25, Z+1	; 0x01
     e80:	11 96       	adiw	r26, 0x01	; 1
     e82:	9c 93       	st	X, r25
     e84:	8e 93       	st	-X, r24
	// Using Channel A in Timer1
	//COM1A1 COM1A0 (0-0)
	SET_BIT(TCCR1A, FOC1A);
     e86:	af e4       	ldi	r26, 0x4F	; 79
     e88:	b0 e0       	ldi	r27, 0x00	; 0
     e8a:	ef e4       	ldi	r30, 0x4F	; 79
     e8c:	f0 e0       	ldi	r31, 0x00	; 0
     e8e:	80 81       	ld	r24, Z
     e90:	88 60       	ori	r24, 0x08	; 8
     e92:	8c 93       	st	X, r24
	//0- Normal  OR 1 -Compare IN WGM12
	//Another Solution than masking is to make if condition to value of enum
	// With Set of Clear bit WGM12
	TCCR1B = (TCCR1B & 0XEF) | ((Config_Ptr->mode) << 4);
     e94:	ae e4       	ldi	r26, 0x4E	; 78
     e96:	b0 e0       	ldi	r27, 0x00	; 0
     e98:	ee e4       	ldi	r30, 0x4E	; 78
     e9a:	f0 e0       	ldi	r31, 0x00	; 0
     e9c:	80 81       	ld	r24, Z
     e9e:	28 2f       	mov	r18, r24
     ea0:	2f 7e       	andi	r18, 0xEF	; 239
     ea2:	e9 81       	ldd	r30, Y+1	; 0x01
     ea4:	fa 81       	ldd	r31, Y+2	; 0x02
     ea6:	85 81       	ldd	r24, Z+5	; 0x05
     ea8:	88 2f       	mov	r24, r24
     eaa:	90 e0       	ldi	r25, 0x00	; 0
     eac:	82 95       	swap	r24
     eae:	92 95       	swap	r25
     eb0:	90 7f       	andi	r25, 0xF0	; 240
     eb2:	98 27       	eor	r25, r24
     eb4:	80 7f       	andi	r24, 0xF0	; 240
     eb6:	98 27       	eor	r25, r24
     eb8:	82 2b       	or	r24, r18
     eba:	8c 93       	st	X, r24
	// Now Mask All Register bits except CS12 CS11 CS10
	TCCR1B = (TCCR1B & 0xEF) | (Config_Ptr->prescaler);
     ebc:	ae e4       	ldi	r26, 0x4E	; 78
     ebe:	b0 e0       	ldi	r27, 0x00	; 0
     ec0:	ee e4       	ldi	r30, 0x4E	; 78
     ec2:	f0 e0       	ldi	r31, 0x00	; 0
     ec4:	80 81       	ld	r24, Z
     ec6:	98 2f       	mov	r25, r24
     ec8:	9f 7e       	andi	r25, 0xEF	; 239
     eca:	e9 81       	ldd	r30, Y+1	; 0x01
     ecc:	fa 81       	ldd	r31, Y+2	; 0x02
     ece:	84 81       	ldd	r24, Z+4	; 0x04
     ed0:	89 2b       	or	r24, r25
     ed2:	8c 93       	st	X, r24
	OCR1A = (Config_Ptr->compare_value);
     ed4:	aa e4       	ldi	r26, 0x4A	; 74
     ed6:	b0 e0       	ldi	r27, 0x00	; 0
     ed8:	e9 81       	ldd	r30, Y+1	; 0x01
     eda:	fa 81       	ldd	r31, Y+2	; 0x02
     edc:	82 81       	ldd	r24, Z+2	; 0x02
     ede:	93 81       	ldd	r25, Z+3	; 0x03
     ee0:	11 96       	adiw	r26, 0x01	; 1
     ee2:	9c 93       	st	X, r25
     ee4:	8e 93       	st	-X, r24
	if ((Config_Ptr->mode) == 0) {
     ee6:	e9 81       	ldd	r30, Y+1	; 0x01
     ee8:	fa 81       	ldd	r31, Y+2	; 0x02
     eea:	85 81       	ldd	r24, Z+5	; 0x05
     eec:	88 23       	and	r24, r24
     eee:	79 f4       	brne	.+30     	; 0xf0e <Timer1_init+0xa8>
		// Normal Mode
		//OCIE2 TOIE2 TICIE1 OCIE1A OCIE1B TOIE1 OCIE0 TOIE0
		// 1     1		0		0		0	0		1	 1
		// Clear Any Older Flag
		TIMSK = (TIMSK & 0XC3);
     ef0:	a9 e5       	ldi	r26, 0x59	; 89
     ef2:	b0 e0       	ldi	r27, 0x00	; 0
     ef4:	e9 e5       	ldi	r30, 0x59	; 89
     ef6:	f0 e0       	ldi	r31, 0x00	; 0
     ef8:	80 81       	ld	r24, Z
     efa:	83 7c       	andi	r24, 0xC3	; 195
     efc:	8c 93       	st	X, r24
		//Bit 2  TOIE1: Timer/Counter1, Overflow Interrupt Enable
		SET_BIT(TIMSK, TOIE1);
     efe:	a9 e5       	ldi	r26, 0x59	; 89
     f00:	b0 e0       	ldi	r27, 0x00	; 0
     f02:	e9 e5       	ldi	r30, 0x59	; 89
     f04:	f0 e0       	ldi	r31, 0x00	; 0
     f06:	80 81       	ld	r24, Z
     f08:	84 60       	ori	r24, 0x04	; 4
     f0a:	8c 93       	st	X, r24
     f0c:	0e c0       	rjmp	.+28     	; 0xf2a <Timer1_init+0xc4>
	} else {
		// Clear Any Older Flag
		TIMSK = (TIMSK & 0XC3);
     f0e:	a9 e5       	ldi	r26, 0x59	; 89
     f10:	b0 e0       	ldi	r27, 0x00	; 0
     f12:	e9 e5       	ldi	r30, 0x59	; 89
     f14:	f0 e0       	ldi	r31, 0x00	; 0
     f16:	80 81       	ld	r24, Z
     f18:	83 7c       	andi	r24, 0xC3	; 195
     f1a:	8c 93       	st	X, r24
		//Bit 4  OCIE1A: Timer/Counter1, Output Compare A Match Interrupt Enable
		SET_BIT(TIMSK, OCIE1A);
     f1c:	a9 e5       	ldi	r26, 0x59	; 89
     f1e:	b0 e0       	ldi	r27, 0x00	; 0
     f20:	e9 e5       	ldi	r30, 0x59	; 89
     f22:	f0 e0       	ldi	r31, 0x00	; 0
     f24:	80 81       	ld	r24, Z
     f26:	80 61       	ori	r24, 0x10	; 16
     f28:	8c 93       	st	X, r24
	}
	//Enable INTERRUPTS At End of Init
	SET_BIT(SREG, 7);
     f2a:	af e5       	ldi	r26, 0x5F	; 95
     f2c:	b0 e0       	ldi	r27, 0x00	; 0
     f2e:	ef e5       	ldi	r30, 0x5F	; 95
     f30:	f0 e0       	ldi	r31, 0x00	; 0
     f32:	80 81       	ld	r24, Z
     f34:	80 68       	ori	r24, 0x80	; 128
     f36:	8c 93       	st	X, r24

}
     f38:	0f 90       	pop	r0
     f3a:	0f 90       	pop	r0
     f3c:	cf 91       	pop	r28
     f3e:	df 91       	pop	r29
     f40:	08 95       	ret

00000f42 <Timer1_setCallBack>:

void Timer1_setCallBack(void (*a_ptr)(void)) {
     f42:	df 93       	push	r29
     f44:	cf 93       	push	r28
     f46:	00 d0       	rcall	.+0      	; 0xf48 <Timer1_setCallBack+0x6>
     f48:	cd b7       	in	r28, 0x3d	; 61
     f4a:	de b7       	in	r29, 0x3e	; 62
     f4c:	9a 83       	std	Y+2, r25	; 0x02
     f4e:	89 83       	std	Y+1, r24	; 0x01
	g_callBackPtr = a_ptr;
     f50:	89 81       	ldd	r24, Y+1	; 0x01
     f52:	9a 81       	ldd	r25, Y+2	; 0x02
     f54:	90 93 4b 01 	sts	0x014B, r25
     f58:	80 93 4a 01 	sts	0x014A, r24
}
     f5c:	0f 90       	pop	r0
     f5e:	0f 90       	pop	r0
     f60:	cf 91       	pop	r28
     f62:	df 91       	pop	r29
     f64:	08 95       	ret

00000f66 <Timer1_deInit>:

void Timer1_deInit(void) {
     f66:	df 93       	push	r29
     f68:	cf 93       	push	r28
     f6a:	cd b7       	in	r28, 0x3d	; 61
     f6c:	de b7       	in	r29, 0x3e	; 62
	TCCR1A = 0;
     f6e:	ef e4       	ldi	r30, 0x4F	; 79
     f70:	f0 e0       	ldi	r31, 0x00	; 0
     f72:	10 82       	st	Z, r1
	TCCR1B = 0;
     f74:	ee e4       	ldi	r30, 0x4E	; 78
     f76:	f0 e0       	ldi	r31, 0x00	; 0
     f78:	10 82       	st	Z, r1
	TCNT1 = 0;
     f7a:	ec e4       	ldi	r30, 0x4C	; 76
     f7c:	f0 e0       	ldi	r31, 0x00	; 0
     f7e:	11 82       	std	Z+1, r1	; 0x01
     f80:	10 82       	st	Z, r1
	OCR1A = 0;
     f82:	ea e4       	ldi	r30, 0x4A	; 74
     f84:	f0 e0       	ldi	r31, 0x00	; 0
     f86:	11 82       	std	Z+1, r1	; 0x01
     f88:	10 82       	st	Z, r1

}
     f8a:	cf 91       	pop	r28
     f8c:	df 91       	pop	r29
     f8e:	08 95       	ret

00000f90 <GPIO_setupPinDirection>:
 * Description :
 * Setup the direction of the required pin input/output.
 * If the input port number or pin number are not correct, The function will not handle the request.
 */
void GPIO_setupPinDirection(uint8 port_num, uint8 pin_num, GPIO_PinDirectionType direction)
{
     f90:	df 93       	push	r29
     f92:	cf 93       	push	r28
     f94:	00 d0       	rcall	.+0      	; 0xf96 <GPIO_setupPinDirection+0x6>
     f96:	00 d0       	rcall	.+0      	; 0xf98 <GPIO_setupPinDirection+0x8>
     f98:	0f 92       	push	r0
     f9a:	cd b7       	in	r28, 0x3d	; 61
     f9c:	de b7       	in	r29, 0x3e	; 62
     f9e:	89 83       	std	Y+1, r24	; 0x01
     fa0:	6a 83       	std	Y+2, r22	; 0x02
     fa2:	4b 83       	std	Y+3, r20	; 0x03
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
     fa4:	8a 81       	ldd	r24, Y+2	; 0x02
     fa6:	88 30       	cpi	r24, 0x08	; 8
     fa8:	08 f0       	brcs	.+2      	; 0xfac <GPIO_setupPinDirection+0x1c>
     faa:	d5 c0       	rjmp	.+426    	; 0x1156 <GPIO_setupPinDirection+0x1c6>
     fac:	89 81       	ldd	r24, Y+1	; 0x01
     fae:	84 30       	cpi	r24, 0x04	; 4
     fb0:	08 f0       	brcs	.+2      	; 0xfb4 <GPIO_setupPinDirection+0x24>
     fb2:	d1 c0       	rjmp	.+418    	; 0x1156 <GPIO_setupPinDirection+0x1c6>
		/* Do Nothing */
	}
	else
	{
		/* Setup the pin direction as required */
		switch(port_num)
     fb4:	89 81       	ldd	r24, Y+1	; 0x01
     fb6:	28 2f       	mov	r18, r24
     fb8:	30 e0       	ldi	r19, 0x00	; 0
     fba:	3d 83       	std	Y+5, r19	; 0x05
     fbc:	2c 83       	std	Y+4, r18	; 0x04
     fbe:	8c 81       	ldd	r24, Y+4	; 0x04
     fc0:	9d 81       	ldd	r25, Y+5	; 0x05
     fc2:	81 30       	cpi	r24, 0x01	; 1
     fc4:	91 05       	cpc	r25, r1
     fc6:	09 f4       	brne	.+2      	; 0xfca <GPIO_setupPinDirection+0x3a>
     fc8:	43 c0       	rjmp	.+134    	; 0x1050 <GPIO_setupPinDirection+0xc0>
     fca:	2c 81       	ldd	r18, Y+4	; 0x04
     fcc:	3d 81       	ldd	r19, Y+5	; 0x05
     fce:	22 30       	cpi	r18, 0x02	; 2
     fd0:	31 05       	cpc	r19, r1
     fd2:	2c f4       	brge	.+10     	; 0xfde <GPIO_setupPinDirection+0x4e>
     fd4:	8c 81       	ldd	r24, Y+4	; 0x04
     fd6:	9d 81       	ldd	r25, Y+5	; 0x05
     fd8:	00 97       	sbiw	r24, 0x00	; 0
     fda:	71 f0       	breq	.+28     	; 0xff8 <GPIO_setupPinDirection+0x68>
     fdc:	bc c0       	rjmp	.+376    	; 0x1156 <GPIO_setupPinDirection+0x1c6>
     fde:	2c 81       	ldd	r18, Y+4	; 0x04
     fe0:	3d 81       	ldd	r19, Y+5	; 0x05
     fe2:	22 30       	cpi	r18, 0x02	; 2
     fe4:	31 05       	cpc	r19, r1
     fe6:	09 f4       	brne	.+2      	; 0xfea <GPIO_setupPinDirection+0x5a>
     fe8:	5f c0       	rjmp	.+190    	; 0x10a8 <GPIO_setupPinDirection+0x118>
     fea:	8c 81       	ldd	r24, Y+4	; 0x04
     fec:	9d 81       	ldd	r25, Y+5	; 0x05
     fee:	83 30       	cpi	r24, 0x03	; 3
     ff0:	91 05       	cpc	r25, r1
     ff2:	09 f4       	brne	.+2      	; 0xff6 <GPIO_setupPinDirection+0x66>
     ff4:	85 c0       	rjmp	.+266    	; 0x1100 <GPIO_setupPinDirection+0x170>
     ff6:	af c0       	rjmp	.+350    	; 0x1156 <GPIO_setupPinDirection+0x1c6>
		{
		case PORTA_ID:
			if(direction == PIN_OUTPUT)
     ff8:	8b 81       	ldd	r24, Y+3	; 0x03
     ffa:	81 30       	cpi	r24, 0x01	; 1
     ffc:	a1 f4       	brne	.+40     	; 0x1026 <GPIO_setupPinDirection+0x96>
			{
				SET_BIT(DDRA,pin_num);
     ffe:	aa e3       	ldi	r26, 0x3A	; 58
    1000:	b0 e0       	ldi	r27, 0x00	; 0
    1002:	ea e3       	ldi	r30, 0x3A	; 58
    1004:	f0 e0       	ldi	r31, 0x00	; 0
    1006:	80 81       	ld	r24, Z
    1008:	48 2f       	mov	r20, r24
    100a:	8a 81       	ldd	r24, Y+2	; 0x02
    100c:	28 2f       	mov	r18, r24
    100e:	30 e0       	ldi	r19, 0x00	; 0
    1010:	81 e0       	ldi	r24, 0x01	; 1
    1012:	90 e0       	ldi	r25, 0x00	; 0
    1014:	02 2e       	mov	r0, r18
    1016:	02 c0       	rjmp	.+4      	; 0x101c <GPIO_setupPinDirection+0x8c>
    1018:	88 0f       	add	r24, r24
    101a:	99 1f       	adc	r25, r25
    101c:	0a 94       	dec	r0
    101e:	e2 f7       	brpl	.-8      	; 0x1018 <GPIO_setupPinDirection+0x88>
    1020:	84 2b       	or	r24, r20
    1022:	8c 93       	st	X, r24
    1024:	98 c0       	rjmp	.+304    	; 0x1156 <GPIO_setupPinDirection+0x1c6>
			}
			else
			{
				CLEAR_BIT(DDRA,pin_num);
    1026:	aa e3       	ldi	r26, 0x3A	; 58
    1028:	b0 e0       	ldi	r27, 0x00	; 0
    102a:	ea e3       	ldi	r30, 0x3A	; 58
    102c:	f0 e0       	ldi	r31, 0x00	; 0
    102e:	80 81       	ld	r24, Z
    1030:	48 2f       	mov	r20, r24
    1032:	8a 81       	ldd	r24, Y+2	; 0x02
    1034:	28 2f       	mov	r18, r24
    1036:	30 e0       	ldi	r19, 0x00	; 0
    1038:	81 e0       	ldi	r24, 0x01	; 1
    103a:	90 e0       	ldi	r25, 0x00	; 0
    103c:	02 2e       	mov	r0, r18
    103e:	02 c0       	rjmp	.+4      	; 0x1044 <GPIO_setupPinDirection+0xb4>
    1040:	88 0f       	add	r24, r24
    1042:	99 1f       	adc	r25, r25
    1044:	0a 94       	dec	r0
    1046:	e2 f7       	brpl	.-8      	; 0x1040 <GPIO_setupPinDirection+0xb0>
    1048:	80 95       	com	r24
    104a:	84 23       	and	r24, r20
    104c:	8c 93       	st	X, r24
    104e:	83 c0       	rjmp	.+262    	; 0x1156 <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTB_ID:
			if(direction == PIN_OUTPUT)
    1050:	8b 81       	ldd	r24, Y+3	; 0x03
    1052:	81 30       	cpi	r24, 0x01	; 1
    1054:	a1 f4       	brne	.+40     	; 0x107e <GPIO_setupPinDirection+0xee>
			{
				SET_BIT(DDRB,pin_num);
    1056:	a7 e3       	ldi	r26, 0x37	; 55
    1058:	b0 e0       	ldi	r27, 0x00	; 0
    105a:	e7 e3       	ldi	r30, 0x37	; 55
    105c:	f0 e0       	ldi	r31, 0x00	; 0
    105e:	80 81       	ld	r24, Z
    1060:	48 2f       	mov	r20, r24
    1062:	8a 81       	ldd	r24, Y+2	; 0x02
    1064:	28 2f       	mov	r18, r24
    1066:	30 e0       	ldi	r19, 0x00	; 0
    1068:	81 e0       	ldi	r24, 0x01	; 1
    106a:	90 e0       	ldi	r25, 0x00	; 0
    106c:	02 2e       	mov	r0, r18
    106e:	02 c0       	rjmp	.+4      	; 0x1074 <GPIO_setupPinDirection+0xe4>
    1070:	88 0f       	add	r24, r24
    1072:	99 1f       	adc	r25, r25
    1074:	0a 94       	dec	r0
    1076:	e2 f7       	brpl	.-8      	; 0x1070 <GPIO_setupPinDirection+0xe0>
    1078:	84 2b       	or	r24, r20
    107a:	8c 93       	st	X, r24
    107c:	6c c0       	rjmp	.+216    	; 0x1156 <GPIO_setupPinDirection+0x1c6>
			}
			else
			{
				CLEAR_BIT(DDRB,pin_num);
    107e:	a7 e3       	ldi	r26, 0x37	; 55
    1080:	b0 e0       	ldi	r27, 0x00	; 0
    1082:	e7 e3       	ldi	r30, 0x37	; 55
    1084:	f0 e0       	ldi	r31, 0x00	; 0
    1086:	80 81       	ld	r24, Z
    1088:	48 2f       	mov	r20, r24
    108a:	8a 81       	ldd	r24, Y+2	; 0x02
    108c:	28 2f       	mov	r18, r24
    108e:	30 e0       	ldi	r19, 0x00	; 0
    1090:	81 e0       	ldi	r24, 0x01	; 1
    1092:	90 e0       	ldi	r25, 0x00	; 0
    1094:	02 2e       	mov	r0, r18
    1096:	02 c0       	rjmp	.+4      	; 0x109c <GPIO_setupPinDirection+0x10c>
    1098:	88 0f       	add	r24, r24
    109a:	99 1f       	adc	r25, r25
    109c:	0a 94       	dec	r0
    109e:	e2 f7       	brpl	.-8      	; 0x1098 <GPIO_setupPinDirection+0x108>
    10a0:	80 95       	com	r24
    10a2:	84 23       	and	r24, r20
    10a4:	8c 93       	st	X, r24
    10a6:	57 c0       	rjmp	.+174    	; 0x1156 <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTC_ID:
			if(direction == PIN_OUTPUT)
    10a8:	8b 81       	ldd	r24, Y+3	; 0x03
    10aa:	81 30       	cpi	r24, 0x01	; 1
    10ac:	a1 f4       	brne	.+40     	; 0x10d6 <GPIO_setupPinDirection+0x146>
			{
				SET_BIT(DDRC,pin_num);
    10ae:	a4 e3       	ldi	r26, 0x34	; 52
    10b0:	b0 e0       	ldi	r27, 0x00	; 0
    10b2:	e4 e3       	ldi	r30, 0x34	; 52
    10b4:	f0 e0       	ldi	r31, 0x00	; 0
    10b6:	80 81       	ld	r24, Z
    10b8:	48 2f       	mov	r20, r24
    10ba:	8a 81       	ldd	r24, Y+2	; 0x02
    10bc:	28 2f       	mov	r18, r24
    10be:	30 e0       	ldi	r19, 0x00	; 0
    10c0:	81 e0       	ldi	r24, 0x01	; 1
    10c2:	90 e0       	ldi	r25, 0x00	; 0
    10c4:	02 2e       	mov	r0, r18
    10c6:	02 c0       	rjmp	.+4      	; 0x10cc <GPIO_setupPinDirection+0x13c>
    10c8:	88 0f       	add	r24, r24
    10ca:	99 1f       	adc	r25, r25
    10cc:	0a 94       	dec	r0
    10ce:	e2 f7       	brpl	.-8      	; 0x10c8 <GPIO_setupPinDirection+0x138>
    10d0:	84 2b       	or	r24, r20
    10d2:	8c 93       	st	X, r24
    10d4:	40 c0       	rjmp	.+128    	; 0x1156 <GPIO_setupPinDirection+0x1c6>
			}
			else
			{
				CLEAR_BIT(DDRC,pin_num);
    10d6:	a4 e3       	ldi	r26, 0x34	; 52
    10d8:	b0 e0       	ldi	r27, 0x00	; 0
    10da:	e4 e3       	ldi	r30, 0x34	; 52
    10dc:	f0 e0       	ldi	r31, 0x00	; 0
    10de:	80 81       	ld	r24, Z
    10e0:	48 2f       	mov	r20, r24
    10e2:	8a 81       	ldd	r24, Y+2	; 0x02
    10e4:	28 2f       	mov	r18, r24
    10e6:	30 e0       	ldi	r19, 0x00	; 0
    10e8:	81 e0       	ldi	r24, 0x01	; 1
    10ea:	90 e0       	ldi	r25, 0x00	; 0
    10ec:	02 2e       	mov	r0, r18
    10ee:	02 c0       	rjmp	.+4      	; 0x10f4 <GPIO_setupPinDirection+0x164>
    10f0:	88 0f       	add	r24, r24
    10f2:	99 1f       	adc	r25, r25
    10f4:	0a 94       	dec	r0
    10f6:	e2 f7       	brpl	.-8      	; 0x10f0 <GPIO_setupPinDirection+0x160>
    10f8:	80 95       	com	r24
    10fa:	84 23       	and	r24, r20
    10fc:	8c 93       	st	X, r24
    10fe:	2b c0       	rjmp	.+86     	; 0x1156 <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTD_ID:
			if(direction == PIN_OUTPUT)
    1100:	8b 81       	ldd	r24, Y+3	; 0x03
    1102:	81 30       	cpi	r24, 0x01	; 1
    1104:	a1 f4       	brne	.+40     	; 0x112e <GPIO_setupPinDirection+0x19e>
			{
				SET_BIT(DDRD,pin_num);
    1106:	a1 e3       	ldi	r26, 0x31	; 49
    1108:	b0 e0       	ldi	r27, 0x00	; 0
    110a:	e1 e3       	ldi	r30, 0x31	; 49
    110c:	f0 e0       	ldi	r31, 0x00	; 0
    110e:	80 81       	ld	r24, Z
    1110:	48 2f       	mov	r20, r24
    1112:	8a 81       	ldd	r24, Y+2	; 0x02
    1114:	28 2f       	mov	r18, r24
    1116:	30 e0       	ldi	r19, 0x00	; 0
    1118:	81 e0       	ldi	r24, 0x01	; 1
    111a:	90 e0       	ldi	r25, 0x00	; 0
    111c:	02 2e       	mov	r0, r18
    111e:	02 c0       	rjmp	.+4      	; 0x1124 <GPIO_setupPinDirection+0x194>
    1120:	88 0f       	add	r24, r24
    1122:	99 1f       	adc	r25, r25
    1124:	0a 94       	dec	r0
    1126:	e2 f7       	brpl	.-8      	; 0x1120 <GPIO_setupPinDirection+0x190>
    1128:	84 2b       	or	r24, r20
    112a:	8c 93       	st	X, r24
    112c:	14 c0       	rjmp	.+40     	; 0x1156 <GPIO_setupPinDirection+0x1c6>
			}
			else
			{
				CLEAR_BIT(DDRD,pin_num);
    112e:	a1 e3       	ldi	r26, 0x31	; 49
    1130:	b0 e0       	ldi	r27, 0x00	; 0
    1132:	e1 e3       	ldi	r30, 0x31	; 49
    1134:	f0 e0       	ldi	r31, 0x00	; 0
    1136:	80 81       	ld	r24, Z
    1138:	48 2f       	mov	r20, r24
    113a:	8a 81       	ldd	r24, Y+2	; 0x02
    113c:	28 2f       	mov	r18, r24
    113e:	30 e0       	ldi	r19, 0x00	; 0
    1140:	81 e0       	ldi	r24, 0x01	; 1
    1142:	90 e0       	ldi	r25, 0x00	; 0
    1144:	02 2e       	mov	r0, r18
    1146:	02 c0       	rjmp	.+4      	; 0x114c <GPIO_setupPinDirection+0x1bc>
    1148:	88 0f       	add	r24, r24
    114a:	99 1f       	adc	r25, r25
    114c:	0a 94       	dec	r0
    114e:	e2 f7       	brpl	.-8      	; 0x1148 <GPIO_setupPinDirection+0x1b8>
    1150:	80 95       	com	r24
    1152:	84 23       	and	r24, r20
    1154:	8c 93       	st	X, r24
			}
			break;
		}
	}
}
    1156:	0f 90       	pop	r0
    1158:	0f 90       	pop	r0
    115a:	0f 90       	pop	r0
    115c:	0f 90       	pop	r0
    115e:	0f 90       	pop	r0
    1160:	cf 91       	pop	r28
    1162:	df 91       	pop	r29
    1164:	08 95       	ret

00001166 <GPIO_writePin>:
 * Write the value Logic High or Logic Low on the required pin.
 * If the input port number or pin number are not correct, The function will not handle the request.
 * If the pin is input, this function will enable/disable the internal pull-up resistor.
 */
void GPIO_writePin(uint8 port_num, uint8 pin_num, uint8 value)
{
    1166:	df 93       	push	r29
    1168:	cf 93       	push	r28
    116a:	00 d0       	rcall	.+0      	; 0x116c <GPIO_writePin+0x6>
    116c:	00 d0       	rcall	.+0      	; 0x116e <GPIO_writePin+0x8>
    116e:	0f 92       	push	r0
    1170:	cd b7       	in	r28, 0x3d	; 61
    1172:	de b7       	in	r29, 0x3e	; 62
    1174:	89 83       	std	Y+1, r24	; 0x01
    1176:	6a 83       	std	Y+2, r22	; 0x02
    1178:	4b 83       	std	Y+3, r20	; 0x03
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
    117a:	8a 81       	ldd	r24, Y+2	; 0x02
    117c:	88 30       	cpi	r24, 0x08	; 8
    117e:	08 f0       	brcs	.+2      	; 0x1182 <GPIO_writePin+0x1c>
    1180:	d5 c0       	rjmp	.+426    	; 0x132c <GPIO_writePin+0x1c6>
    1182:	89 81       	ldd	r24, Y+1	; 0x01
    1184:	84 30       	cpi	r24, 0x04	; 4
    1186:	08 f0       	brcs	.+2      	; 0x118a <GPIO_writePin+0x24>
    1188:	d1 c0       	rjmp	.+418    	; 0x132c <GPIO_writePin+0x1c6>
		/* Do Nothing */
	}
	else
	{
		/* Write the pin value as required */
		switch(port_num)
    118a:	89 81       	ldd	r24, Y+1	; 0x01
    118c:	28 2f       	mov	r18, r24
    118e:	30 e0       	ldi	r19, 0x00	; 0
    1190:	3d 83       	std	Y+5, r19	; 0x05
    1192:	2c 83       	std	Y+4, r18	; 0x04
    1194:	8c 81       	ldd	r24, Y+4	; 0x04
    1196:	9d 81       	ldd	r25, Y+5	; 0x05
    1198:	81 30       	cpi	r24, 0x01	; 1
    119a:	91 05       	cpc	r25, r1
    119c:	09 f4       	brne	.+2      	; 0x11a0 <GPIO_writePin+0x3a>
    119e:	43 c0       	rjmp	.+134    	; 0x1226 <GPIO_writePin+0xc0>
    11a0:	2c 81       	ldd	r18, Y+4	; 0x04
    11a2:	3d 81       	ldd	r19, Y+5	; 0x05
    11a4:	22 30       	cpi	r18, 0x02	; 2
    11a6:	31 05       	cpc	r19, r1
    11a8:	2c f4       	brge	.+10     	; 0x11b4 <GPIO_writePin+0x4e>
    11aa:	8c 81       	ldd	r24, Y+4	; 0x04
    11ac:	9d 81       	ldd	r25, Y+5	; 0x05
    11ae:	00 97       	sbiw	r24, 0x00	; 0
    11b0:	71 f0       	breq	.+28     	; 0x11ce <GPIO_writePin+0x68>
    11b2:	bc c0       	rjmp	.+376    	; 0x132c <GPIO_writePin+0x1c6>
    11b4:	2c 81       	ldd	r18, Y+4	; 0x04
    11b6:	3d 81       	ldd	r19, Y+5	; 0x05
    11b8:	22 30       	cpi	r18, 0x02	; 2
    11ba:	31 05       	cpc	r19, r1
    11bc:	09 f4       	brne	.+2      	; 0x11c0 <GPIO_writePin+0x5a>
    11be:	5f c0       	rjmp	.+190    	; 0x127e <GPIO_writePin+0x118>
    11c0:	8c 81       	ldd	r24, Y+4	; 0x04
    11c2:	9d 81       	ldd	r25, Y+5	; 0x05
    11c4:	83 30       	cpi	r24, 0x03	; 3
    11c6:	91 05       	cpc	r25, r1
    11c8:	09 f4       	brne	.+2      	; 0x11cc <GPIO_writePin+0x66>
    11ca:	85 c0       	rjmp	.+266    	; 0x12d6 <GPIO_writePin+0x170>
    11cc:	af c0       	rjmp	.+350    	; 0x132c <GPIO_writePin+0x1c6>
		{
		case PORTA_ID:
			if(value == LOGIC_HIGH)
    11ce:	8b 81       	ldd	r24, Y+3	; 0x03
    11d0:	81 30       	cpi	r24, 0x01	; 1
    11d2:	a1 f4       	brne	.+40     	; 0x11fc <GPIO_writePin+0x96>
			{
				SET_BIT(PORTA,pin_num);
    11d4:	ab e3       	ldi	r26, 0x3B	; 59
    11d6:	b0 e0       	ldi	r27, 0x00	; 0
    11d8:	eb e3       	ldi	r30, 0x3B	; 59
    11da:	f0 e0       	ldi	r31, 0x00	; 0
    11dc:	80 81       	ld	r24, Z
    11de:	48 2f       	mov	r20, r24
    11e0:	8a 81       	ldd	r24, Y+2	; 0x02
    11e2:	28 2f       	mov	r18, r24
    11e4:	30 e0       	ldi	r19, 0x00	; 0
    11e6:	81 e0       	ldi	r24, 0x01	; 1
    11e8:	90 e0       	ldi	r25, 0x00	; 0
    11ea:	02 2e       	mov	r0, r18
    11ec:	02 c0       	rjmp	.+4      	; 0x11f2 <GPIO_writePin+0x8c>
    11ee:	88 0f       	add	r24, r24
    11f0:	99 1f       	adc	r25, r25
    11f2:	0a 94       	dec	r0
    11f4:	e2 f7       	brpl	.-8      	; 0x11ee <GPIO_writePin+0x88>
    11f6:	84 2b       	or	r24, r20
    11f8:	8c 93       	st	X, r24
    11fa:	98 c0       	rjmp	.+304    	; 0x132c <GPIO_writePin+0x1c6>
			}
			else
			{
				CLEAR_BIT(PORTA,pin_num);
    11fc:	ab e3       	ldi	r26, 0x3B	; 59
    11fe:	b0 e0       	ldi	r27, 0x00	; 0
    1200:	eb e3       	ldi	r30, 0x3B	; 59
    1202:	f0 e0       	ldi	r31, 0x00	; 0
    1204:	80 81       	ld	r24, Z
    1206:	48 2f       	mov	r20, r24
    1208:	8a 81       	ldd	r24, Y+2	; 0x02
    120a:	28 2f       	mov	r18, r24
    120c:	30 e0       	ldi	r19, 0x00	; 0
    120e:	81 e0       	ldi	r24, 0x01	; 1
    1210:	90 e0       	ldi	r25, 0x00	; 0
    1212:	02 2e       	mov	r0, r18
    1214:	02 c0       	rjmp	.+4      	; 0x121a <GPIO_writePin+0xb4>
    1216:	88 0f       	add	r24, r24
    1218:	99 1f       	adc	r25, r25
    121a:	0a 94       	dec	r0
    121c:	e2 f7       	brpl	.-8      	; 0x1216 <GPIO_writePin+0xb0>
    121e:	80 95       	com	r24
    1220:	84 23       	and	r24, r20
    1222:	8c 93       	st	X, r24
    1224:	83 c0       	rjmp	.+262    	; 0x132c <GPIO_writePin+0x1c6>
			}
			break;
		case PORTB_ID:
			if(value == LOGIC_HIGH)
    1226:	8b 81       	ldd	r24, Y+3	; 0x03
    1228:	81 30       	cpi	r24, 0x01	; 1
    122a:	a1 f4       	brne	.+40     	; 0x1254 <GPIO_writePin+0xee>
			{
				SET_BIT(PORTB,pin_num);
    122c:	a8 e3       	ldi	r26, 0x38	; 56
    122e:	b0 e0       	ldi	r27, 0x00	; 0
    1230:	e8 e3       	ldi	r30, 0x38	; 56
    1232:	f0 e0       	ldi	r31, 0x00	; 0
    1234:	80 81       	ld	r24, Z
    1236:	48 2f       	mov	r20, r24
    1238:	8a 81       	ldd	r24, Y+2	; 0x02
    123a:	28 2f       	mov	r18, r24
    123c:	30 e0       	ldi	r19, 0x00	; 0
    123e:	81 e0       	ldi	r24, 0x01	; 1
    1240:	90 e0       	ldi	r25, 0x00	; 0
    1242:	02 2e       	mov	r0, r18
    1244:	02 c0       	rjmp	.+4      	; 0x124a <GPIO_writePin+0xe4>
    1246:	88 0f       	add	r24, r24
    1248:	99 1f       	adc	r25, r25
    124a:	0a 94       	dec	r0
    124c:	e2 f7       	brpl	.-8      	; 0x1246 <GPIO_writePin+0xe0>
    124e:	84 2b       	or	r24, r20
    1250:	8c 93       	st	X, r24
    1252:	6c c0       	rjmp	.+216    	; 0x132c <GPIO_writePin+0x1c6>
			}
			else
			{
				CLEAR_BIT(PORTB,pin_num);
    1254:	a8 e3       	ldi	r26, 0x38	; 56
    1256:	b0 e0       	ldi	r27, 0x00	; 0
    1258:	e8 e3       	ldi	r30, 0x38	; 56
    125a:	f0 e0       	ldi	r31, 0x00	; 0
    125c:	80 81       	ld	r24, Z
    125e:	48 2f       	mov	r20, r24
    1260:	8a 81       	ldd	r24, Y+2	; 0x02
    1262:	28 2f       	mov	r18, r24
    1264:	30 e0       	ldi	r19, 0x00	; 0
    1266:	81 e0       	ldi	r24, 0x01	; 1
    1268:	90 e0       	ldi	r25, 0x00	; 0
    126a:	02 2e       	mov	r0, r18
    126c:	02 c0       	rjmp	.+4      	; 0x1272 <GPIO_writePin+0x10c>
    126e:	88 0f       	add	r24, r24
    1270:	99 1f       	adc	r25, r25
    1272:	0a 94       	dec	r0
    1274:	e2 f7       	brpl	.-8      	; 0x126e <GPIO_writePin+0x108>
    1276:	80 95       	com	r24
    1278:	84 23       	and	r24, r20
    127a:	8c 93       	st	X, r24
    127c:	57 c0       	rjmp	.+174    	; 0x132c <GPIO_writePin+0x1c6>
			}
			break;
		case PORTC_ID:
			if(value == LOGIC_HIGH)
    127e:	8b 81       	ldd	r24, Y+3	; 0x03
    1280:	81 30       	cpi	r24, 0x01	; 1
    1282:	a1 f4       	brne	.+40     	; 0x12ac <GPIO_writePin+0x146>
			{
				SET_BIT(PORTC,pin_num);
    1284:	a5 e3       	ldi	r26, 0x35	; 53
    1286:	b0 e0       	ldi	r27, 0x00	; 0
    1288:	e5 e3       	ldi	r30, 0x35	; 53
    128a:	f0 e0       	ldi	r31, 0x00	; 0
    128c:	80 81       	ld	r24, Z
    128e:	48 2f       	mov	r20, r24
    1290:	8a 81       	ldd	r24, Y+2	; 0x02
    1292:	28 2f       	mov	r18, r24
    1294:	30 e0       	ldi	r19, 0x00	; 0
    1296:	81 e0       	ldi	r24, 0x01	; 1
    1298:	90 e0       	ldi	r25, 0x00	; 0
    129a:	02 2e       	mov	r0, r18
    129c:	02 c0       	rjmp	.+4      	; 0x12a2 <GPIO_writePin+0x13c>
    129e:	88 0f       	add	r24, r24
    12a0:	99 1f       	adc	r25, r25
    12a2:	0a 94       	dec	r0
    12a4:	e2 f7       	brpl	.-8      	; 0x129e <GPIO_writePin+0x138>
    12a6:	84 2b       	or	r24, r20
    12a8:	8c 93       	st	X, r24
    12aa:	40 c0       	rjmp	.+128    	; 0x132c <GPIO_writePin+0x1c6>
			}
			else
			{
				CLEAR_BIT(PORTC,pin_num);
    12ac:	a5 e3       	ldi	r26, 0x35	; 53
    12ae:	b0 e0       	ldi	r27, 0x00	; 0
    12b0:	e5 e3       	ldi	r30, 0x35	; 53
    12b2:	f0 e0       	ldi	r31, 0x00	; 0
    12b4:	80 81       	ld	r24, Z
    12b6:	48 2f       	mov	r20, r24
    12b8:	8a 81       	ldd	r24, Y+2	; 0x02
    12ba:	28 2f       	mov	r18, r24
    12bc:	30 e0       	ldi	r19, 0x00	; 0
    12be:	81 e0       	ldi	r24, 0x01	; 1
    12c0:	90 e0       	ldi	r25, 0x00	; 0
    12c2:	02 2e       	mov	r0, r18
    12c4:	02 c0       	rjmp	.+4      	; 0x12ca <GPIO_writePin+0x164>
    12c6:	88 0f       	add	r24, r24
    12c8:	99 1f       	adc	r25, r25
    12ca:	0a 94       	dec	r0
    12cc:	e2 f7       	brpl	.-8      	; 0x12c6 <GPIO_writePin+0x160>
    12ce:	80 95       	com	r24
    12d0:	84 23       	and	r24, r20
    12d2:	8c 93       	st	X, r24
    12d4:	2b c0       	rjmp	.+86     	; 0x132c <GPIO_writePin+0x1c6>
			}
			break;
		case PORTD_ID:
			if(value == LOGIC_HIGH)
    12d6:	8b 81       	ldd	r24, Y+3	; 0x03
    12d8:	81 30       	cpi	r24, 0x01	; 1
    12da:	a1 f4       	brne	.+40     	; 0x1304 <GPIO_writePin+0x19e>
			{
				SET_BIT(PORTD,pin_num);
    12dc:	a2 e3       	ldi	r26, 0x32	; 50
    12de:	b0 e0       	ldi	r27, 0x00	; 0
    12e0:	e2 e3       	ldi	r30, 0x32	; 50
    12e2:	f0 e0       	ldi	r31, 0x00	; 0
    12e4:	80 81       	ld	r24, Z
    12e6:	48 2f       	mov	r20, r24
    12e8:	8a 81       	ldd	r24, Y+2	; 0x02
    12ea:	28 2f       	mov	r18, r24
    12ec:	30 e0       	ldi	r19, 0x00	; 0
    12ee:	81 e0       	ldi	r24, 0x01	; 1
    12f0:	90 e0       	ldi	r25, 0x00	; 0
    12f2:	02 2e       	mov	r0, r18
    12f4:	02 c0       	rjmp	.+4      	; 0x12fa <GPIO_writePin+0x194>
    12f6:	88 0f       	add	r24, r24
    12f8:	99 1f       	adc	r25, r25
    12fa:	0a 94       	dec	r0
    12fc:	e2 f7       	brpl	.-8      	; 0x12f6 <GPIO_writePin+0x190>
    12fe:	84 2b       	or	r24, r20
    1300:	8c 93       	st	X, r24
    1302:	14 c0       	rjmp	.+40     	; 0x132c <GPIO_writePin+0x1c6>
			}
			else
			{
				CLEAR_BIT(PORTD,pin_num);
    1304:	a2 e3       	ldi	r26, 0x32	; 50
    1306:	b0 e0       	ldi	r27, 0x00	; 0
    1308:	e2 e3       	ldi	r30, 0x32	; 50
    130a:	f0 e0       	ldi	r31, 0x00	; 0
    130c:	80 81       	ld	r24, Z
    130e:	48 2f       	mov	r20, r24
    1310:	8a 81       	ldd	r24, Y+2	; 0x02
    1312:	28 2f       	mov	r18, r24
    1314:	30 e0       	ldi	r19, 0x00	; 0
    1316:	81 e0       	ldi	r24, 0x01	; 1
    1318:	90 e0       	ldi	r25, 0x00	; 0
    131a:	02 2e       	mov	r0, r18
    131c:	02 c0       	rjmp	.+4      	; 0x1322 <GPIO_writePin+0x1bc>
    131e:	88 0f       	add	r24, r24
    1320:	99 1f       	adc	r25, r25
    1322:	0a 94       	dec	r0
    1324:	e2 f7       	brpl	.-8      	; 0x131e <GPIO_writePin+0x1b8>
    1326:	80 95       	com	r24
    1328:	84 23       	and	r24, r20
    132a:	8c 93       	st	X, r24
			}
			break;
		}
	}
}
    132c:	0f 90       	pop	r0
    132e:	0f 90       	pop	r0
    1330:	0f 90       	pop	r0
    1332:	0f 90       	pop	r0
    1334:	0f 90       	pop	r0
    1336:	cf 91       	pop	r28
    1338:	df 91       	pop	r29
    133a:	08 95       	ret

0000133c <GPIO_readPin>:
 * Description :
 * Read and return the value for the required pin, it should be Logic High or Logic Low.
 * If the input port number or pin number are not correct, The function will return Logic Low.
 */
uint8 GPIO_readPin(uint8 port_num, uint8 pin_num)
{
    133c:	df 93       	push	r29
    133e:	cf 93       	push	r28
    1340:	00 d0       	rcall	.+0      	; 0x1342 <GPIO_readPin+0x6>
    1342:	00 d0       	rcall	.+0      	; 0x1344 <GPIO_readPin+0x8>
    1344:	0f 92       	push	r0
    1346:	cd b7       	in	r28, 0x3d	; 61
    1348:	de b7       	in	r29, 0x3e	; 62
    134a:	8a 83       	std	Y+2, r24	; 0x02
    134c:	6b 83       	std	Y+3, r22	; 0x03
	uint8 pin_value = LOGIC_LOW;
    134e:	19 82       	std	Y+1, r1	; 0x01
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
    1350:	8b 81       	ldd	r24, Y+3	; 0x03
    1352:	88 30       	cpi	r24, 0x08	; 8
    1354:	08 f0       	brcs	.+2      	; 0x1358 <GPIO_readPin+0x1c>
    1356:	84 c0       	rjmp	.+264    	; 0x1460 <GPIO_readPin+0x124>
    1358:	8a 81       	ldd	r24, Y+2	; 0x02
    135a:	84 30       	cpi	r24, 0x04	; 4
    135c:	08 f0       	brcs	.+2      	; 0x1360 <GPIO_readPin+0x24>
    135e:	80 c0       	rjmp	.+256    	; 0x1460 <GPIO_readPin+0x124>
		/* Do Nothing */
	}
	else
	{
		/* Read the pin value as required */
		switch(port_num)
    1360:	8a 81       	ldd	r24, Y+2	; 0x02
    1362:	28 2f       	mov	r18, r24
    1364:	30 e0       	ldi	r19, 0x00	; 0
    1366:	3d 83       	std	Y+5, r19	; 0x05
    1368:	2c 83       	std	Y+4, r18	; 0x04
    136a:	4c 81       	ldd	r20, Y+4	; 0x04
    136c:	5d 81       	ldd	r21, Y+5	; 0x05
    136e:	41 30       	cpi	r20, 0x01	; 1
    1370:	51 05       	cpc	r21, r1
    1372:	79 f1       	breq	.+94     	; 0x13d2 <GPIO_readPin+0x96>
    1374:	8c 81       	ldd	r24, Y+4	; 0x04
    1376:	9d 81       	ldd	r25, Y+5	; 0x05
    1378:	82 30       	cpi	r24, 0x02	; 2
    137a:	91 05       	cpc	r25, r1
    137c:	34 f4       	brge	.+12     	; 0x138a <GPIO_readPin+0x4e>
    137e:	2c 81       	ldd	r18, Y+4	; 0x04
    1380:	3d 81       	ldd	r19, Y+5	; 0x05
    1382:	21 15       	cp	r18, r1
    1384:	31 05       	cpc	r19, r1
    1386:	69 f0       	breq	.+26     	; 0x13a2 <GPIO_readPin+0x66>
    1388:	6b c0       	rjmp	.+214    	; 0x1460 <GPIO_readPin+0x124>
    138a:	4c 81       	ldd	r20, Y+4	; 0x04
    138c:	5d 81       	ldd	r21, Y+5	; 0x05
    138e:	42 30       	cpi	r20, 0x02	; 2
    1390:	51 05       	cpc	r21, r1
    1392:	b9 f1       	breq	.+110    	; 0x1402 <GPIO_readPin+0xc6>
    1394:	8c 81       	ldd	r24, Y+4	; 0x04
    1396:	9d 81       	ldd	r25, Y+5	; 0x05
    1398:	83 30       	cpi	r24, 0x03	; 3
    139a:	91 05       	cpc	r25, r1
    139c:	09 f4       	brne	.+2      	; 0x13a0 <GPIO_readPin+0x64>
    139e:	49 c0       	rjmp	.+146    	; 0x1432 <GPIO_readPin+0xf6>
    13a0:	5f c0       	rjmp	.+190    	; 0x1460 <GPIO_readPin+0x124>
		{
		case PORTA_ID:
			if(BIT_IS_SET(PINA,pin_num))
    13a2:	e9 e3       	ldi	r30, 0x39	; 57
    13a4:	f0 e0       	ldi	r31, 0x00	; 0
    13a6:	80 81       	ld	r24, Z
    13a8:	28 2f       	mov	r18, r24
    13aa:	30 e0       	ldi	r19, 0x00	; 0
    13ac:	8b 81       	ldd	r24, Y+3	; 0x03
    13ae:	88 2f       	mov	r24, r24
    13b0:	90 e0       	ldi	r25, 0x00	; 0
    13b2:	a9 01       	movw	r20, r18
    13b4:	02 c0       	rjmp	.+4      	; 0x13ba <GPIO_readPin+0x7e>
    13b6:	55 95       	asr	r21
    13b8:	47 95       	ror	r20
    13ba:	8a 95       	dec	r24
    13bc:	e2 f7       	brpl	.-8      	; 0x13b6 <GPIO_readPin+0x7a>
    13be:	ca 01       	movw	r24, r20
    13c0:	81 70       	andi	r24, 0x01	; 1
    13c2:	90 70       	andi	r25, 0x00	; 0
    13c4:	88 23       	and	r24, r24
    13c6:	19 f0       	breq	.+6      	; 0x13ce <GPIO_readPin+0x92>
			{
				pin_value = LOGIC_HIGH;
    13c8:	81 e0       	ldi	r24, 0x01	; 1
    13ca:	89 83       	std	Y+1, r24	; 0x01
    13cc:	49 c0       	rjmp	.+146    	; 0x1460 <GPIO_readPin+0x124>
			}
			else
			{
				pin_value = LOGIC_LOW;
    13ce:	19 82       	std	Y+1, r1	; 0x01
    13d0:	47 c0       	rjmp	.+142    	; 0x1460 <GPIO_readPin+0x124>
			}
			break;
		case PORTB_ID:
			if(BIT_IS_SET(PINB,pin_num))
    13d2:	e6 e3       	ldi	r30, 0x36	; 54
    13d4:	f0 e0       	ldi	r31, 0x00	; 0
    13d6:	80 81       	ld	r24, Z
    13d8:	28 2f       	mov	r18, r24
    13da:	30 e0       	ldi	r19, 0x00	; 0
    13dc:	8b 81       	ldd	r24, Y+3	; 0x03
    13de:	88 2f       	mov	r24, r24
    13e0:	90 e0       	ldi	r25, 0x00	; 0
    13e2:	a9 01       	movw	r20, r18
    13e4:	02 c0       	rjmp	.+4      	; 0x13ea <GPIO_readPin+0xae>
    13e6:	55 95       	asr	r21
    13e8:	47 95       	ror	r20
    13ea:	8a 95       	dec	r24
    13ec:	e2 f7       	brpl	.-8      	; 0x13e6 <GPIO_readPin+0xaa>
    13ee:	ca 01       	movw	r24, r20
    13f0:	81 70       	andi	r24, 0x01	; 1
    13f2:	90 70       	andi	r25, 0x00	; 0
    13f4:	88 23       	and	r24, r24
    13f6:	19 f0       	breq	.+6      	; 0x13fe <GPIO_readPin+0xc2>
			{
				pin_value = LOGIC_HIGH;
    13f8:	81 e0       	ldi	r24, 0x01	; 1
    13fa:	89 83       	std	Y+1, r24	; 0x01
    13fc:	31 c0       	rjmp	.+98     	; 0x1460 <GPIO_readPin+0x124>
			}
			else
			{
				pin_value = LOGIC_LOW;
    13fe:	19 82       	std	Y+1, r1	; 0x01
    1400:	2f c0       	rjmp	.+94     	; 0x1460 <GPIO_readPin+0x124>
			}
			break;
		case PORTC_ID:
			if(BIT_IS_SET(PINC,pin_num))
    1402:	e3 e3       	ldi	r30, 0x33	; 51
    1404:	f0 e0       	ldi	r31, 0x00	; 0
    1406:	80 81       	ld	r24, Z
    1408:	28 2f       	mov	r18, r24
    140a:	30 e0       	ldi	r19, 0x00	; 0
    140c:	8b 81       	ldd	r24, Y+3	; 0x03
    140e:	88 2f       	mov	r24, r24
    1410:	90 e0       	ldi	r25, 0x00	; 0
    1412:	a9 01       	movw	r20, r18
    1414:	02 c0       	rjmp	.+4      	; 0x141a <GPIO_readPin+0xde>
    1416:	55 95       	asr	r21
    1418:	47 95       	ror	r20
    141a:	8a 95       	dec	r24
    141c:	e2 f7       	brpl	.-8      	; 0x1416 <GPIO_readPin+0xda>
    141e:	ca 01       	movw	r24, r20
    1420:	81 70       	andi	r24, 0x01	; 1
    1422:	90 70       	andi	r25, 0x00	; 0
    1424:	88 23       	and	r24, r24
    1426:	19 f0       	breq	.+6      	; 0x142e <GPIO_readPin+0xf2>
			{
				pin_value = LOGIC_HIGH;
    1428:	81 e0       	ldi	r24, 0x01	; 1
    142a:	89 83       	std	Y+1, r24	; 0x01
    142c:	19 c0       	rjmp	.+50     	; 0x1460 <GPIO_readPin+0x124>
			}
			else
			{
				pin_value = LOGIC_LOW;
    142e:	19 82       	std	Y+1, r1	; 0x01
    1430:	17 c0       	rjmp	.+46     	; 0x1460 <GPIO_readPin+0x124>
			}
			break;
		case PORTD_ID:
			if(BIT_IS_SET(PIND,pin_num))
    1432:	e0 e3       	ldi	r30, 0x30	; 48
    1434:	f0 e0       	ldi	r31, 0x00	; 0
    1436:	80 81       	ld	r24, Z
    1438:	28 2f       	mov	r18, r24
    143a:	30 e0       	ldi	r19, 0x00	; 0
    143c:	8b 81       	ldd	r24, Y+3	; 0x03
    143e:	88 2f       	mov	r24, r24
    1440:	90 e0       	ldi	r25, 0x00	; 0
    1442:	a9 01       	movw	r20, r18
    1444:	02 c0       	rjmp	.+4      	; 0x144a <GPIO_readPin+0x10e>
    1446:	55 95       	asr	r21
    1448:	47 95       	ror	r20
    144a:	8a 95       	dec	r24
    144c:	e2 f7       	brpl	.-8      	; 0x1446 <GPIO_readPin+0x10a>
    144e:	ca 01       	movw	r24, r20
    1450:	81 70       	andi	r24, 0x01	; 1
    1452:	90 70       	andi	r25, 0x00	; 0
    1454:	88 23       	and	r24, r24
    1456:	19 f0       	breq	.+6      	; 0x145e <GPIO_readPin+0x122>
			{
				pin_value = LOGIC_HIGH;
    1458:	81 e0       	ldi	r24, 0x01	; 1
    145a:	89 83       	std	Y+1, r24	; 0x01
    145c:	01 c0       	rjmp	.+2      	; 0x1460 <GPIO_readPin+0x124>
			}
			else
			{
				pin_value = LOGIC_LOW;
    145e:	19 82       	std	Y+1, r1	; 0x01
			}
			break;
		}
	}

	return pin_value;
    1460:	89 81       	ldd	r24, Y+1	; 0x01
}
    1462:	0f 90       	pop	r0
    1464:	0f 90       	pop	r0
    1466:	0f 90       	pop	r0
    1468:	0f 90       	pop	r0
    146a:	0f 90       	pop	r0
    146c:	cf 91       	pop	r28
    146e:	df 91       	pop	r29
    1470:	08 95       	ret

00001472 <GPIO_setupPortDirection>:
 * If the direction value is PORT_INPUT all pins in this port should be input pins.
 * If the direction value is PORT_OUTPUT all pins in this port should be output pins.
 * If the input port number is not correct, The function will not handle the request.
 */
void GPIO_setupPortDirection(uint8 port_num, GPIO_PortDirectionType direction)
{
    1472:	df 93       	push	r29
    1474:	cf 93       	push	r28
    1476:	00 d0       	rcall	.+0      	; 0x1478 <GPIO_setupPortDirection+0x6>
    1478:	00 d0       	rcall	.+0      	; 0x147a <GPIO_setupPortDirection+0x8>
    147a:	cd b7       	in	r28, 0x3d	; 61
    147c:	de b7       	in	r29, 0x3e	; 62
    147e:	89 83       	std	Y+1, r24	; 0x01
    1480:	6a 83       	std	Y+2, r22	; 0x02
	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if(port_num >= NUM_OF_PORTS)
    1482:	89 81       	ldd	r24, Y+1	; 0x01
    1484:	84 30       	cpi	r24, 0x04	; 4
    1486:	90 f5       	brcc	.+100    	; 0x14ec <GPIO_setupPortDirection+0x7a>
		/* Do Nothing */
	}
	else
	{
		/* Setup the port direction as required */
		switch(port_num)
    1488:	89 81       	ldd	r24, Y+1	; 0x01
    148a:	28 2f       	mov	r18, r24
    148c:	30 e0       	ldi	r19, 0x00	; 0
    148e:	3c 83       	std	Y+4, r19	; 0x04
    1490:	2b 83       	std	Y+3, r18	; 0x03
    1492:	8b 81       	ldd	r24, Y+3	; 0x03
    1494:	9c 81       	ldd	r25, Y+4	; 0x04
    1496:	81 30       	cpi	r24, 0x01	; 1
    1498:	91 05       	cpc	r25, r1
    149a:	d1 f0       	breq	.+52     	; 0x14d0 <GPIO_setupPortDirection+0x5e>
    149c:	2b 81       	ldd	r18, Y+3	; 0x03
    149e:	3c 81       	ldd	r19, Y+4	; 0x04
    14a0:	22 30       	cpi	r18, 0x02	; 2
    14a2:	31 05       	cpc	r19, r1
    14a4:	2c f4       	brge	.+10     	; 0x14b0 <GPIO_setupPortDirection+0x3e>
    14a6:	8b 81       	ldd	r24, Y+3	; 0x03
    14a8:	9c 81       	ldd	r25, Y+4	; 0x04
    14aa:	00 97       	sbiw	r24, 0x00	; 0
    14ac:	61 f0       	breq	.+24     	; 0x14c6 <GPIO_setupPortDirection+0x54>
    14ae:	1e c0       	rjmp	.+60     	; 0x14ec <GPIO_setupPortDirection+0x7a>
    14b0:	2b 81       	ldd	r18, Y+3	; 0x03
    14b2:	3c 81       	ldd	r19, Y+4	; 0x04
    14b4:	22 30       	cpi	r18, 0x02	; 2
    14b6:	31 05       	cpc	r19, r1
    14b8:	81 f0       	breq	.+32     	; 0x14da <GPIO_setupPortDirection+0x68>
    14ba:	8b 81       	ldd	r24, Y+3	; 0x03
    14bc:	9c 81       	ldd	r25, Y+4	; 0x04
    14be:	83 30       	cpi	r24, 0x03	; 3
    14c0:	91 05       	cpc	r25, r1
    14c2:	81 f0       	breq	.+32     	; 0x14e4 <GPIO_setupPortDirection+0x72>
    14c4:	13 c0       	rjmp	.+38     	; 0x14ec <GPIO_setupPortDirection+0x7a>
		{
		case PORTA_ID:
			DDRA = direction;
    14c6:	ea e3       	ldi	r30, 0x3A	; 58
    14c8:	f0 e0       	ldi	r31, 0x00	; 0
    14ca:	8a 81       	ldd	r24, Y+2	; 0x02
    14cc:	80 83       	st	Z, r24
    14ce:	0e c0       	rjmp	.+28     	; 0x14ec <GPIO_setupPortDirection+0x7a>
			break;
		case PORTB_ID:
			DDRB = direction;
    14d0:	e7 e3       	ldi	r30, 0x37	; 55
    14d2:	f0 e0       	ldi	r31, 0x00	; 0
    14d4:	8a 81       	ldd	r24, Y+2	; 0x02
    14d6:	80 83       	st	Z, r24
    14d8:	09 c0       	rjmp	.+18     	; 0x14ec <GPIO_setupPortDirection+0x7a>
			break;
		case PORTC_ID:
			DDRC = direction;
    14da:	e4 e3       	ldi	r30, 0x34	; 52
    14dc:	f0 e0       	ldi	r31, 0x00	; 0
    14de:	8a 81       	ldd	r24, Y+2	; 0x02
    14e0:	80 83       	st	Z, r24
    14e2:	04 c0       	rjmp	.+8      	; 0x14ec <GPIO_setupPortDirection+0x7a>
			break;
		case PORTD_ID:
			DDRD = direction;
    14e4:	e1 e3       	ldi	r30, 0x31	; 49
    14e6:	f0 e0       	ldi	r31, 0x00	; 0
    14e8:	8a 81       	ldd	r24, Y+2	; 0x02
    14ea:	80 83       	st	Z, r24
			break;
		}
	}
}
    14ec:	0f 90       	pop	r0
    14ee:	0f 90       	pop	r0
    14f0:	0f 90       	pop	r0
    14f2:	0f 90       	pop	r0
    14f4:	cf 91       	pop	r28
    14f6:	df 91       	pop	r29
    14f8:	08 95       	ret

000014fa <GPIO_writePort>:
 * If any pin in the port is output pin the value will be written.
 * If any pin in the port is input pin this will activate/deactivate the internal pull-up resistor.
 * If the input port number is not correct, The function will not handle the request.
 */
void GPIO_writePort(uint8 port_num, uint8 value)
{
    14fa:	df 93       	push	r29
    14fc:	cf 93       	push	r28
    14fe:	00 d0       	rcall	.+0      	; 0x1500 <GPIO_writePort+0x6>
    1500:	00 d0       	rcall	.+0      	; 0x1502 <GPIO_writePort+0x8>
    1502:	cd b7       	in	r28, 0x3d	; 61
    1504:	de b7       	in	r29, 0x3e	; 62
    1506:	89 83       	std	Y+1, r24	; 0x01
    1508:	6a 83       	std	Y+2, r22	; 0x02
	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if(port_num >= NUM_OF_PORTS)
    150a:	89 81       	ldd	r24, Y+1	; 0x01
    150c:	84 30       	cpi	r24, 0x04	; 4
    150e:	90 f5       	brcc	.+100    	; 0x1574 <GPIO_writePort+0x7a>
		/* Do Nothing */
	}
	else
	{
		/* Write the port value as required */
		switch(port_num)
    1510:	89 81       	ldd	r24, Y+1	; 0x01
    1512:	28 2f       	mov	r18, r24
    1514:	30 e0       	ldi	r19, 0x00	; 0
    1516:	3c 83       	std	Y+4, r19	; 0x04
    1518:	2b 83       	std	Y+3, r18	; 0x03
    151a:	8b 81       	ldd	r24, Y+3	; 0x03
    151c:	9c 81       	ldd	r25, Y+4	; 0x04
    151e:	81 30       	cpi	r24, 0x01	; 1
    1520:	91 05       	cpc	r25, r1
    1522:	d1 f0       	breq	.+52     	; 0x1558 <GPIO_writePort+0x5e>
    1524:	2b 81       	ldd	r18, Y+3	; 0x03
    1526:	3c 81       	ldd	r19, Y+4	; 0x04
    1528:	22 30       	cpi	r18, 0x02	; 2
    152a:	31 05       	cpc	r19, r1
    152c:	2c f4       	brge	.+10     	; 0x1538 <GPIO_writePort+0x3e>
    152e:	8b 81       	ldd	r24, Y+3	; 0x03
    1530:	9c 81       	ldd	r25, Y+4	; 0x04
    1532:	00 97       	sbiw	r24, 0x00	; 0
    1534:	61 f0       	breq	.+24     	; 0x154e <GPIO_writePort+0x54>
    1536:	1e c0       	rjmp	.+60     	; 0x1574 <GPIO_writePort+0x7a>
    1538:	2b 81       	ldd	r18, Y+3	; 0x03
    153a:	3c 81       	ldd	r19, Y+4	; 0x04
    153c:	22 30       	cpi	r18, 0x02	; 2
    153e:	31 05       	cpc	r19, r1
    1540:	81 f0       	breq	.+32     	; 0x1562 <GPIO_writePort+0x68>
    1542:	8b 81       	ldd	r24, Y+3	; 0x03
    1544:	9c 81       	ldd	r25, Y+4	; 0x04
    1546:	83 30       	cpi	r24, 0x03	; 3
    1548:	91 05       	cpc	r25, r1
    154a:	81 f0       	breq	.+32     	; 0x156c <GPIO_writePort+0x72>
    154c:	13 c0       	rjmp	.+38     	; 0x1574 <GPIO_writePort+0x7a>
		{
		case PORTA_ID:
			PORTA = value;
    154e:	eb e3       	ldi	r30, 0x3B	; 59
    1550:	f0 e0       	ldi	r31, 0x00	; 0
    1552:	8a 81       	ldd	r24, Y+2	; 0x02
    1554:	80 83       	st	Z, r24
    1556:	0e c0       	rjmp	.+28     	; 0x1574 <GPIO_writePort+0x7a>
			break;
		case PORTB_ID:
			PORTB = value;
    1558:	e8 e3       	ldi	r30, 0x38	; 56
    155a:	f0 e0       	ldi	r31, 0x00	; 0
    155c:	8a 81       	ldd	r24, Y+2	; 0x02
    155e:	80 83       	st	Z, r24
    1560:	09 c0       	rjmp	.+18     	; 0x1574 <GPIO_writePort+0x7a>
			break;
		case PORTC_ID:
			PORTC = value;
    1562:	e5 e3       	ldi	r30, 0x35	; 53
    1564:	f0 e0       	ldi	r31, 0x00	; 0
    1566:	8a 81       	ldd	r24, Y+2	; 0x02
    1568:	80 83       	st	Z, r24
    156a:	04 c0       	rjmp	.+8      	; 0x1574 <GPIO_writePort+0x7a>
			break;
		case PORTD_ID:
			PORTD = value;
    156c:	e2 e3       	ldi	r30, 0x32	; 50
    156e:	f0 e0       	ldi	r31, 0x00	; 0
    1570:	8a 81       	ldd	r24, Y+2	; 0x02
    1572:	80 83       	st	Z, r24
			break;
		}
	}
}
    1574:	0f 90       	pop	r0
    1576:	0f 90       	pop	r0
    1578:	0f 90       	pop	r0
    157a:	0f 90       	pop	r0
    157c:	cf 91       	pop	r28
    157e:	df 91       	pop	r29
    1580:	08 95       	ret

00001582 <GPIO_readPort>:
 * Description :
 * Read and return the value of the required port.
 * If the input port number is not correct, The function will return ZERO value.
 */
uint8 GPIO_readPort(uint8 port_num)
{
    1582:	df 93       	push	r29
    1584:	cf 93       	push	r28
    1586:	00 d0       	rcall	.+0      	; 0x1588 <GPIO_readPort+0x6>
    1588:	00 d0       	rcall	.+0      	; 0x158a <GPIO_readPort+0x8>
    158a:	cd b7       	in	r28, 0x3d	; 61
    158c:	de b7       	in	r29, 0x3e	; 62
    158e:	8a 83       	std	Y+2, r24	; 0x02
	uint8 value = LOGIC_LOW;
    1590:	19 82       	std	Y+1, r1	; 0x01

	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if(port_num >= NUM_OF_PORTS)
    1592:	8a 81       	ldd	r24, Y+2	; 0x02
    1594:	84 30       	cpi	r24, 0x04	; 4
    1596:	90 f5       	brcc	.+100    	; 0x15fc <GPIO_readPort+0x7a>
		/* Do Nothing */
	}
	else
	{
		/* Read the port value as required */
		switch(port_num)
    1598:	8a 81       	ldd	r24, Y+2	; 0x02
    159a:	28 2f       	mov	r18, r24
    159c:	30 e0       	ldi	r19, 0x00	; 0
    159e:	3c 83       	std	Y+4, r19	; 0x04
    15a0:	2b 83       	std	Y+3, r18	; 0x03
    15a2:	8b 81       	ldd	r24, Y+3	; 0x03
    15a4:	9c 81       	ldd	r25, Y+4	; 0x04
    15a6:	81 30       	cpi	r24, 0x01	; 1
    15a8:	91 05       	cpc	r25, r1
    15aa:	d1 f0       	breq	.+52     	; 0x15e0 <GPIO_readPort+0x5e>
    15ac:	2b 81       	ldd	r18, Y+3	; 0x03
    15ae:	3c 81       	ldd	r19, Y+4	; 0x04
    15b0:	22 30       	cpi	r18, 0x02	; 2
    15b2:	31 05       	cpc	r19, r1
    15b4:	2c f4       	brge	.+10     	; 0x15c0 <GPIO_readPort+0x3e>
    15b6:	8b 81       	ldd	r24, Y+3	; 0x03
    15b8:	9c 81       	ldd	r25, Y+4	; 0x04
    15ba:	00 97       	sbiw	r24, 0x00	; 0
    15bc:	61 f0       	breq	.+24     	; 0x15d6 <GPIO_readPort+0x54>
    15be:	1e c0       	rjmp	.+60     	; 0x15fc <GPIO_readPort+0x7a>
    15c0:	2b 81       	ldd	r18, Y+3	; 0x03
    15c2:	3c 81       	ldd	r19, Y+4	; 0x04
    15c4:	22 30       	cpi	r18, 0x02	; 2
    15c6:	31 05       	cpc	r19, r1
    15c8:	81 f0       	breq	.+32     	; 0x15ea <GPIO_readPort+0x68>
    15ca:	8b 81       	ldd	r24, Y+3	; 0x03
    15cc:	9c 81       	ldd	r25, Y+4	; 0x04
    15ce:	83 30       	cpi	r24, 0x03	; 3
    15d0:	91 05       	cpc	r25, r1
    15d2:	81 f0       	breq	.+32     	; 0x15f4 <GPIO_readPort+0x72>
    15d4:	13 c0       	rjmp	.+38     	; 0x15fc <GPIO_readPort+0x7a>
		{
		case PORTA_ID:
			value = PINA;
    15d6:	e9 e3       	ldi	r30, 0x39	; 57
    15d8:	f0 e0       	ldi	r31, 0x00	; 0
    15da:	80 81       	ld	r24, Z
    15dc:	89 83       	std	Y+1, r24	; 0x01
    15de:	0e c0       	rjmp	.+28     	; 0x15fc <GPIO_readPort+0x7a>
			break;
		case PORTB_ID:
			value = PINB;
    15e0:	e6 e3       	ldi	r30, 0x36	; 54
    15e2:	f0 e0       	ldi	r31, 0x00	; 0
    15e4:	80 81       	ld	r24, Z
    15e6:	89 83       	std	Y+1, r24	; 0x01
    15e8:	09 c0       	rjmp	.+18     	; 0x15fc <GPIO_readPort+0x7a>
			break;
		case PORTC_ID:
			value = PINC;
    15ea:	e3 e3       	ldi	r30, 0x33	; 51
    15ec:	f0 e0       	ldi	r31, 0x00	; 0
    15ee:	80 81       	ld	r24, Z
    15f0:	89 83       	std	Y+1, r24	; 0x01
    15f2:	04 c0       	rjmp	.+8      	; 0x15fc <GPIO_readPort+0x7a>
			break;
		case PORTD_ID:
			value = PIND;
    15f4:	e0 e3       	ldi	r30, 0x30	; 48
    15f6:	f0 e0       	ldi	r31, 0x00	; 0
    15f8:	80 81       	ld	r24, Z
    15fa:	89 83       	std	Y+1, r24	; 0x01
			break;
		}
	}

	return value;
    15fc:	89 81       	ldd	r24, Y+1	; 0x01
}
    15fe:	0f 90       	pop	r0
    1600:	0f 90       	pop	r0
    1602:	0f 90       	pop	r0
    1604:	0f 90       	pop	r0
    1606:	cf 91       	pop	r28
    1608:	df 91       	pop	r29
    160a:	08 95       	ret

0000160c <LCD_init>:
 * Initialize the LCD:
 * 1. Setup the LCD pins directions by use the GPIO driver.
 * 2. Setup the LCD Data Mode 4-bits or 8-bits.
 */
void LCD_init(void)
{
    160c:	df 93       	push	r29
    160e:	cf 93       	push	r28
    1610:	cd b7       	in	r28, 0x3d	; 61
    1612:	de b7       	in	r29, 0x3e	; 62
    1614:	2e 97       	sbiw	r28, 0x0e	; 14
    1616:	0f b6       	in	r0, 0x3f	; 63
    1618:	f8 94       	cli
    161a:	de bf       	out	0x3e, r29	; 62
    161c:	0f be       	out	0x3f, r0	; 63
    161e:	cd bf       	out	0x3d, r28	; 61
	/* Configure the direction for RS and E pins as output pins */
	GPIO_setupPinDirection(LCD_RS_PORT_ID,LCD_RS_PIN_ID,PIN_OUTPUT);
    1620:	80 e0       	ldi	r24, 0x00	; 0
    1622:	61 e0       	ldi	r22, 0x01	; 1
    1624:	41 e0       	ldi	r20, 0x01	; 1
    1626:	0e 94 c8 07 	call	0xf90	; 0xf90 <GPIO_setupPinDirection>
	GPIO_setupPinDirection(LCD_E_PORT_ID,LCD_E_PIN_ID,PIN_OUTPUT);
    162a:	80 e0       	ldi	r24, 0x00	; 0
    162c:	62 e0       	ldi	r22, 0x02	; 2
    162e:	41 e0       	ldi	r20, 0x01	; 1
    1630:	0e 94 c8 07 	call	0xf90	; 0xf90 <GPIO_setupPinDirection>
    1634:	80 e0       	ldi	r24, 0x00	; 0
    1636:	90 e0       	ldi	r25, 0x00	; 0
    1638:	a0 ea       	ldi	r26, 0xA0	; 160
    163a:	b1 e4       	ldi	r27, 0x41	; 65
    163c:	8b 87       	std	Y+11, r24	; 0x0b
    163e:	9c 87       	std	Y+12, r25	; 0x0c
    1640:	ad 87       	std	Y+13, r26	; 0x0d
    1642:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1644:	6b 85       	ldd	r22, Y+11	; 0x0b
    1646:	7c 85       	ldd	r23, Y+12	; 0x0c
    1648:	8d 85       	ldd	r24, Y+13	; 0x0d
    164a:	9e 85       	ldd	r25, Y+14	; 0x0e
    164c:	20 e0       	ldi	r18, 0x00	; 0
    164e:	30 e0       	ldi	r19, 0x00	; 0
    1650:	4a ef       	ldi	r20, 0xFA	; 250
    1652:	54 e4       	ldi	r21, 0x44	; 68
    1654:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1658:	dc 01       	movw	r26, r24
    165a:	cb 01       	movw	r24, r22
    165c:	8f 83       	std	Y+7, r24	; 0x07
    165e:	98 87       	std	Y+8, r25	; 0x08
    1660:	a9 87       	std	Y+9, r26	; 0x09
    1662:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1664:	6f 81       	ldd	r22, Y+7	; 0x07
    1666:	78 85       	ldd	r23, Y+8	; 0x08
    1668:	89 85       	ldd	r24, Y+9	; 0x09
    166a:	9a 85       	ldd	r25, Y+10	; 0x0a
    166c:	20 e0       	ldi	r18, 0x00	; 0
    166e:	30 e0       	ldi	r19, 0x00	; 0
    1670:	40 e8       	ldi	r20, 0x80	; 128
    1672:	5f e3       	ldi	r21, 0x3F	; 63
    1674:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1678:	88 23       	and	r24, r24
    167a:	2c f4       	brge	.+10     	; 0x1686 <LCD_init+0x7a>
		__ticks = 1;
    167c:	81 e0       	ldi	r24, 0x01	; 1
    167e:	90 e0       	ldi	r25, 0x00	; 0
    1680:	9e 83       	std	Y+6, r25	; 0x06
    1682:	8d 83       	std	Y+5, r24	; 0x05
    1684:	3f c0       	rjmp	.+126    	; 0x1704 <LCD_init+0xf8>
	else if (__tmp > 65535)
    1686:	6f 81       	ldd	r22, Y+7	; 0x07
    1688:	78 85       	ldd	r23, Y+8	; 0x08
    168a:	89 85       	ldd	r24, Y+9	; 0x09
    168c:	9a 85       	ldd	r25, Y+10	; 0x0a
    168e:	20 e0       	ldi	r18, 0x00	; 0
    1690:	3f ef       	ldi	r19, 0xFF	; 255
    1692:	4f e7       	ldi	r20, 0x7F	; 127
    1694:	57 e4       	ldi	r21, 0x47	; 71
    1696:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    169a:	18 16       	cp	r1, r24
    169c:	4c f5       	brge	.+82     	; 0x16f0 <LCD_init+0xe4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    169e:	6b 85       	ldd	r22, Y+11	; 0x0b
    16a0:	7c 85       	ldd	r23, Y+12	; 0x0c
    16a2:	8d 85       	ldd	r24, Y+13	; 0x0d
    16a4:	9e 85       	ldd	r25, Y+14	; 0x0e
    16a6:	20 e0       	ldi	r18, 0x00	; 0
    16a8:	30 e0       	ldi	r19, 0x00	; 0
    16aa:	40 e2       	ldi	r20, 0x20	; 32
    16ac:	51 e4       	ldi	r21, 0x41	; 65
    16ae:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    16b2:	dc 01       	movw	r26, r24
    16b4:	cb 01       	movw	r24, r22
    16b6:	bc 01       	movw	r22, r24
    16b8:	cd 01       	movw	r24, r26
    16ba:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    16be:	dc 01       	movw	r26, r24
    16c0:	cb 01       	movw	r24, r22
    16c2:	9e 83       	std	Y+6, r25	; 0x06
    16c4:	8d 83       	std	Y+5, r24	; 0x05
    16c6:	0f c0       	rjmp	.+30     	; 0x16e6 <LCD_init+0xda>
    16c8:	88 ec       	ldi	r24, 0xC8	; 200
    16ca:	90 e0       	ldi	r25, 0x00	; 0
    16cc:	9c 83       	std	Y+4, r25	; 0x04
    16ce:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    16d0:	8b 81       	ldd	r24, Y+3	; 0x03
    16d2:	9c 81       	ldd	r25, Y+4	; 0x04
    16d4:	01 97       	sbiw	r24, 0x01	; 1
    16d6:	f1 f7       	brne	.-4      	; 0x16d4 <LCD_init+0xc8>
    16d8:	9c 83       	std	Y+4, r25	; 0x04
    16da:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    16dc:	8d 81       	ldd	r24, Y+5	; 0x05
    16de:	9e 81       	ldd	r25, Y+6	; 0x06
    16e0:	01 97       	sbiw	r24, 0x01	; 1
    16e2:	9e 83       	std	Y+6, r25	; 0x06
    16e4:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    16e6:	8d 81       	ldd	r24, Y+5	; 0x05
    16e8:	9e 81       	ldd	r25, Y+6	; 0x06
    16ea:	00 97       	sbiw	r24, 0x00	; 0
    16ec:	69 f7       	brne	.-38     	; 0x16c8 <LCD_init+0xbc>
    16ee:	14 c0       	rjmp	.+40     	; 0x1718 <LCD_init+0x10c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    16f0:	6f 81       	ldd	r22, Y+7	; 0x07
    16f2:	78 85       	ldd	r23, Y+8	; 0x08
    16f4:	89 85       	ldd	r24, Y+9	; 0x09
    16f6:	9a 85       	ldd	r25, Y+10	; 0x0a
    16f8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    16fc:	dc 01       	movw	r26, r24
    16fe:	cb 01       	movw	r24, r22
    1700:	9e 83       	std	Y+6, r25	; 0x06
    1702:	8d 83       	std	Y+5, r24	; 0x05
    1704:	8d 81       	ldd	r24, Y+5	; 0x05
    1706:	9e 81       	ldd	r25, Y+6	; 0x06
    1708:	9a 83       	std	Y+2, r25	; 0x02
    170a:	89 83       	std	Y+1, r24	; 0x01
    170c:	89 81       	ldd	r24, Y+1	; 0x01
    170e:	9a 81       	ldd	r25, Y+2	; 0x02
    1710:	01 97       	sbiw	r24, 0x01	; 1
    1712:	f1 f7       	brne	.-4      	; 0x1710 <LCD_init+0x104>
    1714:	9a 83       	std	Y+2, r25	; 0x02
    1716:	89 83       	std	Y+1, r24	; 0x01

	_delay_ms(20);		/* LCD Power ON delay always > 15ms */

#if(LCD_DATA_BITS_MODE == 4)
	/* Configure 4 pins in the data port as output pins */
	GPIO_setupPinDirection(LCD_DATA_PORT_ID,LCD_DB4_PIN_ID,PIN_OUTPUT);
    1718:	80 e0       	ldi	r24, 0x00	; 0
    171a:	63 e0       	ldi	r22, 0x03	; 3
    171c:	41 e0       	ldi	r20, 0x01	; 1
    171e:	0e 94 c8 07 	call	0xf90	; 0xf90 <GPIO_setupPinDirection>
	GPIO_setupPinDirection(LCD_DATA_PORT_ID,LCD_DB5_PIN_ID,PIN_OUTPUT);
    1722:	80 e0       	ldi	r24, 0x00	; 0
    1724:	64 e0       	ldi	r22, 0x04	; 4
    1726:	41 e0       	ldi	r20, 0x01	; 1
    1728:	0e 94 c8 07 	call	0xf90	; 0xf90 <GPIO_setupPinDirection>
	GPIO_setupPinDirection(LCD_DATA_PORT_ID,LCD_DB6_PIN_ID,PIN_OUTPUT);
    172c:	80 e0       	ldi	r24, 0x00	; 0
    172e:	65 e0       	ldi	r22, 0x05	; 5
    1730:	41 e0       	ldi	r20, 0x01	; 1
    1732:	0e 94 c8 07 	call	0xf90	; 0xf90 <GPIO_setupPinDirection>
	GPIO_setupPinDirection(LCD_DATA_PORT_ID,LCD_DB7_PIN_ID,PIN_OUTPUT);
    1736:	80 e0       	ldi	r24, 0x00	; 0
    1738:	66 e0       	ldi	r22, 0x06	; 6
    173a:	41 e0       	ldi	r20, 0x01	; 1
    173c:	0e 94 c8 07 	call	0xf90	; 0xf90 <GPIO_setupPinDirection>

	/* Send for 4 bit initialization of LCD  */
	LCD_sendCommand(LCD_TWO_LINES_FOUR_BITS_MODE_INIT1);
    1740:	83 e3       	ldi	r24, 0x33	; 51
    1742:	0e 94 b8 0b 	call	0x1770	; 0x1770 <LCD_sendCommand>
	LCD_sendCommand(LCD_TWO_LINES_FOUR_BITS_MODE_INIT2);
    1746:	82 e3       	ldi	r24, 0x32	; 50
    1748:	0e 94 b8 0b 	call	0x1770	; 0x1770 <LCD_sendCommand>

	/* use 2-lines LCD + 4-bits Data Mode + 5*7 dot display Mode */
	LCD_sendCommand(LCD_TWO_LINES_FOUR_BITS_MODE);
    174c:	88 e2       	ldi	r24, 0x28	; 40
    174e:	0e 94 b8 0b 	call	0x1770	; 0x1770 <LCD_sendCommand>
	/* use 2-lines LCD + 8-bits Data Mode + 5*7 dot display Mode */
	LCD_sendCommand(LCD_TWO_LINES_EIGHT_BITS_MODE);

#endif

	LCD_sendCommand(LCD_CURSOR_OFF); /* cursor off */
    1752:	8c e0       	ldi	r24, 0x0C	; 12
    1754:	0e 94 b8 0b 	call	0x1770	; 0x1770 <LCD_sendCommand>
	LCD_sendCommand(LCD_CLEAR_COMMAND); /* clear LCD at the beginning */
    1758:	81 e0       	ldi	r24, 0x01	; 1
    175a:	0e 94 b8 0b 	call	0x1770	; 0x1770 <LCD_sendCommand>
}
    175e:	2e 96       	adiw	r28, 0x0e	; 14
    1760:	0f b6       	in	r0, 0x3f	; 63
    1762:	f8 94       	cli
    1764:	de bf       	out	0x3e, r29	; 62
    1766:	0f be       	out	0x3f, r0	; 63
    1768:	cd bf       	out	0x3d, r28	; 61
    176a:	cf 91       	pop	r28
    176c:	df 91       	pop	r29
    176e:	08 95       	ret

00001770 <LCD_sendCommand>:
/*
 * Description :
 * Send the required command to the screen
 */
void LCD_sendCommand(uint8 command)
{
    1770:	0f 93       	push	r16
    1772:	1f 93       	push	r17
    1774:	df 93       	push	r29
    1776:	cf 93       	push	r28
    1778:	cd b7       	in	r28, 0x3d	; 61
    177a:	de b7       	in	r29, 0x3e	; 62
    177c:	c3 56       	subi	r28, 0x63	; 99
    177e:	d0 40       	sbci	r29, 0x00	; 0
    1780:	0f b6       	in	r0, 0x3f	; 63
    1782:	f8 94       	cli
    1784:	de bf       	out	0x3e, r29	; 62
    1786:	0f be       	out	0x3f, r0	; 63
    1788:	cd bf       	out	0x3d, r28	; 61
    178a:	fe 01       	movw	r30, r28
    178c:	ed 59       	subi	r30, 0x9D	; 157
    178e:	ff 4f       	sbci	r31, 0xFF	; 255
    1790:	80 83       	st	Z, r24
	GPIO_writePin(LCD_RS_PORT_ID,LCD_RS_PIN_ID,LOGIC_LOW); /* Instruction Mode RS=0 */
    1792:	80 e0       	ldi	r24, 0x00	; 0
    1794:	61 e0       	ldi	r22, 0x01	; 1
    1796:	40 e0       	ldi	r20, 0x00	; 0
    1798:	0e 94 b3 08 	call	0x1166	; 0x1166 <GPIO_writePin>
    179c:	fe 01       	movw	r30, r28
    179e:	e1 5a       	subi	r30, 0xA1	; 161
    17a0:	ff 4f       	sbci	r31, 0xFF	; 255
    17a2:	80 e0       	ldi	r24, 0x00	; 0
    17a4:	90 e0       	ldi	r25, 0x00	; 0
    17a6:	a0 e8       	ldi	r26, 0x80	; 128
    17a8:	bf e3       	ldi	r27, 0x3F	; 63
    17aa:	80 83       	st	Z, r24
    17ac:	91 83       	std	Z+1, r25	; 0x01
    17ae:	a2 83       	std	Z+2, r26	; 0x02
    17b0:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    17b2:	8e 01       	movw	r16, r28
    17b4:	05 5a       	subi	r16, 0xA5	; 165
    17b6:	1f 4f       	sbci	r17, 0xFF	; 255
    17b8:	fe 01       	movw	r30, r28
    17ba:	e1 5a       	subi	r30, 0xA1	; 161
    17bc:	ff 4f       	sbci	r31, 0xFF	; 255
    17be:	60 81       	ld	r22, Z
    17c0:	71 81       	ldd	r23, Z+1	; 0x01
    17c2:	82 81       	ldd	r24, Z+2	; 0x02
    17c4:	93 81       	ldd	r25, Z+3	; 0x03
    17c6:	20 e0       	ldi	r18, 0x00	; 0
    17c8:	30 e0       	ldi	r19, 0x00	; 0
    17ca:	4a ef       	ldi	r20, 0xFA	; 250
    17cc:	54 e4       	ldi	r21, 0x44	; 68
    17ce:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    17d2:	dc 01       	movw	r26, r24
    17d4:	cb 01       	movw	r24, r22
    17d6:	f8 01       	movw	r30, r16
    17d8:	80 83       	st	Z, r24
    17da:	91 83       	std	Z+1, r25	; 0x01
    17dc:	a2 83       	std	Z+2, r26	; 0x02
    17de:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    17e0:	fe 01       	movw	r30, r28
    17e2:	e5 5a       	subi	r30, 0xA5	; 165
    17e4:	ff 4f       	sbci	r31, 0xFF	; 255
    17e6:	60 81       	ld	r22, Z
    17e8:	71 81       	ldd	r23, Z+1	; 0x01
    17ea:	82 81       	ldd	r24, Z+2	; 0x02
    17ec:	93 81       	ldd	r25, Z+3	; 0x03
    17ee:	20 e0       	ldi	r18, 0x00	; 0
    17f0:	30 e0       	ldi	r19, 0x00	; 0
    17f2:	40 e8       	ldi	r20, 0x80	; 128
    17f4:	5f e3       	ldi	r21, 0x3F	; 63
    17f6:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    17fa:	88 23       	and	r24, r24
    17fc:	44 f4       	brge	.+16     	; 0x180e <LCD_sendCommand+0x9e>
		__ticks = 1;
    17fe:	fe 01       	movw	r30, r28
    1800:	e7 5a       	subi	r30, 0xA7	; 167
    1802:	ff 4f       	sbci	r31, 0xFF	; 255
    1804:	81 e0       	ldi	r24, 0x01	; 1
    1806:	90 e0       	ldi	r25, 0x00	; 0
    1808:	91 83       	std	Z+1, r25	; 0x01
    180a:	80 83       	st	Z, r24
    180c:	64 c0       	rjmp	.+200    	; 0x18d6 <LCD_sendCommand+0x166>
	else if (__tmp > 65535)
    180e:	fe 01       	movw	r30, r28
    1810:	e5 5a       	subi	r30, 0xA5	; 165
    1812:	ff 4f       	sbci	r31, 0xFF	; 255
    1814:	60 81       	ld	r22, Z
    1816:	71 81       	ldd	r23, Z+1	; 0x01
    1818:	82 81       	ldd	r24, Z+2	; 0x02
    181a:	93 81       	ldd	r25, Z+3	; 0x03
    181c:	20 e0       	ldi	r18, 0x00	; 0
    181e:	3f ef       	ldi	r19, 0xFF	; 255
    1820:	4f e7       	ldi	r20, 0x7F	; 127
    1822:	57 e4       	ldi	r21, 0x47	; 71
    1824:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1828:	18 16       	cp	r1, r24
    182a:	0c f0       	brlt	.+2      	; 0x182e <LCD_sendCommand+0xbe>
    182c:	43 c0       	rjmp	.+134    	; 0x18b4 <LCD_sendCommand+0x144>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    182e:	fe 01       	movw	r30, r28
    1830:	e1 5a       	subi	r30, 0xA1	; 161
    1832:	ff 4f       	sbci	r31, 0xFF	; 255
    1834:	60 81       	ld	r22, Z
    1836:	71 81       	ldd	r23, Z+1	; 0x01
    1838:	82 81       	ldd	r24, Z+2	; 0x02
    183a:	93 81       	ldd	r25, Z+3	; 0x03
    183c:	20 e0       	ldi	r18, 0x00	; 0
    183e:	30 e0       	ldi	r19, 0x00	; 0
    1840:	40 e2       	ldi	r20, 0x20	; 32
    1842:	51 e4       	ldi	r21, 0x41	; 65
    1844:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1848:	dc 01       	movw	r26, r24
    184a:	cb 01       	movw	r24, r22
    184c:	8e 01       	movw	r16, r28
    184e:	07 5a       	subi	r16, 0xA7	; 167
    1850:	1f 4f       	sbci	r17, 0xFF	; 255
    1852:	bc 01       	movw	r22, r24
    1854:	cd 01       	movw	r24, r26
    1856:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    185a:	dc 01       	movw	r26, r24
    185c:	cb 01       	movw	r24, r22
    185e:	f8 01       	movw	r30, r16
    1860:	91 83       	std	Z+1, r25	; 0x01
    1862:	80 83       	st	Z, r24
    1864:	1f c0       	rjmp	.+62     	; 0x18a4 <LCD_sendCommand+0x134>
    1866:	fe 01       	movw	r30, r28
    1868:	e9 5a       	subi	r30, 0xA9	; 169
    186a:	ff 4f       	sbci	r31, 0xFF	; 255
    186c:	88 ec       	ldi	r24, 0xC8	; 200
    186e:	90 e0       	ldi	r25, 0x00	; 0
    1870:	91 83       	std	Z+1, r25	; 0x01
    1872:	80 83       	st	Z, r24
    1874:	fe 01       	movw	r30, r28
    1876:	e9 5a       	subi	r30, 0xA9	; 169
    1878:	ff 4f       	sbci	r31, 0xFF	; 255
    187a:	80 81       	ld	r24, Z
    187c:	91 81       	ldd	r25, Z+1	; 0x01
    187e:	01 97       	sbiw	r24, 0x01	; 1
    1880:	f1 f7       	brne	.-4      	; 0x187e <LCD_sendCommand+0x10e>
    1882:	fe 01       	movw	r30, r28
    1884:	e9 5a       	subi	r30, 0xA9	; 169
    1886:	ff 4f       	sbci	r31, 0xFF	; 255
    1888:	91 83       	std	Z+1, r25	; 0x01
    188a:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    188c:	de 01       	movw	r26, r28
    188e:	a7 5a       	subi	r26, 0xA7	; 167
    1890:	bf 4f       	sbci	r27, 0xFF	; 255
    1892:	fe 01       	movw	r30, r28
    1894:	e7 5a       	subi	r30, 0xA7	; 167
    1896:	ff 4f       	sbci	r31, 0xFF	; 255
    1898:	80 81       	ld	r24, Z
    189a:	91 81       	ldd	r25, Z+1	; 0x01
    189c:	01 97       	sbiw	r24, 0x01	; 1
    189e:	11 96       	adiw	r26, 0x01	; 1
    18a0:	9c 93       	st	X, r25
    18a2:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    18a4:	fe 01       	movw	r30, r28
    18a6:	e7 5a       	subi	r30, 0xA7	; 167
    18a8:	ff 4f       	sbci	r31, 0xFF	; 255
    18aa:	80 81       	ld	r24, Z
    18ac:	91 81       	ldd	r25, Z+1	; 0x01
    18ae:	00 97       	sbiw	r24, 0x00	; 0
    18b0:	d1 f6       	brne	.-76     	; 0x1866 <LCD_sendCommand+0xf6>
    18b2:	27 c0       	rjmp	.+78     	; 0x1902 <LCD_sendCommand+0x192>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    18b4:	8e 01       	movw	r16, r28
    18b6:	07 5a       	subi	r16, 0xA7	; 167
    18b8:	1f 4f       	sbci	r17, 0xFF	; 255
    18ba:	fe 01       	movw	r30, r28
    18bc:	e5 5a       	subi	r30, 0xA5	; 165
    18be:	ff 4f       	sbci	r31, 0xFF	; 255
    18c0:	60 81       	ld	r22, Z
    18c2:	71 81       	ldd	r23, Z+1	; 0x01
    18c4:	82 81       	ldd	r24, Z+2	; 0x02
    18c6:	93 81       	ldd	r25, Z+3	; 0x03
    18c8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    18cc:	dc 01       	movw	r26, r24
    18ce:	cb 01       	movw	r24, r22
    18d0:	f8 01       	movw	r30, r16
    18d2:	91 83       	std	Z+1, r25	; 0x01
    18d4:	80 83       	st	Z, r24
    18d6:	de 01       	movw	r26, r28
    18d8:	ab 5a       	subi	r26, 0xAB	; 171
    18da:	bf 4f       	sbci	r27, 0xFF	; 255
    18dc:	fe 01       	movw	r30, r28
    18de:	e7 5a       	subi	r30, 0xA7	; 167
    18e0:	ff 4f       	sbci	r31, 0xFF	; 255
    18e2:	80 81       	ld	r24, Z
    18e4:	91 81       	ldd	r25, Z+1	; 0x01
    18e6:	8d 93       	st	X+, r24
    18e8:	9c 93       	st	X, r25
    18ea:	fe 01       	movw	r30, r28
    18ec:	eb 5a       	subi	r30, 0xAB	; 171
    18ee:	ff 4f       	sbci	r31, 0xFF	; 255
    18f0:	80 81       	ld	r24, Z
    18f2:	91 81       	ldd	r25, Z+1	; 0x01
    18f4:	01 97       	sbiw	r24, 0x01	; 1
    18f6:	f1 f7       	brne	.-4      	; 0x18f4 <LCD_sendCommand+0x184>
    18f8:	fe 01       	movw	r30, r28
    18fa:	eb 5a       	subi	r30, 0xAB	; 171
    18fc:	ff 4f       	sbci	r31, 0xFF	; 255
    18fe:	91 83       	std	Z+1, r25	; 0x01
    1900:	80 83       	st	Z, r24
	_delay_ms(1); /* delay for processing Tas = 50ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_HIGH); /* Enable LCD E=1 */
    1902:	80 e0       	ldi	r24, 0x00	; 0
    1904:	62 e0       	ldi	r22, 0x02	; 2
    1906:	41 e0       	ldi	r20, 0x01	; 1
    1908:	0e 94 b3 08 	call	0x1166	; 0x1166 <GPIO_writePin>
    190c:	fe 01       	movw	r30, r28
    190e:	ef 5a       	subi	r30, 0xAF	; 175
    1910:	ff 4f       	sbci	r31, 0xFF	; 255
    1912:	80 e0       	ldi	r24, 0x00	; 0
    1914:	90 e0       	ldi	r25, 0x00	; 0
    1916:	a0 e8       	ldi	r26, 0x80	; 128
    1918:	bf e3       	ldi	r27, 0x3F	; 63
    191a:	80 83       	st	Z, r24
    191c:	91 83       	std	Z+1, r25	; 0x01
    191e:	a2 83       	std	Z+2, r26	; 0x02
    1920:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1922:	8e 01       	movw	r16, r28
    1924:	03 5b       	subi	r16, 0xB3	; 179
    1926:	1f 4f       	sbci	r17, 0xFF	; 255
    1928:	fe 01       	movw	r30, r28
    192a:	ef 5a       	subi	r30, 0xAF	; 175
    192c:	ff 4f       	sbci	r31, 0xFF	; 255
    192e:	60 81       	ld	r22, Z
    1930:	71 81       	ldd	r23, Z+1	; 0x01
    1932:	82 81       	ldd	r24, Z+2	; 0x02
    1934:	93 81       	ldd	r25, Z+3	; 0x03
    1936:	20 e0       	ldi	r18, 0x00	; 0
    1938:	30 e0       	ldi	r19, 0x00	; 0
    193a:	4a ef       	ldi	r20, 0xFA	; 250
    193c:	54 e4       	ldi	r21, 0x44	; 68
    193e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1942:	dc 01       	movw	r26, r24
    1944:	cb 01       	movw	r24, r22
    1946:	f8 01       	movw	r30, r16
    1948:	80 83       	st	Z, r24
    194a:	91 83       	std	Z+1, r25	; 0x01
    194c:	a2 83       	std	Z+2, r26	; 0x02
    194e:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    1950:	fe 01       	movw	r30, r28
    1952:	e3 5b       	subi	r30, 0xB3	; 179
    1954:	ff 4f       	sbci	r31, 0xFF	; 255
    1956:	60 81       	ld	r22, Z
    1958:	71 81       	ldd	r23, Z+1	; 0x01
    195a:	82 81       	ldd	r24, Z+2	; 0x02
    195c:	93 81       	ldd	r25, Z+3	; 0x03
    195e:	20 e0       	ldi	r18, 0x00	; 0
    1960:	30 e0       	ldi	r19, 0x00	; 0
    1962:	40 e8       	ldi	r20, 0x80	; 128
    1964:	5f e3       	ldi	r21, 0x3F	; 63
    1966:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    196a:	88 23       	and	r24, r24
    196c:	44 f4       	brge	.+16     	; 0x197e <LCD_sendCommand+0x20e>
		__ticks = 1;
    196e:	fe 01       	movw	r30, r28
    1970:	e5 5b       	subi	r30, 0xB5	; 181
    1972:	ff 4f       	sbci	r31, 0xFF	; 255
    1974:	81 e0       	ldi	r24, 0x01	; 1
    1976:	90 e0       	ldi	r25, 0x00	; 0
    1978:	91 83       	std	Z+1, r25	; 0x01
    197a:	80 83       	st	Z, r24
    197c:	64 c0       	rjmp	.+200    	; 0x1a46 <LCD_sendCommand+0x2d6>
	else if (__tmp > 65535)
    197e:	fe 01       	movw	r30, r28
    1980:	e3 5b       	subi	r30, 0xB3	; 179
    1982:	ff 4f       	sbci	r31, 0xFF	; 255
    1984:	60 81       	ld	r22, Z
    1986:	71 81       	ldd	r23, Z+1	; 0x01
    1988:	82 81       	ldd	r24, Z+2	; 0x02
    198a:	93 81       	ldd	r25, Z+3	; 0x03
    198c:	20 e0       	ldi	r18, 0x00	; 0
    198e:	3f ef       	ldi	r19, 0xFF	; 255
    1990:	4f e7       	ldi	r20, 0x7F	; 127
    1992:	57 e4       	ldi	r21, 0x47	; 71
    1994:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1998:	18 16       	cp	r1, r24
    199a:	0c f0       	brlt	.+2      	; 0x199e <LCD_sendCommand+0x22e>
    199c:	43 c0       	rjmp	.+134    	; 0x1a24 <LCD_sendCommand+0x2b4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    199e:	fe 01       	movw	r30, r28
    19a0:	ef 5a       	subi	r30, 0xAF	; 175
    19a2:	ff 4f       	sbci	r31, 0xFF	; 255
    19a4:	60 81       	ld	r22, Z
    19a6:	71 81       	ldd	r23, Z+1	; 0x01
    19a8:	82 81       	ldd	r24, Z+2	; 0x02
    19aa:	93 81       	ldd	r25, Z+3	; 0x03
    19ac:	20 e0       	ldi	r18, 0x00	; 0
    19ae:	30 e0       	ldi	r19, 0x00	; 0
    19b0:	40 e2       	ldi	r20, 0x20	; 32
    19b2:	51 e4       	ldi	r21, 0x41	; 65
    19b4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    19b8:	dc 01       	movw	r26, r24
    19ba:	cb 01       	movw	r24, r22
    19bc:	8e 01       	movw	r16, r28
    19be:	05 5b       	subi	r16, 0xB5	; 181
    19c0:	1f 4f       	sbci	r17, 0xFF	; 255
    19c2:	bc 01       	movw	r22, r24
    19c4:	cd 01       	movw	r24, r26
    19c6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    19ca:	dc 01       	movw	r26, r24
    19cc:	cb 01       	movw	r24, r22
    19ce:	f8 01       	movw	r30, r16
    19d0:	91 83       	std	Z+1, r25	; 0x01
    19d2:	80 83       	st	Z, r24
    19d4:	1f c0       	rjmp	.+62     	; 0x1a14 <LCD_sendCommand+0x2a4>
    19d6:	fe 01       	movw	r30, r28
    19d8:	e7 5b       	subi	r30, 0xB7	; 183
    19da:	ff 4f       	sbci	r31, 0xFF	; 255
    19dc:	88 ec       	ldi	r24, 0xC8	; 200
    19de:	90 e0       	ldi	r25, 0x00	; 0
    19e0:	91 83       	std	Z+1, r25	; 0x01
    19e2:	80 83       	st	Z, r24
    19e4:	fe 01       	movw	r30, r28
    19e6:	e7 5b       	subi	r30, 0xB7	; 183
    19e8:	ff 4f       	sbci	r31, 0xFF	; 255
    19ea:	80 81       	ld	r24, Z
    19ec:	91 81       	ldd	r25, Z+1	; 0x01
    19ee:	01 97       	sbiw	r24, 0x01	; 1
    19f0:	f1 f7       	brne	.-4      	; 0x19ee <LCD_sendCommand+0x27e>
    19f2:	fe 01       	movw	r30, r28
    19f4:	e7 5b       	subi	r30, 0xB7	; 183
    19f6:	ff 4f       	sbci	r31, 0xFF	; 255
    19f8:	91 83       	std	Z+1, r25	; 0x01
    19fa:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    19fc:	de 01       	movw	r26, r28
    19fe:	a5 5b       	subi	r26, 0xB5	; 181
    1a00:	bf 4f       	sbci	r27, 0xFF	; 255
    1a02:	fe 01       	movw	r30, r28
    1a04:	e5 5b       	subi	r30, 0xB5	; 181
    1a06:	ff 4f       	sbci	r31, 0xFF	; 255
    1a08:	80 81       	ld	r24, Z
    1a0a:	91 81       	ldd	r25, Z+1	; 0x01
    1a0c:	01 97       	sbiw	r24, 0x01	; 1
    1a0e:	11 96       	adiw	r26, 0x01	; 1
    1a10:	9c 93       	st	X, r25
    1a12:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1a14:	fe 01       	movw	r30, r28
    1a16:	e5 5b       	subi	r30, 0xB5	; 181
    1a18:	ff 4f       	sbci	r31, 0xFF	; 255
    1a1a:	80 81       	ld	r24, Z
    1a1c:	91 81       	ldd	r25, Z+1	; 0x01
    1a1e:	00 97       	sbiw	r24, 0x00	; 0
    1a20:	d1 f6       	brne	.-76     	; 0x19d6 <LCD_sendCommand+0x266>
    1a22:	27 c0       	rjmp	.+78     	; 0x1a72 <LCD_sendCommand+0x302>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1a24:	8e 01       	movw	r16, r28
    1a26:	05 5b       	subi	r16, 0xB5	; 181
    1a28:	1f 4f       	sbci	r17, 0xFF	; 255
    1a2a:	fe 01       	movw	r30, r28
    1a2c:	e3 5b       	subi	r30, 0xB3	; 179
    1a2e:	ff 4f       	sbci	r31, 0xFF	; 255
    1a30:	60 81       	ld	r22, Z
    1a32:	71 81       	ldd	r23, Z+1	; 0x01
    1a34:	82 81       	ldd	r24, Z+2	; 0x02
    1a36:	93 81       	ldd	r25, Z+3	; 0x03
    1a38:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1a3c:	dc 01       	movw	r26, r24
    1a3e:	cb 01       	movw	r24, r22
    1a40:	f8 01       	movw	r30, r16
    1a42:	91 83       	std	Z+1, r25	; 0x01
    1a44:	80 83       	st	Z, r24
    1a46:	de 01       	movw	r26, r28
    1a48:	a9 5b       	subi	r26, 0xB9	; 185
    1a4a:	bf 4f       	sbci	r27, 0xFF	; 255
    1a4c:	fe 01       	movw	r30, r28
    1a4e:	e5 5b       	subi	r30, 0xB5	; 181
    1a50:	ff 4f       	sbci	r31, 0xFF	; 255
    1a52:	80 81       	ld	r24, Z
    1a54:	91 81       	ldd	r25, Z+1	; 0x01
    1a56:	8d 93       	st	X+, r24
    1a58:	9c 93       	st	X, r25
    1a5a:	fe 01       	movw	r30, r28
    1a5c:	e9 5b       	subi	r30, 0xB9	; 185
    1a5e:	ff 4f       	sbci	r31, 0xFF	; 255
    1a60:	80 81       	ld	r24, Z
    1a62:	91 81       	ldd	r25, Z+1	; 0x01
    1a64:	01 97       	sbiw	r24, 0x01	; 1
    1a66:	f1 f7       	brne	.-4      	; 0x1a64 <LCD_sendCommand+0x2f4>
    1a68:	fe 01       	movw	r30, r28
    1a6a:	e9 5b       	subi	r30, 0xB9	; 185
    1a6c:	ff 4f       	sbci	r31, 0xFF	; 255
    1a6e:	91 83       	std	Z+1, r25	; 0x01
    1a70:	80 83       	st	Z, r24
	_delay_ms(1); /* delay for processing Tpw - Tdws = 190ns */

#if(LCD_DATA_BITS_MODE == 4)
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB4_PIN_ID,GET_BIT(command,4));
    1a72:	fe 01       	movw	r30, r28
    1a74:	ed 59       	subi	r30, 0x9D	; 157
    1a76:	ff 4f       	sbci	r31, 0xFF	; 255
    1a78:	80 81       	ld	r24, Z
    1a7a:	88 2f       	mov	r24, r24
    1a7c:	90 e0       	ldi	r25, 0x00	; 0
    1a7e:	80 71       	andi	r24, 0x10	; 16
    1a80:	90 70       	andi	r25, 0x00	; 0
    1a82:	95 95       	asr	r25
    1a84:	87 95       	ror	r24
    1a86:	95 95       	asr	r25
    1a88:	87 95       	ror	r24
    1a8a:	95 95       	asr	r25
    1a8c:	87 95       	ror	r24
    1a8e:	95 95       	asr	r25
    1a90:	87 95       	ror	r24
    1a92:	98 2f       	mov	r25, r24
    1a94:	80 e0       	ldi	r24, 0x00	; 0
    1a96:	63 e0       	ldi	r22, 0x03	; 3
    1a98:	49 2f       	mov	r20, r25
    1a9a:	0e 94 b3 08 	call	0x1166	; 0x1166 <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB5_PIN_ID,GET_BIT(command,5));
    1a9e:	fe 01       	movw	r30, r28
    1aa0:	ed 59       	subi	r30, 0x9D	; 157
    1aa2:	ff 4f       	sbci	r31, 0xFF	; 255
    1aa4:	80 81       	ld	r24, Z
    1aa6:	88 2f       	mov	r24, r24
    1aa8:	90 e0       	ldi	r25, 0x00	; 0
    1aaa:	80 72       	andi	r24, 0x20	; 32
    1aac:	90 70       	andi	r25, 0x00	; 0
    1aae:	95 95       	asr	r25
    1ab0:	87 95       	ror	r24
    1ab2:	95 95       	asr	r25
    1ab4:	87 95       	ror	r24
    1ab6:	95 95       	asr	r25
    1ab8:	87 95       	ror	r24
    1aba:	95 95       	asr	r25
    1abc:	87 95       	ror	r24
    1abe:	95 95       	asr	r25
    1ac0:	87 95       	ror	r24
    1ac2:	98 2f       	mov	r25, r24
    1ac4:	80 e0       	ldi	r24, 0x00	; 0
    1ac6:	64 e0       	ldi	r22, 0x04	; 4
    1ac8:	49 2f       	mov	r20, r25
    1aca:	0e 94 b3 08 	call	0x1166	; 0x1166 <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB6_PIN_ID,GET_BIT(command,6));
    1ace:	fe 01       	movw	r30, r28
    1ad0:	ed 59       	subi	r30, 0x9D	; 157
    1ad2:	ff 4f       	sbci	r31, 0xFF	; 255
    1ad4:	80 81       	ld	r24, Z
    1ad6:	88 2f       	mov	r24, r24
    1ad8:	90 e0       	ldi	r25, 0x00	; 0
    1ada:	80 74       	andi	r24, 0x40	; 64
    1adc:	90 70       	andi	r25, 0x00	; 0
    1ade:	08 2e       	mov	r0, r24
    1ae0:	89 2f       	mov	r24, r25
    1ae2:	00 0c       	add	r0, r0
    1ae4:	88 1f       	adc	r24, r24
    1ae6:	99 0b       	sbc	r25, r25
    1ae8:	00 0c       	add	r0, r0
    1aea:	88 1f       	adc	r24, r24
    1aec:	99 1f       	adc	r25, r25
    1aee:	98 2f       	mov	r25, r24
    1af0:	80 e0       	ldi	r24, 0x00	; 0
    1af2:	65 e0       	ldi	r22, 0x05	; 5
    1af4:	49 2f       	mov	r20, r25
    1af6:	0e 94 b3 08 	call	0x1166	; 0x1166 <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB7_PIN_ID,GET_BIT(command,7));
    1afa:	fe 01       	movw	r30, r28
    1afc:	ed 59       	subi	r30, 0x9D	; 157
    1afe:	ff 4f       	sbci	r31, 0xFF	; 255
    1b00:	80 81       	ld	r24, Z
    1b02:	98 2f       	mov	r25, r24
    1b04:	99 1f       	adc	r25, r25
    1b06:	99 27       	eor	r25, r25
    1b08:	99 1f       	adc	r25, r25
    1b0a:	80 e0       	ldi	r24, 0x00	; 0
    1b0c:	66 e0       	ldi	r22, 0x06	; 6
    1b0e:	49 2f       	mov	r20, r25
    1b10:	0e 94 b3 08 	call	0x1166	; 0x1166 <GPIO_writePin>
    1b14:	fe 01       	movw	r30, r28
    1b16:	ed 5b       	subi	r30, 0xBD	; 189
    1b18:	ff 4f       	sbci	r31, 0xFF	; 255
    1b1a:	80 e0       	ldi	r24, 0x00	; 0
    1b1c:	90 e0       	ldi	r25, 0x00	; 0
    1b1e:	a0 e8       	ldi	r26, 0x80	; 128
    1b20:	bf e3       	ldi	r27, 0x3F	; 63
    1b22:	80 83       	st	Z, r24
    1b24:	91 83       	std	Z+1, r25	; 0x01
    1b26:	a2 83       	std	Z+2, r26	; 0x02
    1b28:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1b2a:	8e 01       	movw	r16, r28
    1b2c:	01 5c       	subi	r16, 0xC1	; 193
    1b2e:	1f 4f       	sbci	r17, 0xFF	; 255
    1b30:	fe 01       	movw	r30, r28
    1b32:	ed 5b       	subi	r30, 0xBD	; 189
    1b34:	ff 4f       	sbci	r31, 0xFF	; 255
    1b36:	60 81       	ld	r22, Z
    1b38:	71 81       	ldd	r23, Z+1	; 0x01
    1b3a:	82 81       	ldd	r24, Z+2	; 0x02
    1b3c:	93 81       	ldd	r25, Z+3	; 0x03
    1b3e:	20 e0       	ldi	r18, 0x00	; 0
    1b40:	30 e0       	ldi	r19, 0x00	; 0
    1b42:	4a ef       	ldi	r20, 0xFA	; 250
    1b44:	54 e4       	ldi	r21, 0x44	; 68
    1b46:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1b4a:	dc 01       	movw	r26, r24
    1b4c:	cb 01       	movw	r24, r22
    1b4e:	f8 01       	movw	r30, r16
    1b50:	80 83       	st	Z, r24
    1b52:	91 83       	std	Z+1, r25	; 0x01
    1b54:	a2 83       	std	Z+2, r26	; 0x02
    1b56:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    1b58:	fe 01       	movw	r30, r28
    1b5a:	ff 96       	adiw	r30, 0x3f	; 63
    1b5c:	60 81       	ld	r22, Z
    1b5e:	71 81       	ldd	r23, Z+1	; 0x01
    1b60:	82 81       	ldd	r24, Z+2	; 0x02
    1b62:	93 81       	ldd	r25, Z+3	; 0x03
    1b64:	20 e0       	ldi	r18, 0x00	; 0
    1b66:	30 e0       	ldi	r19, 0x00	; 0
    1b68:	40 e8       	ldi	r20, 0x80	; 128
    1b6a:	5f e3       	ldi	r21, 0x3F	; 63
    1b6c:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1b70:	88 23       	and	r24, r24
    1b72:	2c f4       	brge	.+10     	; 0x1b7e <LCD_sendCommand+0x40e>
		__ticks = 1;
    1b74:	81 e0       	ldi	r24, 0x01	; 1
    1b76:	90 e0       	ldi	r25, 0x00	; 0
    1b78:	9e af       	std	Y+62, r25	; 0x3e
    1b7a:	8d af       	std	Y+61, r24	; 0x3d
    1b7c:	46 c0       	rjmp	.+140    	; 0x1c0a <LCD_sendCommand+0x49a>
	else if (__tmp > 65535)
    1b7e:	fe 01       	movw	r30, r28
    1b80:	ff 96       	adiw	r30, 0x3f	; 63
    1b82:	60 81       	ld	r22, Z
    1b84:	71 81       	ldd	r23, Z+1	; 0x01
    1b86:	82 81       	ldd	r24, Z+2	; 0x02
    1b88:	93 81       	ldd	r25, Z+3	; 0x03
    1b8a:	20 e0       	ldi	r18, 0x00	; 0
    1b8c:	3f ef       	ldi	r19, 0xFF	; 255
    1b8e:	4f e7       	ldi	r20, 0x7F	; 127
    1b90:	57 e4       	ldi	r21, 0x47	; 71
    1b92:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1b96:	18 16       	cp	r1, r24
    1b98:	64 f5       	brge	.+88     	; 0x1bf2 <LCD_sendCommand+0x482>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1b9a:	fe 01       	movw	r30, r28
    1b9c:	ed 5b       	subi	r30, 0xBD	; 189
    1b9e:	ff 4f       	sbci	r31, 0xFF	; 255
    1ba0:	60 81       	ld	r22, Z
    1ba2:	71 81       	ldd	r23, Z+1	; 0x01
    1ba4:	82 81       	ldd	r24, Z+2	; 0x02
    1ba6:	93 81       	ldd	r25, Z+3	; 0x03
    1ba8:	20 e0       	ldi	r18, 0x00	; 0
    1baa:	30 e0       	ldi	r19, 0x00	; 0
    1bac:	40 e2       	ldi	r20, 0x20	; 32
    1bae:	51 e4       	ldi	r21, 0x41	; 65
    1bb0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1bb4:	dc 01       	movw	r26, r24
    1bb6:	cb 01       	movw	r24, r22
    1bb8:	bc 01       	movw	r22, r24
    1bba:	cd 01       	movw	r24, r26
    1bbc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1bc0:	dc 01       	movw	r26, r24
    1bc2:	cb 01       	movw	r24, r22
    1bc4:	9e af       	std	Y+62, r25	; 0x3e
    1bc6:	8d af       	std	Y+61, r24	; 0x3d
    1bc8:	0f c0       	rjmp	.+30     	; 0x1be8 <LCD_sendCommand+0x478>
    1bca:	88 ec       	ldi	r24, 0xC8	; 200
    1bcc:	90 e0       	ldi	r25, 0x00	; 0
    1bce:	9c af       	std	Y+60, r25	; 0x3c
    1bd0:	8b af       	std	Y+59, r24	; 0x3b
    1bd2:	8b ad       	ldd	r24, Y+59	; 0x3b
    1bd4:	9c ad       	ldd	r25, Y+60	; 0x3c
    1bd6:	01 97       	sbiw	r24, 0x01	; 1
    1bd8:	f1 f7       	brne	.-4      	; 0x1bd6 <LCD_sendCommand+0x466>
    1bda:	9c af       	std	Y+60, r25	; 0x3c
    1bdc:	8b af       	std	Y+59, r24	; 0x3b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1bde:	8d ad       	ldd	r24, Y+61	; 0x3d
    1be0:	9e ad       	ldd	r25, Y+62	; 0x3e
    1be2:	01 97       	sbiw	r24, 0x01	; 1
    1be4:	9e af       	std	Y+62, r25	; 0x3e
    1be6:	8d af       	std	Y+61, r24	; 0x3d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1be8:	8d ad       	ldd	r24, Y+61	; 0x3d
    1bea:	9e ad       	ldd	r25, Y+62	; 0x3e
    1bec:	00 97       	sbiw	r24, 0x00	; 0
    1bee:	69 f7       	brne	.-38     	; 0x1bca <LCD_sendCommand+0x45a>
    1bf0:	16 c0       	rjmp	.+44     	; 0x1c1e <LCD_sendCommand+0x4ae>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1bf2:	fe 01       	movw	r30, r28
    1bf4:	ff 96       	adiw	r30, 0x3f	; 63
    1bf6:	60 81       	ld	r22, Z
    1bf8:	71 81       	ldd	r23, Z+1	; 0x01
    1bfa:	82 81       	ldd	r24, Z+2	; 0x02
    1bfc:	93 81       	ldd	r25, Z+3	; 0x03
    1bfe:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1c02:	dc 01       	movw	r26, r24
    1c04:	cb 01       	movw	r24, r22
    1c06:	9e af       	std	Y+62, r25	; 0x3e
    1c08:	8d af       	std	Y+61, r24	; 0x3d
    1c0a:	8d ad       	ldd	r24, Y+61	; 0x3d
    1c0c:	9e ad       	ldd	r25, Y+62	; 0x3e
    1c0e:	9a af       	std	Y+58, r25	; 0x3a
    1c10:	89 af       	std	Y+57, r24	; 0x39
    1c12:	89 ad       	ldd	r24, Y+57	; 0x39
    1c14:	9a ad       	ldd	r25, Y+58	; 0x3a
    1c16:	01 97       	sbiw	r24, 0x01	; 1
    1c18:	f1 f7       	brne	.-4      	; 0x1c16 <LCD_sendCommand+0x4a6>
    1c1a:	9a af       	std	Y+58, r25	; 0x3a
    1c1c:	89 af       	std	Y+57, r24	; 0x39

	_delay_ms(1); /* delay for processing Tdsw = 100ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_LOW); /* Disable LCD E=0 */
    1c1e:	80 e0       	ldi	r24, 0x00	; 0
    1c20:	62 e0       	ldi	r22, 0x02	; 2
    1c22:	40 e0       	ldi	r20, 0x00	; 0
    1c24:	0e 94 b3 08 	call	0x1166	; 0x1166 <GPIO_writePin>
    1c28:	80 e0       	ldi	r24, 0x00	; 0
    1c2a:	90 e0       	ldi	r25, 0x00	; 0
    1c2c:	a0 e8       	ldi	r26, 0x80	; 128
    1c2e:	bf e3       	ldi	r27, 0x3F	; 63
    1c30:	8d ab       	std	Y+53, r24	; 0x35
    1c32:	9e ab       	std	Y+54, r25	; 0x36
    1c34:	af ab       	std	Y+55, r26	; 0x37
    1c36:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1c38:	6d a9       	ldd	r22, Y+53	; 0x35
    1c3a:	7e a9       	ldd	r23, Y+54	; 0x36
    1c3c:	8f a9       	ldd	r24, Y+55	; 0x37
    1c3e:	98 ad       	ldd	r25, Y+56	; 0x38
    1c40:	20 e0       	ldi	r18, 0x00	; 0
    1c42:	30 e0       	ldi	r19, 0x00	; 0
    1c44:	4a ef       	ldi	r20, 0xFA	; 250
    1c46:	54 e4       	ldi	r21, 0x44	; 68
    1c48:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1c4c:	dc 01       	movw	r26, r24
    1c4e:	cb 01       	movw	r24, r22
    1c50:	89 ab       	std	Y+49, r24	; 0x31
    1c52:	9a ab       	std	Y+50, r25	; 0x32
    1c54:	ab ab       	std	Y+51, r26	; 0x33
    1c56:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    1c58:	69 a9       	ldd	r22, Y+49	; 0x31
    1c5a:	7a a9       	ldd	r23, Y+50	; 0x32
    1c5c:	8b a9       	ldd	r24, Y+51	; 0x33
    1c5e:	9c a9       	ldd	r25, Y+52	; 0x34
    1c60:	20 e0       	ldi	r18, 0x00	; 0
    1c62:	30 e0       	ldi	r19, 0x00	; 0
    1c64:	40 e8       	ldi	r20, 0x80	; 128
    1c66:	5f e3       	ldi	r21, 0x3F	; 63
    1c68:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1c6c:	88 23       	and	r24, r24
    1c6e:	2c f4       	brge	.+10     	; 0x1c7a <LCD_sendCommand+0x50a>
		__ticks = 1;
    1c70:	81 e0       	ldi	r24, 0x01	; 1
    1c72:	90 e0       	ldi	r25, 0x00	; 0
    1c74:	98 ab       	std	Y+48, r25	; 0x30
    1c76:	8f a7       	std	Y+47, r24	; 0x2f
    1c78:	3f c0       	rjmp	.+126    	; 0x1cf8 <LCD_sendCommand+0x588>
	else if (__tmp > 65535)
    1c7a:	69 a9       	ldd	r22, Y+49	; 0x31
    1c7c:	7a a9       	ldd	r23, Y+50	; 0x32
    1c7e:	8b a9       	ldd	r24, Y+51	; 0x33
    1c80:	9c a9       	ldd	r25, Y+52	; 0x34
    1c82:	20 e0       	ldi	r18, 0x00	; 0
    1c84:	3f ef       	ldi	r19, 0xFF	; 255
    1c86:	4f e7       	ldi	r20, 0x7F	; 127
    1c88:	57 e4       	ldi	r21, 0x47	; 71
    1c8a:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1c8e:	18 16       	cp	r1, r24
    1c90:	4c f5       	brge	.+82     	; 0x1ce4 <LCD_sendCommand+0x574>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1c92:	6d a9       	ldd	r22, Y+53	; 0x35
    1c94:	7e a9       	ldd	r23, Y+54	; 0x36
    1c96:	8f a9       	ldd	r24, Y+55	; 0x37
    1c98:	98 ad       	ldd	r25, Y+56	; 0x38
    1c9a:	20 e0       	ldi	r18, 0x00	; 0
    1c9c:	30 e0       	ldi	r19, 0x00	; 0
    1c9e:	40 e2       	ldi	r20, 0x20	; 32
    1ca0:	51 e4       	ldi	r21, 0x41	; 65
    1ca2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1ca6:	dc 01       	movw	r26, r24
    1ca8:	cb 01       	movw	r24, r22
    1caa:	bc 01       	movw	r22, r24
    1cac:	cd 01       	movw	r24, r26
    1cae:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1cb2:	dc 01       	movw	r26, r24
    1cb4:	cb 01       	movw	r24, r22
    1cb6:	98 ab       	std	Y+48, r25	; 0x30
    1cb8:	8f a7       	std	Y+47, r24	; 0x2f
    1cba:	0f c0       	rjmp	.+30     	; 0x1cda <LCD_sendCommand+0x56a>
    1cbc:	88 ec       	ldi	r24, 0xC8	; 200
    1cbe:	90 e0       	ldi	r25, 0x00	; 0
    1cc0:	9e a7       	std	Y+46, r25	; 0x2e
    1cc2:	8d a7       	std	Y+45, r24	; 0x2d
    1cc4:	8d a5       	ldd	r24, Y+45	; 0x2d
    1cc6:	9e a5       	ldd	r25, Y+46	; 0x2e
    1cc8:	01 97       	sbiw	r24, 0x01	; 1
    1cca:	f1 f7       	brne	.-4      	; 0x1cc8 <LCD_sendCommand+0x558>
    1ccc:	9e a7       	std	Y+46, r25	; 0x2e
    1cce:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1cd0:	8f a5       	ldd	r24, Y+47	; 0x2f
    1cd2:	98 a9       	ldd	r25, Y+48	; 0x30
    1cd4:	01 97       	sbiw	r24, 0x01	; 1
    1cd6:	98 ab       	std	Y+48, r25	; 0x30
    1cd8:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1cda:	8f a5       	ldd	r24, Y+47	; 0x2f
    1cdc:	98 a9       	ldd	r25, Y+48	; 0x30
    1cde:	00 97       	sbiw	r24, 0x00	; 0
    1ce0:	69 f7       	brne	.-38     	; 0x1cbc <LCD_sendCommand+0x54c>
    1ce2:	14 c0       	rjmp	.+40     	; 0x1d0c <LCD_sendCommand+0x59c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1ce4:	69 a9       	ldd	r22, Y+49	; 0x31
    1ce6:	7a a9       	ldd	r23, Y+50	; 0x32
    1ce8:	8b a9       	ldd	r24, Y+51	; 0x33
    1cea:	9c a9       	ldd	r25, Y+52	; 0x34
    1cec:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1cf0:	dc 01       	movw	r26, r24
    1cf2:	cb 01       	movw	r24, r22
    1cf4:	98 ab       	std	Y+48, r25	; 0x30
    1cf6:	8f a7       	std	Y+47, r24	; 0x2f
    1cf8:	8f a5       	ldd	r24, Y+47	; 0x2f
    1cfa:	98 a9       	ldd	r25, Y+48	; 0x30
    1cfc:	9c a7       	std	Y+44, r25	; 0x2c
    1cfe:	8b a7       	std	Y+43, r24	; 0x2b
    1d00:	8b a5       	ldd	r24, Y+43	; 0x2b
    1d02:	9c a5       	ldd	r25, Y+44	; 0x2c
    1d04:	01 97       	sbiw	r24, 0x01	; 1
    1d06:	f1 f7       	brne	.-4      	; 0x1d04 <LCD_sendCommand+0x594>
    1d08:	9c a7       	std	Y+44, r25	; 0x2c
    1d0a:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(1); /* delay for processing Th = 13ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_HIGH); /* Enable LCD E=1 */
    1d0c:	80 e0       	ldi	r24, 0x00	; 0
    1d0e:	62 e0       	ldi	r22, 0x02	; 2
    1d10:	41 e0       	ldi	r20, 0x01	; 1
    1d12:	0e 94 b3 08 	call	0x1166	; 0x1166 <GPIO_writePin>
    1d16:	80 e0       	ldi	r24, 0x00	; 0
    1d18:	90 e0       	ldi	r25, 0x00	; 0
    1d1a:	a0 e8       	ldi	r26, 0x80	; 128
    1d1c:	bf e3       	ldi	r27, 0x3F	; 63
    1d1e:	8f a3       	std	Y+39, r24	; 0x27
    1d20:	98 a7       	std	Y+40, r25	; 0x28
    1d22:	a9 a7       	std	Y+41, r26	; 0x29
    1d24:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1d26:	6f a1       	ldd	r22, Y+39	; 0x27
    1d28:	78 a5       	ldd	r23, Y+40	; 0x28
    1d2a:	89 a5       	ldd	r24, Y+41	; 0x29
    1d2c:	9a a5       	ldd	r25, Y+42	; 0x2a
    1d2e:	20 e0       	ldi	r18, 0x00	; 0
    1d30:	30 e0       	ldi	r19, 0x00	; 0
    1d32:	4a ef       	ldi	r20, 0xFA	; 250
    1d34:	54 e4       	ldi	r21, 0x44	; 68
    1d36:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1d3a:	dc 01       	movw	r26, r24
    1d3c:	cb 01       	movw	r24, r22
    1d3e:	8b a3       	std	Y+35, r24	; 0x23
    1d40:	9c a3       	std	Y+36, r25	; 0x24
    1d42:	ad a3       	std	Y+37, r26	; 0x25
    1d44:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    1d46:	6b a1       	ldd	r22, Y+35	; 0x23
    1d48:	7c a1       	ldd	r23, Y+36	; 0x24
    1d4a:	8d a1       	ldd	r24, Y+37	; 0x25
    1d4c:	9e a1       	ldd	r25, Y+38	; 0x26
    1d4e:	20 e0       	ldi	r18, 0x00	; 0
    1d50:	30 e0       	ldi	r19, 0x00	; 0
    1d52:	40 e8       	ldi	r20, 0x80	; 128
    1d54:	5f e3       	ldi	r21, 0x3F	; 63
    1d56:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1d5a:	88 23       	and	r24, r24
    1d5c:	2c f4       	brge	.+10     	; 0x1d68 <LCD_sendCommand+0x5f8>
		__ticks = 1;
    1d5e:	81 e0       	ldi	r24, 0x01	; 1
    1d60:	90 e0       	ldi	r25, 0x00	; 0
    1d62:	9a a3       	std	Y+34, r25	; 0x22
    1d64:	89 a3       	std	Y+33, r24	; 0x21
    1d66:	3f c0       	rjmp	.+126    	; 0x1de6 <LCD_sendCommand+0x676>
	else if (__tmp > 65535)
    1d68:	6b a1       	ldd	r22, Y+35	; 0x23
    1d6a:	7c a1       	ldd	r23, Y+36	; 0x24
    1d6c:	8d a1       	ldd	r24, Y+37	; 0x25
    1d6e:	9e a1       	ldd	r25, Y+38	; 0x26
    1d70:	20 e0       	ldi	r18, 0x00	; 0
    1d72:	3f ef       	ldi	r19, 0xFF	; 255
    1d74:	4f e7       	ldi	r20, 0x7F	; 127
    1d76:	57 e4       	ldi	r21, 0x47	; 71
    1d78:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1d7c:	18 16       	cp	r1, r24
    1d7e:	4c f5       	brge	.+82     	; 0x1dd2 <LCD_sendCommand+0x662>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1d80:	6f a1       	ldd	r22, Y+39	; 0x27
    1d82:	78 a5       	ldd	r23, Y+40	; 0x28
    1d84:	89 a5       	ldd	r24, Y+41	; 0x29
    1d86:	9a a5       	ldd	r25, Y+42	; 0x2a
    1d88:	20 e0       	ldi	r18, 0x00	; 0
    1d8a:	30 e0       	ldi	r19, 0x00	; 0
    1d8c:	40 e2       	ldi	r20, 0x20	; 32
    1d8e:	51 e4       	ldi	r21, 0x41	; 65
    1d90:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1d94:	dc 01       	movw	r26, r24
    1d96:	cb 01       	movw	r24, r22
    1d98:	bc 01       	movw	r22, r24
    1d9a:	cd 01       	movw	r24, r26
    1d9c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1da0:	dc 01       	movw	r26, r24
    1da2:	cb 01       	movw	r24, r22
    1da4:	9a a3       	std	Y+34, r25	; 0x22
    1da6:	89 a3       	std	Y+33, r24	; 0x21
    1da8:	0f c0       	rjmp	.+30     	; 0x1dc8 <LCD_sendCommand+0x658>
    1daa:	88 ec       	ldi	r24, 0xC8	; 200
    1dac:	90 e0       	ldi	r25, 0x00	; 0
    1dae:	98 a3       	std	Y+32, r25	; 0x20
    1db0:	8f 8f       	std	Y+31, r24	; 0x1f
    1db2:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1db4:	98 a1       	ldd	r25, Y+32	; 0x20
    1db6:	01 97       	sbiw	r24, 0x01	; 1
    1db8:	f1 f7       	brne	.-4      	; 0x1db6 <LCD_sendCommand+0x646>
    1dba:	98 a3       	std	Y+32, r25	; 0x20
    1dbc:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1dbe:	89 a1       	ldd	r24, Y+33	; 0x21
    1dc0:	9a a1       	ldd	r25, Y+34	; 0x22
    1dc2:	01 97       	sbiw	r24, 0x01	; 1
    1dc4:	9a a3       	std	Y+34, r25	; 0x22
    1dc6:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1dc8:	89 a1       	ldd	r24, Y+33	; 0x21
    1dca:	9a a1       	ldd	r25, Y+34	; 0x22
    1dcc:	00 97       	sbiw	r24, 0x00	; 0
    1dce:	69 f7       	brne	.-38     	; 0x1daa <LCD_sendCommand+0x63a>
    1dd0:	14 c0       	rjmp	.+40     	; 0x1dfa <LCD_sendCommand+0x68a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1dd2:	6b a1       	ldd	r22, Y+35	; 0x23
    1dd4:	7c a1       	ldd	r23, Y+36	; 0x24
    1dd6:	8d a1       	ldd	r24, Y+37	; 0x25
    1dd8:	9e a1       	ldd	r25, Y+38	; 0x26
    1dda:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1dde:	dc 01       	movw	r26, r24
    1de0:	cb 01       	movw	r24, r22
    1de2:	9a a3       	std	Y+34, r25	; 0x22
    1de4:	89 a3       	std	Y+33, r24	; 0x21
    1de6:	89 a1       	ldd	r24, Y+33	; 0x21
    1de8:	9a a1       	ldd	r25, Y+34	; 0x22
    1dea:	9e 8f       	std	Y+30, r25	; 0x1e
    1dec:	8d 8f       	std	Y+29, r24	; 0x1d
    1dee:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1df0:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1df2:	01 97       	sbiw	r24, 0x01	; 1
    1df4:	f1 f7       	brne	.-4      	; 0x1df2 <LCD_sendCommand+0x682>
    1df6:	9e 8f       	std	Y+30, r25	; 0x1e
    1df8:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(1); /* delay for processing Tpw - Tdws = 190ns */

	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB4_PIN_ID,GET_BIT(command,0));
    1dfa:	fe 01       	movw	r30, r28
    1dfc:	ed 59       	subi	r30, 0x9D	; 157
    1dfe:	ff 4f       	sbci	r31, 0xFF	; 255
    1e00:	80 81       	ld	r24, Z
    1e02:	98 2f       	mov	r25, r24
    1e04:	91 70       	andi	r25, 0x01	; 1
    1e06:	80 e0       	ldi	r24, 0x00	; 0
    1e08:	63 e0       	ldi	r22, 0x03	; 3
    1e0a:	49 2f       	mov	r20, r25
    1e0c:	0e 94 b3 08 	call	0x1166	; 0x1166 <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB5_PIN_ID,GET_BIT(command,1));
    1e10:	fe 01       	movw	r30, r28
    1e12:	ed 59       	subi	r30, 0x9D	; 157
    1e14:	ff 4f       	sbci	r31, 0xFF	; 255
    1e16:	80 81       	ld	r24, Z
    1e18:	88 2f       	mov	r24, r24
    1e1a:	90 e0       	ldi	r25, 0x00	; 0
    1e1c:	82 70       	andi	r24, 0x02	; 2
    1e1e:	90 70       	andi	r25, 0x00	; 0
    1e20:	95 95       	asr	r25
    1e22:	87 95       	ror	r24
    1e24:	98 2f       	mov	r25, r24
    1e26:	80 e0       	ldi	r24, 0x00	; 0
    1e28:	64 e0       	ldi	r22, 0x04	; 4
    1e2a:	49 2f       	mov	r20, r25
    1e2c:	0e 94 b3 08 	call	0x1166	; 0x1166 <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB6_PIN_ID,GET_BIT(command,2));
    1e30:	fe 01       	movw	r30, r28
    1e32:	ed 59       	subi	r30, 0x9D	; 157
    1e34:	ff 4f       	sbci	r31, 0xFF	; 255
    1e36:	80 81       	ld	r24, Z
    1e38:	88 2f       	mov	r24, r24
    1e3a:	90 e0       	ldi	r25, 0x00	; 0
    1e3c:	84 70       	andi	r24, 0x04	; 4
    1e3e:	90 70       	andi	r25, 0x00	; 0
    1e40:	95 95       	asr	r25
    1e42:	87 95       	ror	r24
    1e44:	95 95       	asr	r25
    1e46:	87 95       	ror	r24
    1e48:	98 2f       	mov	r25, r24
    1e4a:	80 e0       	ldi	r24, 0x00	; 0
    1e4c:	65 e0       	ldi	r22, 0x05	; 5
    1e4e:	49 2f       	mov	r20, r25
    1e50:	0e 94 b3 08 	call	0x1166	; 0x1166 <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB7_PIN_ID,GET_BIT(command,3));
    1e54:	fe 01       	movw	r30, r28
    1e56:	ed 59       	subi	r30, 0x9D	; 157
    1e58:	ff 4f       	sbci	r31, 0xFF	; 255
    1e5a:	80 81       	ld	r24, Z
    1e5c:	88 2f       	mov	r24, r24
    1e5e:	90 e0       	ldi	r25, 0x00	; 0
    1e60:	88 70       	andi	r24, 0x08	; 8
    1e62:	90 70       	andi	r25, 0x00	; 0
    1e64:	95 95       	asr	r25
    1e66:	87 95       	ror	r24
    1e68:	95 95       	asr	r25
    1e6a:	87 95       	ror	r24
    1e6c:	95 95       	asr	r25
    1e6e:	87 95       	ror	r24
    1e70:	98 2f       	mov	r25, r24
    1e72:	80 e0       	ldi	r24, 0x00	; 0
    1e74:	66 e0       	ldi	r22, 0x06	; 6
    1e76:	49 2f       	mov	r20, r25
    1e78:	0e 94 b3 08 	call	0x1166	; 0x1166 <GPIO_writePin>
    1e7c:	80 e0       	ldi	r24, 0x00	; 0
    1e7e:	90 e0       	ldi	r25, 0x00	; 0
    1e80:	a0 e8       	ldi	r26, 0x80	; 128
    1e82:	bf e3       	ldi	r27, 0x3F	; 63
    1e84:	89 8f       	std	Y+25, r24	; 0x19
    1e86:	9a 8f       	std	Y+26, r25	; 0x1a
    1e88:	ab 8f       	std	Y+27, r26	; 0x1b
    1e8a:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1e8c:	69 8d       	ldd	r22, Y+25	; 0x19
    1e8e:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1e90:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1e92:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1e94:	20 e0       	ldi	r18, 0x00	; 0
    1e96:	30 e0       	ldi	r19, 0x00	; 0
    1e98:	4a ef       	ldi	r20, 0xFA	; 250
    1e9a:	54 e4       	ldi	r21, 0x44	; 68
    1e9c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1ea0:	dc 01       	movw	r26, r24
    1ea2:	cb 01       	movw	r24, r22
    1ea4:	8d 8b       	std	Y+21, r24	; 0x15
    1ea6:	9e 8b       	std	Y+22, r25	; 0x16
    1ea8:	af 8b       	std	Y+23, r26	; 0x17
    1eaa:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    1eac:	6d 89       	ldd	r22, Y+21	; 0x15
    1eae:	7e 89       	ldd	r23, Y+22	; 0x16
    1eb0:	8f 89       	ldd	r24, Y+23	; 0x17
    1eb2:	98 8d       	ldd	r25, Y+24	; 0x18
    1eb4:	20 e0       	ldi	r18, 0x00	; 0
    1eb6:	30 e0       	ldi	r19, 0x00	; 0
    1eb8:	40 e8       	ldi	r20, 0x80	; 128
    1eba:	5f e3       	ldi	r21, 0x3F	; 63
    1ebc:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1ec0:	88 23       	and	r24, r24
    1ec2:	2c f4       	brge	.+10     	; 0x1ece <LCD_sendCommand+0x75e>
		__ticks = 1;
    1ec4:	81 e0       	ldi	r24, 0x01	; 1
    1ec6:	90 e0       	ldi	r25, 0x00	; 0
    1ec8:	9c 8b       	std	Y+20, r25	; 0x14
    1eca:	8b 8b       	std	Y+19, r24	; 0x13
    1ecc:	3f c0       	rjmp	.+126    	; 0x1f4c <LCD_sendCommand+0x7dc>
	else if (__tmp > 65535)
    1ece:	6d 89       	ldd	r22, Y+21	; 0x15
    1ed0:	7e 89       	ldd	r23, Y+22	; 0x16
    1ed2:	8f 89       	ldd	r24, Y+23	; 0x17
    1ed4:	98 8d       	ldd	r25, Y+24	; 0x18
    1ed6:	20 e0       	ldi	r18, 0x00	; 0
    1ed8:	3f ef       	ldi	r19, 0xFF	; 255
    1eda:	4f e7       	ldi	r20, 0x7F	; 127
    1edc:	57 e4       	ldi	r21, 0x47	; 71
    1ede:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1ee2:	18 16       	cp	r1, r24
    1ee4:	4c f5       	brge	.+82     	; 0x1f38 <LCD_sendCommand+0x7c8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1ee6:	69 8d       	ldd	r22, Y+25	; 0x19
    1ee8:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1eea:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1eec:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1eee:	20 e0       	ldi	r18, 0x00	; 0
    1ef0:	30 e0       	ldi	r19, 0x00	; 0
    1ef2:	40 e2       	ldi	r20, 0x20	; 32
    1ef4:	51 e4       	ldi	r21, 0x41	; 65
    1ef6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1efa:	dc 01       	movw	r26, r24
    1efc:	cb 01       	movw	r24, r22
    1efe:	bc 01       	movw	r22, r24
    1f00:	cd 01       	movw	r24, r26
    1f02:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1f06:	dc 01       	movw	r26, r24
    1f08:	cb 01       	movw	r24, r22
    1f0a:	9c 8b       	std	Y+20, r25	; 0x14
    1f0c:	8b 8b       	std	Y+19, r24	; 0x13
    1f0e:	0f c0       	rjmp	.+30     	; 0x1f2e <LCD_sendCommand+0x7be>
    1f10:	88 ec       	ldi	r24, 0xC8	; 200
    1f12:	90 e0       	ldi	r25, 0x00	; 0
    1f14:	9a 8b       	std	Y+18, r25	; 0x12
    1f16:	89 8b       	std	Y+17, r24	; 0x11
    1f18:	89 89       	ldd	r24, Y+17	; 0x11
    1f1a:	9a 89       	ldd	r25, Y+18	; 0x12
    1f1c:	01 97       	sbiw	r24, 0x01	; 1
    1f1e:	f1 f7       	brne	.-4      	; 0x1f1c <LCD_sendCommand+0x7ac>
    1f20:	9a 8b       	std	Y+18, r25	; 0x12
    1f22:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1f24:	8b 89       	ldd	r24, Y+19	; 0x13
    1f26:	9c 89       	ldd	r25, Y+20	; 0x14
    1f28:	01 97       	sbiw	r24, 0x01	; 1
    1f2a:	9c 8b       	std	Y+20, r25	; 0x14
    1f2c:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1f2e:	8b 89       	ldd	r24, Y+19	; 0x13
    1f30:	9c 89       	ldd	r25, Y+20	; 0x14
    1f32:	00 97       	sbiw	r24, 0x00	; 0
    1f34:	69 f7       	brne	.-38     	; 0x1f10 <LCD_sendCommand+0x7a0>
    1f36:	14 c0       	rjmp	.+40     	; 0x1f60 <LCD_sendCommand+0x7f0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1f38:	6d 89       	ldd	r22, Y+21	; 0x15
    1f3a:	7e 89       	ldd	r23, Y+22	; 0x16
    1f3c:	8f 89       	ldd	r24, Y+23	; 0x17
    1f3e:	98 8d       	ldd	r25, Y+24	; 0x18
    1f40:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1f44:	dc 01       	movw	r26, r24
    1f46:	cb 01       	movw	r24, r22
    1f48:	9c 8b       	std	Y+20, r25	; 0x14
    1f4a:	8b 8b       	std	Y+19, r24	; 0x13
    1f4c:	8b 89       	ldd	r24, Y+19	; 0x13
    1f4e:	9c 89       	ldd	r25, Y+20	; 0x14
    1f50:	98 8b       	std	Y+16, r25	; 0x10
    1f52:	8f 87       	std	Y+15, r24	; 0x0f
    1f54:	8f 85       	ldd	r24, Y+15	; 0x0f
    1f56:	98 89       	ldd	r25, Y+16	; 0x10
    1f58:	01 97       	sbiw	r24, 0x01	; 1
    1f5a:	f1 f7       	brne	.-4      	; 0x1f58 <LCD_sendCommand+0x7e8>
    1f5c:	98 8b       	std	Y+16, r25	; 0x10
    1f5e:	8f 87       	std	Y+15, r24	; 0x0f

	_delay_ms(1); /* delay for processing Tdsw = 100ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_LOW); /* Disable LCD E=0 */
    1f60:	80 e0       	ldi	r24, 0x00	; 0
    1f62:	62 e0       	ldi	r22, 0x02	; 2
    1f64:	40 e0       	ldi	r20, 0x00	; 0
    1f66:	0e 94 b3 08 	call	0x1166	; 0x1166 <GPIO_writePin>
    1f6a:	80 e0       	ldi	r24, 0x00	; 0
    1f6c:	90 e0       	ldi	r25, 0x00	; 0
    1f6e:	a0 e8       	ldi	r26, 0x80	; 128
    1f70:	bf e3       	ldi	r27, 0x3F	; 63
    1f72:	8b 87       	std	Y+11, r24	; 0x0b
    1f74:	9c 87       	std	Y+12, r25	; 0x0c
    1f76:	ad 87       	std	Y+13, r26	; 0x0d
    1f78:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1f7a:	6b 85       	ldd	r22, Y+11	; 0x0b
    1f7c:	7c 85       	ldd	r23, Y+12	; 0x0c
    1f7e:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f80:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f82:	20 e0       	ldi	r18, 0x00	; 0
    1f84:	30 e0       	ldi	r19, 0x00	; 0
    1f86:	4a ef       	ldi	r20, 0xFA	; 250
    1f88:	54 e4       	ldi	r21, 0x44	; 68
    1f8a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1f8e:	dc 01       	movw	r26, r24
    1f90:	cb 01       	movw	r24, r22
    1f92:	8f 83       	std	Y+7, r24	; 0x07
    1f94:	98 87       	std	Y+8, r25	; 0x08
    1f96:	a9 87       	std	Y+9, r26	; 0x09
    1f98:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1f9a:	6f 81       	ldd	r22, Y+7	; 0x07
    1f9c:	78 85       	ldd	r23, Y+8	; 0x08
    1f9e:	89 85       	ldd	r24, Y+9	; 0x09
    1fa0:	9a 85       	ldd	r25, Y+10	; 0x0a
    1fa2:	20 e0       	ldi	r18, 0x00	; 0
    1fa4:	30 e0       	ldi	r19, 0x00	; 0
    1fa6:	40 e8       	ldi	r20, 0x80	; 128
    1fa8:	5f e3       	ldi	r21, 0x3F	; 63
    1faa:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1fae:	88 23       	and	r24, r24
    1fb0:	2c f4       	brge	.+10     	; 0x1fbc <LCD_sendCommand+0x84c>
		__ticks = 1;
    1fb2:	81 e0       	ldi	r24, 0x01	; 1
    1fb4:	90 e0       	ldi	r25, 0x00	; 0
    1fb6:	9e 83       	std	Y+6, r25	; 0x06
    1fb8:	8d 83       	std	Y+5, r24	; 0x05
    1fba:	3f c0       	rjmp	.+126    	; 0x203a <LCD_sendCommand+0x8ca>
	else if (__tmp > 65535)
    1fbc:	6f 81       	ldd	r22, Y+7	; 0x07
    1fbe:	78 85       	ldd	r23, Y+8	; 0x08
    1fc0:	89 85       	ldd	r24, Y+9	; 0x09
    1fc2:	9a 85       	ldd	r25, Y+10	; 0x0a
    1fc4:	20 e0       	ldi	r18, 0x00	; 0
    1fc6:	3f ef       	ldi	r19, 0xFF	; 255
    1fc8:	4f e7       	ldi	r20, 0x7F	; 127
    1fca:	57 e4       	ldi	r21, 0x47	; 71
    1fcc:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1fd0:	18 16       	cp	r1, r24
    1fd2:	4c f5       	brge	.+82     	; 0x2026 <LCD_sendCommand+0x8b6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1fd4:	6b 85       	ldd	r22, Y+11	; 0x0b
    1fd6:	7c 85       	ldd	r23, Y+12	; 0x0c
    1fd8:	8d 85       	ldd	r24, Y+13	; 0x0d
    1fda:	9e 85       	ldd	r25, Y+14	; 0x0e
    1fdc:	20 e0       	ldi	r18, 0x00	; 0
    1fde:	30 e0       	ldi	r19, 0x00	; 0
    1fe0:	40 e2       	ldi	r20, 0x20	; 32
    1fe2:	51 e4       	ldi	r21, 0x41	; 65
    1fe4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1fe8:	dc 01       	movw	r26, r24
    1fea:	cb 01       	movw	r24, r22
    1fec:	bc 01       	movw	r22, r24
    1fee:	cd 01       	movw	r24, r26
    1ff0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1ff4:	dc 01       	movw	r26, r24
    1ff6:	cb 01       	movw	r24, r22
    1ff8:	9e 83       	std	Y+6, r25	; 0x06
    1ffa:	8d 83       	std	Y+5, r24	; 0x05
    1ffc:	0f c0       	rjmp	.+30     	; 0x201c <LCD_sendCommand+0x8ac>
    1ffe:	88 ec       	ldi	r24, 0xC8	; 200
    2000:	90 e0       	ldi	r25, 0x00	; 0
    2002:	9c 83       	std	Y+4, r25	; 0x04
    2004:	8b 83       	std	Y+3, r24	; 0x03
    2006:	8b 81       	ldd	r24, Y+3	; 0x03
    2008:	9c 81       	ldd	r25, Y+4	; 0x04
    200a:	01 97       	sbiw	r24, 0x01	; 1
    200c:	f1 f7       	brne	.-4      	; 0x200a <LCD_sendCommand+0x89a>
    200e:	9c 83       	std	Y+4, r25	; 0x04
    2010:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2012:	8d 81       	ldd	r24, Y+5	; 0x05
    2014:	9e 81       	ldd	r25, Y+6	; 0x06
    2016:	01 97       	sbiw	r24, 0x01	; 1
    2018:	9e 83       	std	Y+6, r25	; 0x06
    201a:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    201c:	8d 81       	ldd	r24, Y+5	; 0x05
    201e:	9e 81       	ldd	r25, Y+6	; 0x06
    2020:	00 97       	sbiw	r24, 0x00	; 0
    2022:	69 f7       	brne	.-38     	; 0x1ffe <LCD_sendCommand+0x88e>
    2024:	14 c0       	rjmp	.+40     	; 0x204e <LCD_sendCommand+0x8de>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2026:	6f 81       	ldd	r22, Y+7	; 0x07
    2028:	78 85       	ldd	r23, Y+8	; 0x08
    202a:	89 85       	ldd	r24, Y+9	; 0x09
    202c:	9a 85       	ldd	r25, Y+10	; 0x0a
    202e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2032:	dc 01       	movw	r26, r24
    2034:	cb 01       	movw	r24, r22
    2036:	9e 83       	std	Y+6, r25	; 0x06
    2038:	8d 83       	std	Y+5, r24	; 0x05
    203a:	8d 81       	ldd	r24, Y+5	; 0x05
    203c:	9e 81       	ldd	r25, Y+6	; 0x06
    203e:	9a 83       	std	Y+2, r25	; 0x02
    2040:	89 83       	std	Y+1, r24	; 0x01
    2042:	89 81       	ldd	r24, Y+1	; 0x01
    2044:	9a 81       	ldd	r25, Y+2	; 0x02
    2046:	01 97       	sbiw	r24, 0x01	; 1
    2048:	f1 f7       	brne	.-4      	; 0x2046 <LCD_sendCommand+0x8d6>
    204a:	9a 83       	std	Y+2, r25	; 0x02
    204c:	89 83       	std	Y+1, r24	; 0x01
	GPIO_writePort(LCD_DATA_PORT_ID,command); /* out the required command to the data bus D0 --> D7 */
	_delay_ms(1); /* delay for processing Tdsw = 100ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_LOW); /* Disable LCD E=0 */
	_delay_ms(1); /* delay for processing Th = 13ns */
#endif
}
    204e:	cd 59       	subi	r28, 0x9D	; 157
    2050:	df 4f       	sbci	r29, 0xFF	; 255
    2052:	0f b6       	in	r0, 0x3f	; 63
    2054:	f8 94       	cli
    2056:	de bf       	out	0x3e, r29	; 62
    2058:	0f be       	out	0x3f, r0	; 63
    205a:	cd bf       	out	0x3d, r28	; 61
    205c:	cf 91       	pop	r28
    205e:	df 91       	pop	r29
    2060:	1f 91       	pop	r17
    2062:	0f 91       	pop	r16
    2064:	08 95       	ret

00002066 <LCD_displayCharacter>:
/*
 * Description :
 * Display the required character on the screen
 */
void LCD_displayCharacter(uint8 data)
{
    2066:	0f 93       	push	r16
    2068:	1f 93       	push	r17
    206a:	df 93       	push	r29
    206c:	cf 93       	push	r28
    206e:	cd b7       	in	r28, 0x3d	; 61
    2070:	de b7       	in	r29, 0x3e	; 62
    2072:	c3 56       	subi	r28, 0x63	; 99
    2074:	d0 40       	sbci	r29, 0x00	; 0
    2076:	0f b6       	in	r0, 0x3f	; 63
    2078:	f8 94       	cli
    207a:	de bf       	out	0x3e, r29	; 62
    207c:	0f be       	out	0x3f, r0	; 63
    207e:	cd bf       	out	0x3d, r28	; 61
    2080:	fe 01       	movw	r30, r28
    2082:	ed 59       	subi	r30, 0x9D	; 157
    2084:	ff 4f       	sbci	r31, 0xFF	; 255
    2086:	80 83       	st	Z, r24
	GPIO_writePin(LCD_RS_PORT_ID,LCD_RS_PIN_ID,LOGIC_HIGH); /* Data Mode RS=1 */
    2088:	80 e0       	ldi	r24, 0x00	; 0
    208a:	61 e0       	ldi	r22, 0x01	; 1
    208c:	41 e0       	ldi	r20, 0x01	; 1
    208e:	0e 94 b3 08 	call	0x1166	; 0x1166 <GPIO_writePin>
    2092:	fe 01       	movw	r30, r28
    2094:	e1 5a       	subi	r30, 0xA1	; 161
    2096:	ff 4f       	sbci	r31, 0xFF	; 255
    2098:	80 e0       	ldi	r24, 0x00	; 0
    209a:	90 e0       	ldi	r25, 0x00	; 0
    209c:	a0 e8       	ldi	r26, 0x80	; 128
    209e:	bf e3       	ldi	r27, 0x3F	; 63
    20a0:	80 83       	st	Z, r24
    20a2:	91 83       	std	Z+1, r25	; 0x01
    20a4:	a2 83       	std	Z+2, r26	; 0x02
    20a6:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    20a8:	8e 01       	movw	r16, r28
    20aa:	05 5a       	subi	r16, 0xA5	; 165
    20ac:	1f 4f       	sbci	r17, 0xFF	; 255
    20ae:	fe 01       	movw	r30, r28
    20b0:	e1 5a       	subi	r30, 0xA1	; 161
    20b2:	ff 4f       	sbci	r31, 0xFF	; 255
    20b4:	60 81       	ld	r22, Z
    20b6:	71 81       	ldd	r23, Z+1	; 0x01
    20b8:	82 81       	ldd	r24, Z+2	; 0x02
    20ba:	93 81       	ldd	r25, Z+3	; 0x03
    20bc:	20 e0       	ldi	r18, 0x00	; 0
    20be:	30 e0       	ldi	r19, 0x00	; 0
    20c0:	4a ef       	ldi	r20, 0xFA	; 250
    20c2:	54 e4       	ldi	r21, 0x44	; 68
    20c4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    20c8:	dc 01       	movw	r26, r24
    20ca:	cb 01       	movw	r24, r22
    20cc:	f8 01       	movw	r30, r16
    20ce:	80 83       	st	Z, r24
    20d0:	91 83       	std	Z+1, r25	; 0x01
    20d2:	a2 83       	std	Z+2, r26	; 0x02
    20d4:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    20d6:	fe 01       	movw	r30, r28
    20d8:	e5 5a       	subi	r30, 0xA5	; 165
    20da:	ff 4f       	sbci	r31, 0xFF	; 255
    20dc:	60 81       	ld	r22, Z
    20de:	71 81       	ldd	r23, Z+1	; 0x01
    20e0:	82 81       	ldd	r24, Z+2	; 0x02
    20e2:	93 81       	ldd	r25, Z+3	; 0x03
    20e4:	20 e0       	ldi	r18, 0x00	; 0
    20e6:	30 e0       	ldi	r19, 0x00	; 0
    20e8:	40 e8       	ldi	r20, 0x80	; 128
    20ea:	5f e3       	ldi	r21, 0x3F	; 63
    20ec:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    20f0:	88 23       	and	r24, r24
    20f2:	44 f4       	brge	.+16     	; 0x2104 <LCD_displayCharacter+0x9e>
		__ticks = 1;
    20f4:	fe 01       	movw	r30, r28
    20f6:	e7 5a       	subi	r30, 0xA7	; 167
    20f8:	ff 4f       	sbci	r31, 0xFF	; 255
    20fa:	81 e0       	ldi	r24, 0x01	; 1
    20fc:	90 e0       	ldi	r25, 0x00	; 0
    20fe:	91 83       	std	Z+1, r25	; 0x01
    2100:	80 83       	st	Z, r24
    2102:	64 c0       	rjmp	.+200    	; 0x21cc <LCD_displayCharacter+0x166>
	else if (__tmp > 65535)
    2104:	fe 01       	movw	r30, r28
    2106:	e5 5a       	subi	r30, 0xA5	; 165
    2108:	ff 4f       	sbci	r31, 0xFF	; 255
    210a:	60 81       	ld	r22, Z
    210c:	71 81       	ldd	r23, Z+1	; 0x01
    210e:	82 81       	ldd	r24, Z+2	; 0x02
    2110:	93 81       	ldd	r25, Z+3	; 0x03
    2112:	20 e0       	ldi	r18, 0x00	; 0
    2114:	3f ef       	ldi	r19, 0xFF	; 255
    2116:	4f e7       	ldi	r20, 0x7F	; 127
    2118:	57 e4       	ldi	r21, 0x47	; 71
    211a:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    211e:	18 16       	cp	r1, r24
    2120:	0c f0       	brlt	.+2      	; 0x2124 <LCD_displayCharacter+0xbe>
    2122:	43 c0       	rjmp	.+134    	; 0x21aa <LCD_displayCharacter+0x144>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2124:	fe 01       	movw	r30, r28
    2126:	e1 5a       	subi	r30, 0xA1	; 161
    2128:	ff 4f       	sbci	r31, 0xFF	; 255
    212a:	60 81       	ld	r22, Z
    212c:	71 81       	ldd	r23, Z+1	; 0x01
    212e:	82 81       	ldd	r24, Z+2	; 0x02
    2130:	93 81       	ldd	r25, Z+3	; 0x03
    2132:	20 e0       	ldi	r18, 0x00	; 0
    2134:	30 e0       	ldi	r19, 0x00	; 0
    2136:	40 e2       	ldi	r20, 0x20	; 32
    2138:	51 e4       	ldi	r21, 0x41	; 65
    213a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    213e:	dc 01       	movw	r26, r24
    2140:	cb 01       	movw	r24, r22
    2142:	8e 01       	movw	r16, r28
    2144:	07 5a       	subi	r16, 0xA7	; 167
    2146:	1f 4f       	sbci	r17, 0xFF	; 255
    2148:	bc 01       	movw	r22, r24
    214a:	cd 01       	movw	r24, r26
    214c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2150:	dc 01       	movw	r26, r24
    2152:	cb 01       	movw	r24, r22
    2154:	f8 01       	movw	r30, r16
    2156:	91 83       	std	Z+1, r25	; 0x01
    2158:	80 83       	st	Z, r24
    215a:	1f c0       	rjmp	.+62     	; 0x219a <LCD_displayCharacter+0x134>
    215c:	fe 01       	movw	r30, r28
    215e:	e9 5a       	subi	r30, 0xA9	; 169
    2160:	ff 4f       	sbci	r31, 0xFF	; 255
    2162:	88 ec       	ldi	r24, 0xC8	; 200
    2164:	90 e0       	ldi	r25, 0x00	; 0
    2166:	91 83       	std	Z+1, r25	; 0x01
    2168:	80 83       	st	Z, r24
    216a:	fe 01       	movw	r30, r28
    216c:	e9 5a       	subi	r30, 0xA9	; 169
    216e:	ff 4f       	sbci	r31, 0xFF	; 255
    2170:	80 81       	ld	r24, Z
    2172:	91 81       	ldd	r25, Z+1	; 0x01
    2174:	01 97       	sbiw	r24, 0x01	; 1
    2176:	f1 f7       	brne	.-4      	; 0x2174 <LCD_displayCharacter+0x10e>
    2178:	fe 01       	movw	r30, r28
    217a:	e9 5a       	subi	r30, 0xA9	; 169
    217c:	ff 4f       	sbci	r31, 0xFF	; 255
    217e:	91 83       	std	Z+1, r25	; 0x01
    2180:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2182:	de 01       	movw	r26, r28
    2184:	a7 5a       	subi	r26, 0xA7	; 167
    2186:	bf 4f       	sbci	r27, 0xFF	; 255
    2188:	fe 01       	movw	r30, r28
    218a:	e7 5a       	subi	r30, 0xA7	; 167
    218c:	ff 4f       	sbci	r31, 0xFF	; 255
    218e:	80 81       	ld	r24, Z
    2190:	91 81       	ldd	r25, Z+1	; 0x01
    2192:	01 97       	sbiw	r24, 0x01	; 1
    2194:	11 96       	adiw	r26, 0x01	; 1
    2196:	9c 93       	st	X, r25
    2198:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    219a:	fe 01       	movw	r30, r28
    219c:	e7 5a       	subi	r30, 0xA7	; 167
    219e:	ff 4f       	sbci	r31, 0xFF	; 255
    21a0:	80 81       	ld	r24, Z
    21a2:	91 81       	ldd	r25, Z+1	; 0x01
    21a4:	00 97       	sbiw	r24, 0x00	; 0
    21a6:	d1 f6       	brne	.-76     	; 0x215c <LCD_displayCharacter+0xf6>
    21a8:	27 c0       	rjmp	.+78     	; 0x21f8 <LCD_displayCharacter+0x192>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    21aa:	8e 01       	movw	r16, r28
    21ac:	07 5a       	subi	r16, 0xA7	; 167
    21ae:	1f 4f       	sbci	r17, 0xFF	; 255
    21b0:	fe 01       	movw	r30, r28
    21b2:	e5 5a       	subi	r30, 0xA5	; 165
    21b4:	ff 4f       	sbci	r31, 0xFF	; 255
    21b6:	60 81       	ld	r22, Z
    21b8:	71 81       	ldd	r23, Z+1	; 0x01
    21ba:	82 81       	ldd	r24, Z+2	; 0x02
    21bc:	93 81       	ldd	r25, Z+3	; 0x03
    21be:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    21c2:	dc 01       	movw	r26, r24
    21c4:	cb 01       	movw	r24, r22
    21c6:	f8 01       	movw	r30, r16
    21c8:	91 83       	std	Z+1, r25	; 0x01
    21ca:	80 83       	st	Z, r24
    21cc:	de 01       	movw	r26, r28
    21ce:	ab 5a       	subi	r26, 0xAB	; 171
    21d0:	bf 4f       	sbci	r27, 0xFF	; 255
    21d2:	fe 01       	movw	r30, r28
    21d4:	e7 5a       	subi	r30, 0xA7	; 167
    21d6:	ff 4f       	sbci	r31, 0xFF	; 255
    21d8:	80 81       	ld	r24, Z
    21da:	91 81       	ldd	r25, Z+1	; 0x01
    21dc:	8d 93       	st	X+, r24
    21de:	9c 93       	st	X, r25
    21e0:	fe 01       	movw	r30, r28
    21e2:	eb 5a       	subi	r30, 0xAB	; 171
    21e4:	ff 4f       	sbci	r31, 0xFF	; 255
    21e6:	80 81       	ld	r24, Z
    21e8:	91 81       	ldd	r25, Z+1	; 0x01
    21ea:	01 97       	sbiw	r24, 0x01	; 1
    21ec:	f1 f7       	brne	.-4      	; 0x21ea <LCD_displayCharacter+0x184>
    21ee:	fe 01       	movw	r30, r28
    21f0:	eb 5a       	subi	r30, 0xAB	; 171
    21f2:	ff 4f       	sbci	r31, 0xFF	; 255
    21f4:	91 83       	std	Z+1, r25	; 0x01
    21f6:	80 83       	st	Z, r24
	_delay_ms(1); /* delay for processing Tas = 50ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_HIGH); /* Enable LCD E=1 */
    21f8:	80 e0       	ldi	r24, 0x00	; 0
    21fa:	62 e0       	ldi	r22, 0x02	; 2
    21fc:	41 e0       	ldi	r20, 0x01	; 1
    21fe:	0e 94 b3 08 	call	0x1166	; 0x1166 <GPIO_writePin>
    2202:	fe 01       	movw	r30, r28
    2204:	ef 5a       	subi	r30, 0xAF	; 175
    2206:	ff 4f       	sbci	r31, 0xFF	; 255
    2208:	80 e0       	ldi	r24, 0x00	; 0
    220a:	90 e0       	ldi	r25, 0x00	; 0
    220c:	a0 e8       	ldi	r26, 0x80	; 128
    220e:	bf e3       	ldi	r27, 0x3F	; 63
    2210:	80 83       	st	Z, r24
    2212:	91 83       	std	Z+1, r25	; 0x01
    2214:	a2 83       	std	Z+2, r26	; 0x02
    2216:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2218:	8e 01       	movw	r16, r28
    221a:	03 5b       	subi	r16, 0xB3	; 179
    221c:	1f 4f       	sbci	r17, 0xFF	; 255
    221e:	fe 01       	movw	r30, r28
    2220:	ef 5a       	subi	r30, 0xAF	; 175
    2222:	ff 4f       	sbci	r31, 0xFF	; 255
    2224:	60 81       	ld	r22, Z
    2226:	71 81       	ldd	r23, Z+1	; 0x01
    2228:	82 81       	ldd	r24, Z+2	; 0x02
    222a:	93 81       	ldd	r25, Z+3	; 0x03
    222c:	20 e0       	ldi	r18, 0x00	; 0
    222e:	30 e0       	ldi	r19, 0x00	; 0
    2230:	4a ef       	ldi	r20, 0xFA	; 250
    2232:	54 e4       	ldi	r21, 0x44	; 68
    2234:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2238:	dc 01       	movw	r26, r24
    223a:	cb 01       	movw	r24, r22
    223c:	f8 01       	movw	r30, r16
    223e:	80 83       	st	Z, r24
    2240:	91 83       	std	Z+1, r25	; 0x01
    2242:	a2 83       	std	Z+2, r26	; 0x02
    2244:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    2246:	fe 01       	movw	r30, r28
    2248:	e3 5b       	subi	r30, 0xB3	; 179
    224a:	ff 4f       	sbci	r31, 0xFF	; 255
    224c:	60 81       	ld	r22, Z
    224e:	71 81       	ldd	r23, Z+1	; 0x01
    2250:	82 81       	ldd	r24, Z+2	; 0x02
    2252:	93 81       	ldd	r25, Z+3	; 0x03
    2254:	20 e0       	ldi	r18, 0x00	; 0
    2256:	30 e0       	ldi	r19, 0x00	; 0
    2258:	40 e8       	ldi	r20, 0x80	; 128
    225a:	5f e3       	ldi	r21, 0x3F	; 63
    225c:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    2260:	88 23       	and	r24, r24
    2262:	44 f4       	brge	.+16     	; 0x2274 <LCD_displayCharacter+0x20e>
		__ticks = 1;
    2264:	fe 01       	movw	r30, r28
    2266:	e5 5b       	subi	r30, 0xB5	; 181
    2268:	ff 4f       	sbci	r31, 0xFF	; 255
    226a:	81 e0       	ldi	r24, 0x01	; 1
    226c:	90 e0       	ldi	r25, 0x00	; 0
    226e:	91 83       	std	Z+1, r25	; 0x01
    2270:	80 83       	st	Z, r24
    2272:	64 c0       	rjmp	.+200    	; 0x233c <LCD_displayCharacter+0x2d6>
	else if (__tmp > 65535)
    2274:	fe 01       	movw	r30, r28
    2276:	e3 5b       	subi	r30, 0xB3	; 179
    2278:	ff 4f       	sbci	r31, 0xFF	; 255
    227a:	60 81       	ld	r22, Z
    227c:	71 81       	ldd	r23, Z+1	; 0x01
    227e:	82 81       	ldd	r24, Z+2	; 0x02
    2280:	93 81       	ldd	r25, Z+3	; 0x03
    2282:	20 e0       	ldi	r18, 0x00	; 0
    2284:	3f ef       	ldi	r19, 0xFF	; 255
    2286:	4f e7       	ldi	r20, 0x7F	; 127
    2288:	57 e4       	ldi	r21, 0x47	; 71
    228a:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    228e:	18 16       	cp	r1, r24
    2290:	0c f0       	brlt	.+2      	; 0x2294 <LCD_displayCharacter+0x22e>
    2292:	43 c0       	rjmp	.+134    	; 0x231a <LCD_displayCharacter+0x2b4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2294:	fe 01       	movw	r30, r28
    2296:	ef 5a       	subi	r30, 0xAF	; 175
    2298:	ff 4f       	sbci	r31, 0xFF	; 255
    229a:	60 81       	ld	r22, Z
    229c:	71 81       	ldd	r23, Z+1	; 0x01
    229e:	82 81       	ldd	r24, Z+2	; 0x02
    22a0:	93 81       	ldd	r25, Z+3	; 0x03
    22a2:	20 e0       	ldi	r18, 0x00	; 0
    22a4:	30 e0       	ldi	r19, 0x00	; 0
    22a6:	40 e2       	ldi	r20, 0x20	; 32
    22a8:	51 e4       	ldi	r21, 0x41	; 65
    22aa:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    22ae:	dc 01       	movw	r26, r24
    22b0:	cb 01       	movw	r24, r22
    22b2:	8e 01       	movw	r16, r28
    22b4:	05 5b       	subi	r16, 0xB5	; 181
    22b6:	1f 4f       	sbci	r17, 0xFF	; 255
    22b8:	bc 01       	movw	r22, r24
    22ba:	cd 01       	movw	r24, r26
    22bc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    22c0:	dc 01       	movw	r26, r24
    22c2:	cb 01       	movw	r24, r22
    22c4:	f8 01       	movw	r30, r16
    22c6:	91 83       	std	Z+1, r25	; 0x01
    22c8:	80 83       	st	Z, r24
    22ca:	1f c0       	rjmp	.+62     	; 0x230a <LCD_displayCharacter+0x2a4>
    22cc:	fe 01       	movw	r30, r28
    22ce:	e7 5b       	subi	r30, 0xB7	; 183
    22d0:	ff 4f       	sbci	r31, 0xFF	; 255
    22d2:	88 ec       	ldi	r24, 0xC8	; 200
    22d4:	90 e0       	ldi	r25, 0x00	; 0
    22d6:	91 83       	std	Z+1, r25	; 0x01
    22d8:	80 83       	st	Z, r24
    22da:	fe 01       	movw	r30, r28
    22dc:	e7 5b       	subi	r30, 0xB7	; 183
    22de:	ff 4f       	sbci	r31, 0xFF	; 255
    22e0:	80 81       	ld	r24, Z
    22e2:	91 81       	ldd	r25, Z+1	; 0x01
    22e4:	01 97       	sbiw	r24, 0x01	; 1
    22e6:	f1 f7       	brne	.-4      	; 0x22e4 <LCD_displayCharacter+0x27e>
    22e8:	fe 01       	movw	r30, r28
    22ea:	e7 5b       	subi	r30, 0xB7	; 183
    22ec:	ff 4f       	sbci	r31, 0xFF	; 255
    22ee:	91 83       	std	Z+1, r25	; 0x01
    22f0:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    22f2:	de 01       	movw	r26, r28
    22f4:	a5 5b       	subi	r26, 0xB5	; 181
    22f6:	bf 4f       	sbci	r27, 0xFF	; 255
    22f8:	fe 01       	movw	r30, r28
    22fa:	e5 5b       	subi	r30, 0xB5	; 181
    22fc:	ff 4f       	sbci	r31, 0xFF	; 255
    22fe:	80 81       	ld	r24, Z
    2300:	91 81       	ldd	r25, Z+1	; 0x01
    2302:	01 97       	sbiw	r24, 0x01	; 1
    2304:	11 96       	adiw	r26, 0x01	; 1
    2306:	9c 93       	st	X, r25
    2308:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    230a:	fe 01       	movw	r30, r28
    230c:	e5 5b       	subi	r30, 0xB5	; 181
    230e:	ff 4f       	sbci	r31, 0xFF	; 255
    2310:	80 81       	ld	r24, Z
    2312:	91 81       	ldd	r25, Z+1	; 0x01
    2314:	00 97       	sbiw	r24, 0x00	; 0
    2316:	d1 f6       	brne	.-76     	; 0x22cc <LCD_displayCharacter+0x266>
    2318:	27 c0       	rjmp	.+78     	; 0x2368 <LCD_displayCharacter+0x302>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    231a:	8e 01       	movw	r16, r28
    231c:	05 5b       	subi	r16, 0xB5	; 181
    231e:	1f 4f       	sbci	r17, 0xFF	; 255
    2320:	fe 01       	movw	r30, r28
    2322:	e3 5b       	subi	r30, 0xB3	; 179
    2324:	ff 4f       	sbci	r31, 0xFF	; 255
    2326:	60 81       	ld	r22, Z
    2328:	71 81       	ldd	r23, Z+1	; 0x01
    232a:	82 81       	ldd	r24, Z+2	; 0x02
    232c:	93 81       	ldd	r25, Z+3	; 0x03
    232e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2332:	dc 01       	movw	r26, r24
    2334:	cb 01       	movw	r24, r22
    2336:	f8 01       	movw	r30, r16
    2338:	91 83       	std	Z+1, r25	; 0x01
    233a:	80 83       	st	Z, r24
    233c:	de 01       	movw	r26, r28
    233e:	a9 5b       	subi	r26, 0xB9	; 185
    2340:	bf 4f       	sbci	r27, 0xFF	; 255
    2342:	fe 01       	movw	r30, r28
    2344:	e5 5b       	subi	r30, 0xB5	; 181
    2346:	ff 4f       	sbci	r31, 0xFF	; 255
    2348:	80 81       	ld	r24, Z
    234a:	91 81       	ldd	r25, Z+1	; 0x01
    234c:	8d 93       	st	X+, r24
    234e:	9c 93       	st	X, r25
    2350:	fe 01       	movw	r30, r28
    2352:	e9 5b       	subi	r30, 0xB9	; 185
    2354:	ff 4f       	sbci	r31, 0xFF	; 255
    2356:	80 81       	ld	r24, Z
    2358:	91 81       	ldd	r25, Z+1	; 0x01
    235a:	01 97       	sbiw	r24, 0x01	; 1
    235c:	f1 f7       	brne	.-4      	; 0x235a <LCD_displayCharacter+0x2f4>
    235e:	fe 01       	movw	r30, r28
    2360:	e9 5b       	subi	r30, 0xB9	; 185
    2362:	ff 4f       	sbci	r31, 0xFF	; 255
    2364:	91 83       	std	Z+1, r25	; 0x01
    2366:	80 83       	st	Z, r24
	_delay_ms(1); /* delay for processing Tpw - Tdws = 190ns */

#if(LCD_DATA_BITS_MODE == 4)
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB4_PIN_ID,GET_BIT(data,4));
    2368:	fe 01       	movw	r30, r28
    236a:	ed 59       	subi	r30, 0x9D	; 157
    236c:	ff 4f       	sbci	r31, 0xFF	; 255
    236e:	80 81       	ld	r24, Z
    2370:	88 2f       	mov	r24, r24
    2372:	90 e0       	ldi	r25, 0x00	; 0
    2374:	80 71       	andi	r24, 0x10	; 16
    2376:	90 70       	andi	r25, 0x00	; 0
    2378:	95 95       	asr	r25
    237a:	87 95       	ror	r24
    237c:	95 95       	asr	r25
    237e:	87 95       	ror	r24
    2380:	95 95       	asr	r25
    2382:	87 95       	ror	r24
    2384:	95 95       	asr	r25
    2386:	87 95       	ror	r24
    2388:	98 2f       	mov	r25, r24
    238a:	80 e0       	ldi	r24, 0x00	; 0
    238c:	63 e0       	ldi	r22, 0x03	; 3
    238e:	49 2f       	mov	r20, r25
    2390:	0e 94 b3 08 	call	0x1166	; 0x1166 <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB5_PIN_ID,GET_BIT(data,5));
    2394:	fe 01       	movw	r30, r28
    2396:	ed 59       	subi	r30, 0x9D	; 157
    2398:	ff 4f       	sbci	r31, 0xFF	; 255
    239a:	80 81       	ld	r24, Z
    239c:	88 2f       	mov	r24, r24
    239e:	90 e0       	ldi	r25, 0x00	; 0
    23a0:	80 72       	andi	r24, 0x20	; 32
    23a2:	90 70       	andi	r25, 0x00	; 0
    23a4:	95 95       	asr	r25
    23a6:	87 95       	ror	r24
    23a8:	95 95       	asr	r25
    23aa:	87 95       	ror	r24
    23ac:	95 95       	asr	r25
    23ae:	87 95       	ror	r24
    23b0:	95 95       	asr	r25
    23b2:	87 95       	ror	r24
    23b4:	95 95       	asr	r25
    23b6:	87 95       	ror	r24
    23b8:	98 2f       	mov	r25, r24
    23ba:	80 e0       	ldi	r24, 0x00	; 0
    23bc:	64 e0       	ldi	r22, 0x04	; 4
    23be:	49 2f       	mov	r20, r25
    23c0:	0e 94 b3 08 	call	0x1166	; 0x1166 <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB6_PIN_ID,GET_BIT(data,6));
    23c4:	fe 01       	movw	r30, r28
    23c6:	ed 59       	subi	r30, 0x9D	; 157
    23c8:	ff 4f       	sbci	r31, 0xFF	; 255
    23ca:	80 81       	ld	r24, Z
    23cc:	88 2f       	mov	r24, r24
    23ce:	90 e0       	ldi	r25, 0x00	; 0
    23d0:	80 74       	andi	r24, 0x40	; 64
    23d2:	90 70       	andi	r25, 0x00	; 0
    23d4:	08 2e       	mov	r0, r24
    23d6:	89 2f       	mov	r24, r25
    23d8:	00 0c       	add	r0, r0
    23da:	88 1f       	adc	r24, r24
    23dc:	99 0b       	sbc	r25, r25
    23de:	00 0c       	add	r0, r0
    23e0:	88 1f       	adc	r24, r24
    23e2:	99 1f       	adc	r25, r25
    23e4:	98 2f       	mov	r25, r24
    23e6:	80 e0       	ldi	r24, 0x00	; 0
    23e8:	65 e0       	ldi	r22, 0x05	; 5
    23ea:	49 2f       	mov	r20, r25
    23ec:	0e 94 b3 08 	call	0x1166	; 0x1166 <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB7_PIN_ID,GET_BIT(data,7));
    23f0:	fe 01       	movw	r30, r28
    23f2:	ed 59       	subi	r30, 0x9D	; 157
    23f4:	ff 4f       	sbci	r31, 0xFF	; 255
    23f6:	80 81       	ld	r24, Z
    23f8:	98 2f       	mov	r25, r24
    23fa:	99 1f       	adc	r25, r25
    23fc:	99 27       	eor	r25, r25
    23fe:	99 1f       	adc	r25, r25
    2400:	80 e0       	ldi	r24, 0x00	; 0
    2402:	66 e0       	ldi	r22, 0x06	; 6
    2404:	49 2f       	mov	r20, r25
    2406:	0e 94 b3 08 	call	0x1166	; 0x1166 <GPIO_writePin>
    240a:	fe 01       	movw	r30, r28
    240c:	ed 5b       	subi	r30, 0xBD	; 189
    240e:	ff 4f       	sbci	r31, 0xFF	; 255
    2410:	80 e0       	ldi	r24, 0x00	; 0
    2412:	90 e0       	ldi	r25, 0x00	; 0
    2414:	a0 e8       	ldi	r26, 0x80	; 128
    2416:	bf e3       	ldi	r27, 0x3F	; 63
    2418:	80 83       	st	Z, r24
    241a:	91 83       	std	Z+1, r25	; 0x01
    241c:	a2 83       	std	Z+2, r26	; 0x02
    241e:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2420:	8e 01       	movw	r16, r28
    2422:	01 5c       	subi	r16, 0xC1	; 193
    2424:	1f 4f       	sbci	r17, 0xFF	; 255
    2426:	fe 01       	movw	r30, r28
    2428:	ed 5b       	subi	r30, 0xBD	; 189
    242a:	ff 4f       	sbci	r31, 0xFF	; 255
    242c:	60 81       	ld	r22, Z
    242e:	71 81       	ldd	r23, Z+1	; 0x01
    2430:	82 81       	ldd	r24, Z+2	; 0x02
    2432:	93 81       	ldd	r25, Z+3	; 0x03
    2434:	20 e0       	ldi	r18, 0x00	; 0
    2436:	30 e0       	ldi	r19, 0x00	; 0
    2438:	4a ef       	ldi	r20, 0xFA	; 250
    243a:	54 e4       	ldi	r21, 0x44	; 68
    243c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2440:	dc 01       	movw	r26, r24
    2442:	cb 01       	movw	r24, r22
    2444:	f8 01       	movw	r30, r16
    2446:	80 83       	st	Z, r24
    2448:	91 83       	std	Z+1, r25	; 0x01
    244a:	a2 83       	std	Z+2, r26	; 0x02
    244c:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    244e:	fe 01       	movw	r30, r28
    2450:	ff 96       	adiw	r30, 0x3f	; 63
    2452:	60 81       	ld	r22, Z
    2454:	71 81       	ldd	r23, Z+1	; 0x01
    2456:	82 81       	ldd	r24, Z+2	; 0x02
    2458:	93 81       	ldd	r25, Z+3	; 0x03
    245a:	20 e0       	ldi	r18, 0x00	; 0
    245c:	30 e0       	ldi	r19, 0x00	; 0
    245e:	40 e8       	ldi	r20, 0x80	; 128
    2460:	5f e3       	ldi	r21, 0x3F	; 63
    2462:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    2466:	88 23       	and	r24, r24
    2468:	2c f4       	brge	.+10     	; 0x2474 <LCD_displayCharacter+0x40e>
		__ticks = 1;
    246a:	81 e0       	ldi	r24, 0x01	; 1
    246c:	90 e0       	ldi	r25, 0x00	; 0
    246e:	9e af       	std	Y+62, r25	; 0x3e
    2470:	8d af       	std	Y+61, r24	; 0x3d
    2472:	46 c0       	rjmp	.+140    	; 0x2500 <LCD_displayCharacter+0x49a>
	else if (__tmp > 65535)
    2474:	fe 01       	movw	r30, r28
    2476:	ff 96       	adiw	r30, 0x3f	; 63
    2478:	60 81       	ld	r22, Z
    247a:	71 81       	ldd	r23, Z+1	; 0x01
    247c:	82 81       	ldd	r24, Z+2	; 0x02
    247e:	93 81       	ldd	r25, Z+3	; 0x03
    2480:	20 e0       	ldi	r18, 0x00	; 0
    2482:	3f ef       	ldi	r19, 0xFF	; 255
    2484:	4f e7       	ldi	r20, 0x7F	; 127
    2486:	57 e4       	ldi	r21, 0x47	; 71
    2488:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    248c:	18 16       	cp	r1, r24
    248e:	64 f5       	brge	.+88     	; 0x24e8 <LCD_displayCharacter+0x482>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2490:	fe 01       	movw	r30, r28
    2492:	ed 5b       	subi	r30, 0xBD	; 189
    2494:	ff 4f       	sbci	r31, 0xFF	; 255
    2496:	60 81       	ld	r22, Z
    2498:	71 81       	ldd	r23, Z+1	; 0x01
    249a:	82 81       	ldd	r24, Z+2	; 0x02
    249c:	93 81       	ldd	r25, Z+3	; 0x03
    249e:	20 e0       	ldi	r18, 0x00	; 0
    24a0:	30 e0       	ldi	r19, 0x00	; 0
    24a2:	40 e2       	ldi	r20, 0x20	; 32
    24a4:	51 e4       	ldi	r21, 0x41	; 65
    24a6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    24aa:	dc 01       	movw	r26, r24
    24ac:	cb 01       	movw	r24, r22
    24ae:	bc 01       	movw	r22, r24
    24b0:	cd 01       	movw	r24, r26
    24b2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    24b6:	dc 01       	movw	r26, r24
    24b8:	cb 01       	movw	r24, r22
    24ba:	9e af       	std	Y+62, r25	; 0x3e
    24bc:	8d af       	std	Y+61, r24	; 0x3d
    24be:	0f c0       	rjmp	.+30     	; 0x24de <LCD_displayCharacter+0x478>
    24c0:	88 ec       	ldi	r24, 0xC8	; 200
    24c2:	90 e0       	ldi	r25, 0x00	; 0
    24c4:	9c af       	std	Y+60, r25	; 0x3c
    24c6:	8b af       	std	Y+59, r24	; 0x3b
    24c8:	8b ad       	ldd	r24, Y+59	; 0x3b
    24ca:	9c ad       	ldd	r25, Y+60	; 0x3c
    24cc:	01 97       	sbiw	r24, 0x01	; 1
    24ce:	f1 f7       	brne	.-4      	; 0x24cc <LCD_displayCharacter+0x466>
    24d0:	9c af       	std	Y+60, r25	; 0x3c
    24d2:	8b af       	std	Y+59, r24	; 0x3b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    24d4:	8d ad       	ldd	r24, Y+61	; 0x3d
    24d6:	9e ad       	ldd	r25, Y+62	; 0x3e
    24d8:	01 97       	sbiw	r24, 0x01	; 1
    24da:	9e af       	std	Y+62, r25	; 0x3e
    24dc:	8d af       	std	Y+61, r24	; 0x3d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    24de:	8d ad       	ldd	r24, Y+61	; 0x3d
    24e0:	9e ad       	ldd	r25, Y+62	; 0x3e
    24e2:	00 97       	sbiw	r24, 0x00	; 0
    24e4:	69 f7       	brne	.-38     	; 0x24c0 <LCD_displayCharacter+0x45a>
    24e6:	16 c0       	rjmp	.+44     	; 0x2514 <LCD_displayCharacter+0x4ae>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    24e8:	fe 01       	movw	r30, r28
    24ea:	ff 96       	adiw	r30, 0x3f	; 63
    24ec:	60 81       	ld	r22, Z
    24ee:	71 81       	ldd	r23, Z+1	; 0x01
    24f0:	82 81       	ldd	r24, Z+2	; 0x02
    24f2:	93 81       	ldd	r25, Z+3	; 0x03
    24f4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    24f8:	dc 01       	movw	r26, r24
    24fa:	cb 01       	movw	r24, r22
    24fc:	9e af       	std	Y+62, r25	; 0x3e
    24fe:	8d af       	std	Y+61, r24	; 0x3d
    2500:	8d ad       	ldd	r24, Y+61	; 0x3d
    2502:	9e ad       	ldd	r25, Y+62	; 0x3e
    2504:	9a af       	std	Y+58, r25	; 0x3a
    2506:	89 af       	std	Y+57, r24	; 0x39
    2508:	89 ad       	ldd	r24, Y+57	; 0x39
    250a:	9a ad       	ldd	r25, Y+58	; 0x3a
    250c:	01 97       	sbiw	r24, 0x01	; 1
    250e:	f1 f7       	brne	.-4      	; 0x250c <LCD_displayCharacter+0x4a6>
    2510:	9a af       	std	Y+58, r25	; 0x3a
    2512:	89 af       	std	Y+57, r24	; 0x39

	_delay_ms(1); /* delay for processing Tdsw = 100ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_LOW); /* Disable LCD E=0 */
    2514:	80 e0       	ldi	r24, 0x00	; 0
    2516:	62 e0       	ldi	r22, 0x02	; 2
    2518:	40 e0       	ldi	r20, 0x00	; 0
    251a:	0e 94 b3 08 	call	0x1166	; 0x1166 <GPIO_writePin>
    251e:	80 e0       	ldi	r24, 0x00	; 0
    2520:	90 e0       	ldi	r25, 0x00	; 0
    2522:	a0 e8       	ldi	r26, 0x80	; 128
    2524:	bf e3       	ldi	r27, 0x3F	; 63
    2526:	8d ab       	std	Y+53, r24	; 0x35
    2528:	9e ab       	std	Y+54, r25	; 0x36
    252a:	af ab       	std	Y+55, r26	; 0x37
    252c:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    252e:	6d a9       	ldd	r22, Y+53	; 0x35
    2530:	7e a9       	ldd	r23, Y+54	; 0x36
    2532:	8f a9       	ldd	r24, Y+55	; 0x37
    2534:	98 ad       	ldd	r25, Y+56	; 0x38
    2536:	20 e0       	ldi	r18, 0x00	; 0
    2538:	30 e0       	ldi	r19, 0x00	; 0
    253a:	4a ef       	ldi	r20, 0xFA	; 250
    253c:	54 e4       	ldi	r21, 0x44	; 68
    253e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2542:	dc 01       	movw	r26, r24
    2544:	cb 01       	movw	r24, r22
    2546:	89 ab       	std	Y+49, r24	; 0x31
    2548:	9a ab       	std	Y+50, r25	; 0x32
    254a:	ab ab       	std	Y+51, r26	; 0x33
    254c:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    254e:	69 a9       	ldd	r22, Y+49	; 0x31
    2550:	7a a9       	ldd	r23, Y+50	; 0x32
    2552:	8b a9       	ldd	r24, Y+51	; 0x33
    2554:	9c a9       	ldd	r25, Y+52	; 0x34
    2556:	20 e0       	ldi	r18, 0x00	; 0
    2558:	30 e0       	ldi	r19, 0x00	; 0
    255a:	40 e8       	ldi	r20, 0x80	; 128
    255c:	5f e3       	ldi	r21, 0x3F	; 63
    255e:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    2562:	88 23       	and	r24, r24
    2564:	2c f4       	brge	.+10     	; 0x2570 <LCD_displayCharacter+0x50a>
		__ticks = 1;
    2566:	81 e0       	ldi	r24, 0x01	; 1
    2568:	90 e0       	ldi	r25, 0x00	; 0
    256a:	98 ab       	std	Y+48, r25	; 0x30
    256c:	8f a7       	std	Y+47, r24	; 0x2f
    256e:	3f c0       	rjmp	.+126    	; 0x25ee <LCD_displayCharacter+0x588>
	else if (__tmp > 65535)
    2570:	69 a9       	ldd	r22, Y+49	; 0x31
    2572:	7a a9       	ldd	r23, Y+50	; 0x32
    2574:	8b a9       	ldd	r24, Y+51	; 0x33
    2576:	9c a9       	ldd	r25, Y+52	; 0x34
    2578:	20 e0       	ldi	r18, 0x00	; 0
    257a:	3f ef       	ldi	r19, 0xFF	; 255
    257c:	4f e7       	ldi	r20, 0x7F	; 127
    257e:	57 e4       	ldi	r21, 0x47	; 71
    2580:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    2584:	18 16       	cp	r1, r24
    2586:	4c f5       	brge	.+82     	; 0x25da <LCD_displayCharacter+0x574>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2588:	6d a9       	ldd	r22, Y+53	; 0x35
    258a:	7e a9       	ldd	r23, Y+54	; 0x36
    258c:	8f a9       	ldd	r24, Y+55	; 0x37
    258e:	98 ad       	ldd	r25, Y+56	; 0x38
    2590:	20 e0       	ldi	r18, 0x00	; 0
    2592:	30 e0       	ldi	r19, 0x00	; 0
    2594:	40 e2       	ldi	r20, 0x20	; 32
    2596:	51 e4       	ldi	r21, 0x41	; 65
    2598:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    259c:	dc 01       	movw	r26, r24
    259e:	cb 01       	movw	r24, r22
    25a0:	bc 01       	movw	r22, r24
    25a2:	cd 01       	movw	r24, r26
    25a4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    25a8:	dc 01       	movw	r26, r24
    25aa:	cb 01       	movw	r24, r22
    25ac:	98 ab       	std	Y+48, r25	; 0x30
    25ae:	8f a7       	std	Y+47, r24	; 0x2f
    25b0:	0f c0       	rjmp	.+30     	; 0x25d0 <LCD_displayCharacter+0x56a>
    25b2:	88 ec       	ldi	r24, 0xC8	; 200
    25b4:	90 e0       	ldi	r25, 0x00	; 0
    25b6:	9e a7       	std	Y+46, r25	; 0x2e
    25b8:	8d a7       	std	Y+45, r24	; 0x2d
    25ba:	8d a5       	ldd	r24, Y+45	; 0x2d
    25bc:	9e a5       	ldd	r25, Y+46	; 0x2e
    25be:	01 97       	sbiw	r24, 0x01	; 1
    25c0:	f1 f7       	brne	.-4      	; 0x25be <LCD_displayCharacter+0x558>
    25c2:	9e a7       	std	Y+46, r25	; 0x2e
    25c4:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    25c6:	8f a5       	ldd	r24, Y+47	; 0x2f
    25c8:	98 a9       	ldd	r25, Y+48	; 0x30
    25ca:	01 97       	sbiw	r24, 0x01	; 1
    25cc:	98 ab       	std	Y+48, r25	; 0x30
    25ce:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    25d0:	8f a5       	ldd	r24, Y+47	; 0x2f
    25d2:	98 a9       	ldd	r25, Y+48	; 0x30
    25d4:	00 97       	sbiw	r24, 0x00	; 0
    25d6:	69 f7       	brne	.-38     	; 0x25b2 <LCD_displayCharacter+0x54c>
    25d8:	14 c0       	rjmp	.+40     	; 0x2602 <LCD_displayCharacter+0x59c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    25da:	69 a9       	ldd	r22, Y+49	; 0x31
    25dc:	7a a9       	ldd	r23, Y+50	; 0x32
    25de:	8b a9       	ldd	r24, Y+51	; 0x33
    25e0:	9c a9       	ldd	r25, Y+52	; 0x34
    25e2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    25e6:	dc 01       	movw	r26, r24
    25e8:	cb 01       	movw	r24, r22
    25ea:	98 ab       	std	Y+48, r25	; 0x30
    25ec:	8f a7       	std	Y+47, r24	; 0x2f
    25ee:	8f a5       	ldd	r24, Y+47	; 0x2f
    25f0:	98 a9       	ldd	r25, Y+48	; 0x30
    25f2:	9c a7       	std	Y+44, r25	; 0x2c
    25f4:	8b a7       	std	Y+43, r24	; 0x2b
    25f6:	8b a5       	ldd	r24, Y+43	; 0x2b
    25f8:	9c a5       	ldd	r25, Y+44	; 0x2c
    25fa:	01 97       	sbiw	r24, 0x01	; 1
    25fc:	f1 f7       	brne	.-4      	; 0x25fa <LCD_displayCharacter+0x594>
    25fe:	9c a7       	std	Y+44, r25	; 0x2c
    2600:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(1); /* delay for processing Th = 13ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_HIGH); /* Enable LCD E=1 */
    2602:	80 e0       	ldi	r24, 0x00	; 0
    2604:	62 e0       	ldi	r22, 0x02	; 2
    2606:	41 e0       	ldi	r20, 0x01	; 1
    2608:	0e 94 b3 08 	call	0x1166	; 0x1166 <GPIO_writePin>
    260c:	80 e0       	ldi	r24, 0x00	; 0
    260e:	90 e0       	ldi	r25, 0x00	; 0
    2610:	a0 e8       	ldi	r26, 0x80	; 128
    2612:	bf e3       	ldi	r27, 0x3F	; 63
    2614:	8f a3       	std	Y+39, r24	; 0x27
    2616:	98 a7       	std	Y+40, r25	; 0x28
    2618:	a9 a7       	std	Y+41, r26	; 0x29
    261a:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    261c:	6f a1       	ldd	r22, Y+39	; 0x27
    261e:	78 a5       	ldd	r23, Y+40	; 0x28
    2620:	89 a5       	ldd	r24, Y+41	; 0x29
    2622:	9a a5       	ldd	r25, Y+42	; 0x2a
    2624:	20 e0       	ldi	r18, 0x00	; 0
    2626:	30 e0       	ldi	r19, 0x00	; 0
    2628:	4a ef       	ldi	r20, 0xFA	; 250
    262a:	54 e4       	ldi	r21, 0x44	; 68
    262c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2630:	dc 01       	movw	r26, r24
    2632:	cb 01       	movw	r24, r22
    2634:	8b a3       	std	Y+35, r24	; 0x23
    2636:	9c a3       	std	Y+36, r25	; 0x24
    2638:	ad a3       	std	Y+37, r26	; 0x25
    263a:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    263c:	6b a1       	ldd	r22, Y+35	; 0x23
    263e:	7c a1       	ldd	r23, Y+36	; 0x24
    2640:	8d a1       	ldd	r24, Y+37	; 0x25
    2642:	9e a1       	ldd	r25, Y+38	; 0x26
    2644:	20 e0       	ldi	r18, 0x00	; 0
    2646:	30 e0       	ldi	r19, 0x00	; 0
    2648:	40 e8       	ldi	r20, 0x80	; 128
    264a:	5f e3       	ldi	r21, 0x3F	; 63
    264c:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    2650:	88 23       	and	r24, r24
    2652:	2c f4       	brge	.+10     	; 0x265e <LCD_displayCharacter+0x5f8>
		__ticks = 1;
    2654:	81 e0       	ldi	r24, 0x01	; 1
    2656:	90 e0       	ldi	r25, 0x00	; 0
    2658:	9a a3       	std	Y+34, r25	; 0x22
    265a:	89 a3       	std	Y+33, r24	; 0x21
    265c:	3f c0       	rjmp	.+126    	; 0x26dc <LCD_displayCharacter+0x676>
	else if (__tmp > 65535)
    265e:	6b a1       	ldd	r22, Y+35	; 0x23
    2660:	7c a1       	ldd	r23, Y+36	; 0x24
    2662:	8d a1       	ldd	r24, Y+37	; 0x25
    2664:	9e a1       	ldd	r25, Y+38	; 0x26
    2666:	20 e0       	ldi	r18, 0x00	; 0
    2668:	3f ef       	ldi	r19, 0xFF	; 255
    266a:	4f e7       	ldi	r20, 0x7F	; 127
    266c:	57 e4       	ldi	r21, 0x47	; 71
    266e:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    2672:	18 16       	cp	r1, r24
    2674:	4c f5       	brge	.+82     	; 0x26c8 <LCD_displayCharacter+0x662>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2676:	6f a1       	ldd	r22, Y+39	; 0x27
    2678:	78 a5       	ldd	r23, Y+40	; 0x28
    267a:	89 a5       	ldd	r24, Y+41	; 0x29
    267c:	9a a5       	ldd	r25, Y+42	; 0x2a
    267e:	20 e0       	ldi	r18, 0x00	; 0
    2680:	30 e0       	ldi	r19, 0x00	; 0
    2682:	40 e2       	ldi	r20, 0x20	; 32
    2684:	51 e4       	ldi	r21, 0x41	; 65
    2686:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    268a:	dc 01       	movw	r26, r24
    268c:	cb 01       	movw	r24, r22
    268e:	bc 01       	movw	r22, r24
    2690:	cd 01       	movw	r24, r26
    2692:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2696:	dc 01       	movw	r26, r24
    2698:	cb 01       	movw	r24, r22
    269a:	9a a3       	std	Y+34, r25	; 0x22
    269c:	89 a3       	std	Y+33, r24	; 0x21
    269e:	0f c0       	rjmp	.+30     	; 0x26be <LCD_displayCharacter+0x658>
    26a0:	88 ec       	ldi	r24, 0xC8	; 200
    26a2:	90 e0       	ldi	r25, 0x00	; 0
    26a4:	98 a3       	std	Y+32, r25	; 0x20
    26a6:	8f 8f       	std	Y+31, r24	; 0x1f
    26a8:	8f 8d       	ldd	r24, Y+31	; 0x1f
    26aa:	98 a1       	ldd	r25, Y+32	; 0x20
    26ac:	01 97       	sbiw	r24, 0x01	; 1
    26ae:	f1 f7       	brne	.-4      	; 0x26ac <LCD_displayCharacter+0x646>
    26b0:	98 a3       	std	Y+32, r25	; 0x20
    26b2:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    26b4:	89 a1       	ldd	r24, Y+33	; 0x21
    26b6:	9a a1       	ldd	r25, Y+34	; 0x22
    26b8:	01 97       	sbiw	r24, 0x01	; 1
    26ba:	9a a3       	std	Y+34, r25	; 0x22
    26bc:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    26be:	89 a1       	ldd	r24, Y+33	; 0x21
    26c0:	9a a1       	ldd	r25, Y+34	; 0x22
    26c2:	00 97       	sbiw	r24, 0x00	; 0
    26c4:	69 f7       	brne	.-38     	; 0x26a0 <LCD_displayCharacter+0x63a>
    26c6:	14 c0       	rjmp	.+40     	; 0x26f0 <LCD_displayCharacter+0x68a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    26c8:	6b a1       	ldd	r22, Y+35	; 0x23
    26ca:	7c a1       	ldd	r23, Y+36	; 0x24
    26cc:	8d a1       	ldd	r24, Y+37	; 0x25
    26ce:	9e a1       	ldd	r25, Y+38	; 0x26
    26d0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    26d4:	dc 01       	movw	r26, r24
    26d6:	cb 01       	movw	r24, r22
    26d8:	9a a3       	std	Y+34, r25	; 0x22
    26da:	89 a3       	std	Y+33, r24	; 0x21
    26dc:	89 a1       	ldd	r24, Y+33	; 0x21
    26de:	9a a1       	ldd	r25, Y+34	; 0x22
    26e0:	9e 8f       	std	Y+30, r25	; 0x1e
    26e2:	8d 8f       	std	Y+29, r24	; 0x1d
    26e4:	8d 8d       	ldd	r24, Y+29	; 0x1d
    26e6:	9e 8d       	ldd	r25, Y+30	; 0x1e
    26e8:	01 97       	sbiw	r24, 0x01	; 1
    26ea:	f1 f7       	brne	.-4      	; 0x26e8 <LCD_displayCharacter+0x682>
    26ec:	9e 8f       	std	Y+30, r25	; 0x1e
    26ee:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(1); /* delay for processing Tpw - Tdws = 190ns */

	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB4_PIN_ID,GET_BIT(data,0));
    26f0:	fe 01       	movw	r30, r28
    26f2:	ed 59       	subi	r30, 0x9D	; 157
    26f4:	ff 4f       	sbci	r31, 0xFF	; 255
    26f6:	80 81       	ld	r24, Z
    26f8:	98 2f       	mov	r25, r24
    26fa:	91 70       	andi	r25, 0x01	; 1
    26fc:	80 e0       	ldi	r24, 0x00	; 0
    26fe:	63 e0       	ldi	r22, 0x03	; 3
    2700:	49 2f       	mov	r20, r25
    2702:	0e 94 b3 08 	call	0x1166	; 0x1166 <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB5_PIN_ID,GET_BIT(data,1));
    2706:	fe 01       	movw	r30, r28
    2708:	ed 59       	subi	r30, 0x9D	; 157
    270a:	ff 4f       	sbci	r31, 0xFF	; 255
    270c:	80 81       	ld	r24, Z
    270e:	88 2f       	mov	r24, r24
    2710:	90 e0       	ldi	r25, 0x00	; 0
    2712:	82 70       	andi	r24, 0x02	; 2
    2714:	90 70       	andi	r25, 0x00	; 0
    2716:	95 95       	asr	r25
    2718:	87 95       	ror	r24
    271a:	98 2f       	mov	r25, r24
    271c:	80 e0       	ldi	r24, 0x00	; 0
    271e:	64 e0       	ldi	r22, 0x04	; 4
    2720:	49 2f       	mov	r20, r25
    2722:	0e 94 b3 08 	call	0x1166	; 0x1166 <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB6_PIN_ID,GET_BIT(data,2));
    2726:	fe 01       	movw	r30, r28
    2728:	ed 59       	subi	r30, 0x9D	; 157
    272a:	ff 4f       	sbci	r31, 0xFF	; 255
    272c:	80 81       	ld	r24, Z
    272e:	88 2f       	mov	r24, r24
    2730:	90 e0       	ldi	r25, 0x00	; 0
    2732:	84 70       	andi	r24, 0x04	; 4
    2734:	90 70       	andi	r25, 0x00	; 0
    2736:	95 95       	asr	r25
    2738:	87 95       	ror	r24
    273a:	95 95       	asr	r25
    273c:	87 95       	ror	r24
    273e:	98 2f       	mov	r25, r24
    2740:	80 e0       	ldi	r24, 0x00	; 0
    2742:	65 e0       	ldi	r22, 0x05	; 5
    2744:	49 2f       	mov	r20, r25
    2746:	0e 94 b3 08 	call	0x1166	; 0x1166 <GPIO_writePin>
	GPIO_writePin(LCD_DATA_PORT_ID,LCD_DB7_PIN_ID,GET_BIT(data,3));
    274a:	fe 01       	movw	r30, r28
    274c:	ed 59       	subi	r30, 0x9D	; 157
    274e:	ff 4f       	sbci	r31, 0xFF	; 255
    2750:	80 81       	ld	r24, Z
    2752:	88 2f       	mov	r24, r24
    2754:	90 e0       	ldi	r25, 0x00	; 0
    2756:	88 70       	andi	r24, 0x08	; 8
    2758:	90 70       	andi	r25, 0x00	; 0
    275a:	95 95       	asr	r25
    275c:	87 95       	ror	r24
    275e:	95 95       	asr	r25
    2760:	87 95       	ror	r24
    2762:	95 95       	asr	r25
    2764:	87 95       	ror	r24
    2766:	98 2f       	mov	r25, r24
    2768:	80 e0       	ldi	r24, 0x00	; 0
    276a:	66 e0       	ldi	r22, 0x06	; 6
    276c:	49 2f       	mov	r20, r25
    276e:	0e 94 b3 08 	call	0x1166	; 0x1166 <GPIO_writePin>
    2772:	80 e0       	ldi	r24, 0x00	; 0
    2774:	90 e0       	ldi	r25, 0x00	; 0
    2776:	a0 e8       	ldi	r26, 0x80	; 128
    2778:	bf e3       	ldi	r27, 0x3F	; 63
    277a:	89 8f       	std	Y+25, r24	; 0x19
    277c:	9a 8f       	std	Y+26, r25	; 0x1a
    277e:	ab 8f       	std	Y+27, r26	; 0x1b
    2780:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2782:	69 8d       	ldd	r22, Y+25	; 0x19
    2784:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2786:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2788:	9c 8d       	ldd	r25, Y+28	; 0x1c
    278a:	20 e0       	ldi	r18, 0x00	; 0
    278c:	30 e0       	ldi	r19, 0x00	; 0
    278e:	4a ef       	ldi	r20, 0xFA	; 250
    2790:	54 e4       	ldi	r21, 0x44	; 68
    2792:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2796:	dc 01       	movw	r26, r24
    2798:	cb 01       	movw	r24, r22
    279a:	8d 8b       	std	Y+21, r24	; 0x15
    279c:	9e 8b       	std	Y+22, r25	; 0x16
    279e:	af 8b       	std	Y+23, r26	; 0x17
    27a0:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    27a2:	6d 89       	ldd	r22, Y+21	; 0x15
    27a4:	7e 89       	ldd	r23, Y+22	; 0x16
    27a6:	8f 89       	ldd	r24, Y+23	; 0x17
    27a8:	98 8d       	ldd	r25, Y+24	; 0x18
    27aa:	20 e0       	ldi	r18, 0x00	; 0
    27ac:	30 e0       	ldi	r19, 0x00	; 0
    27ae:	40 e8       	ldi	r20, 0x80	; 128
    27b0:	5f e3       	ldi	r21, 0x3F	; 63
    27b2:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    27b6:	88 23       	and	r24, r24
    27b8:	2c f4       	brge	.+10     	; 0x27c4 <LCD_displayCharacter+0x75e>
		__ticks = 1;
    27ba:	81 e0       	ldi	r24, 0x01	; 1
    27bc:	90 e0       	ldi	r25, 0x00	; 0
    27be:	9c 8b       	std	Y+20, r25	; 0x14
    27c0:	8b 8b       	std	Y+19, r24	; 0x13
    27c2:	3f c0       	rjmp	.+126    	; 0x2842 <LCD_displayCharacter+0x7dc>
	else if (__tmp > 65535)
    27c4:	6d 89       	ldd	r22, Y+21	; 0x15
    27c6:	7e 89       	ldd	r23, Y+22	; 0x16
    27c8:	8f 89       	ldd	r24, Y+23	; 0x17
    27ca:	98 8d       	ldd	r25, Y+24	; 0x18
    27cc:	20 e0       	ldi	r18, 0x00	; 0
    27ce:	3f ef       	ldi	r19, 0xFF	; 255
    27d0:	4f e7       	ldi	r20, 0x7F	; 127
    27d2:	57 e4       	ldi	r21, 0x47	; 71
    27d4:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    27d8:	18 16       	cp	r1, r24
    27da:	4c f5       	brge	.+82     	; 0x282e <LCD_displayCharacter+0x7c8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    27dc:	69 8d       	ldd	r22, Y+25	; 0x19
    27de:	7a 8d       	ldd	r23, Y+26	; 0x1a
    27e0:	8b 8d       	ldd	r24, Y+27	; 0x1b
    27e2:	9c 8d       	ldd	r25, Y+28	; 0x1c
    27e4:	20 e0       	ldi	r18, 0x00	; 0
    27e6:	30 e0       	ldi	r19, 0x00	; 0
    27e8:	40 e2       	ldi	r20, 0x20	; 32
    27ea:	51 e4       	ldi	r21, 0x41	; 65
    27ec:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    27f0:	dc 01       	movw	r26, r24
    27f2:	cb 01       	movw	r24, r22
    27f4:	bc 01       	movw	r22, r24
    27f6:	cd 01       	movw	r24, r26
    27f8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    27fc:	dc 01       	movw	r26, r24
    27fe:	cb 01       	movw	r24, r22
    2800:	9c 8b       	std	Y+20, r25	; 0x14
    2802:	8b 8b       	std	Y+19, r24	; 0x13
    2804:	0f c0       	rjmp	.+30     	; 0x2824 <LCD_displayCharacter+0x7be>
    2806:	88 ec       	ldi	r24, 0xC8	; 200
    2808:	90 e0       	ldi	r25, 0x00	; 0
    280a:	9a 8b       	std	Y+18, r25	; 0x12
    280c:	89 8b       	std	Y+17, r24	; 0x11
    280e:	89 89       	ldd	r24, Y+17	; 0x11
    2810:	9a 89       	ldd	r25, Y+18	; 0x12
    2812:	01 97       	sbiw	r24, 0x01	; 1
    2814:	f1 f7       	brne	.-4      	; 0x2812 <LCD_displayCharacter+0x7ac>
    2816:	9a 8b       	std	Y+18, r25	; 0x12
    2818:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    281a:	8b 89       	ldd	r24, Y+19	; 0x13
    281c:	9c 89       	ldd	r25, Y+20	; 0x14
    281e:	01 97       	sbiw	r24, 0x01	; 1
    2820:	9c 8b       	std	Y+20, r25	; 0x14
    2822:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2824:	8b 89       	ldd	r24, Y+19	; 0x13
    2826:	9c 89       	ldd	r25, Y+20	; 0x14
    2828:	00 97       	sbiw	r24, 0x00	; 0
    282a:	69 f7       	brne	.-38     	; 0x2806 <LCD_displayCharacter+0x7a0>
    282c:	14 c0       	rjmp	.+40     	; 0x2856 <LCD_displayCharacter+0x7f0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    282e:	6d 89       	ldd	r22, Y+21	; 0x15
    2830:	7e 89       	ldd	r23, Y+22	; 0x16
    2832:	8f 89       	ldd	r24, Y+23	; 0x17
    2834:	98 8d       	ldd	r25, Y+24	; 0x18
    2836:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    283a:	dc 01       	movw	r26, r24
    283c:	cb 01       	movw	r24, r22
    283e:	9c 8b       	std	Y+20, r25	; 0x14
    2840:	8b 8b       	std	Y+19, r24	; 0x13
    2842:	8b 89       	ldd	r24, Y+19	; 0x13
    2844:	9c 89       	ldd	r25, Y+20	; 0x14
    2846:	98 8b       	std	Y+16, r25	; 0x10
    2848:	8f 87       	std	Y+15, r24	; 0x0f
    284a:	8f 85       	ldd	r24, Y+15	; 0x0f
    284c:	98 89       	ldd	r25, Y+16	; 0x10
    284e:	01 97       	sbiw	r24, 0x01	; 1
    2850:	f1 f7       	brne	.-4      	; 0x284e <LCD_displayCharacter+0x7e8>
    2852:	98 8b       	std	Y+16, r25	; 0x10
    2854:	8f 87       	std	Y+15, r24	; 0x0f

	_delay_ms(1); /* delay for processing Tdsw = 100ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_LOW); /* Disable LCD E=0 */
    2856:	80 e0       	ldi	r24, 0x00	; 0
    2858:	62 e0       	ldi	r22, 0x02	; 2
    285a:	40 e0       	ldi	r20, 0x00	; 0
    285c:	0e 94 b3 08 	call	0x1166	; 0x1166 <GPIO_writePin>
    2860:	80 e0       	ldi	r24, 0x00	; 0
    2862:	90 e0       	ldi	r25, 0x00	; 0
    2864:	a0 e8       	ldi	r26, 0x80	; 128
    2866:	bf e3       	ldi	r27, 0x3F	; 63
    2868:	8b 87       	std	Y+11, r24	; 0x0b
    286a:	9c 87       	std	Y+12, r25	; 0x0c
    286c:	ad 87       	std	Y+13, r26	; 0x0d
    286e:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2870:	6b 85       	ldd	r22, Y+11	; 0x0b
    2872:	7c 85       	ldd	r23, Y+12	; 0x0c
    2874:	8d 85       	ldd	r24, Y+13	; 0x0d
    2876:	9e 85       	ldd	r25, Y+14	; 0x0e
    2878:	20 e0       	ldi	r18, 0x00	; 0
    287a:	30 e0       	ldi	r19, 0x00	; 0
    287c:	4a ef       	ldi	r20, 0xFA	; 250
    287e:	54 e4       	ldi	r21, 0x44	; 68
    2880:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2884:	dc 01       	movw	r26, r24
    2886:	cb 01       	movw	r24, r22
    2888:	8f 83       	std	Y+7, r24	; 0x07
    288a:	98 87       	std	Y+8, r25	; 0x08
    288c:	a9 87       	std	Y+9, r26	; 0x09
    288e:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2890:	6f 81       	ldd	r22, Y+7	; 0x07
    2892:	78 85       	ldd	r23, Y+8	; 0x08
    2894:	89 85       	ldd	r24, Y+9	; 0x09
    2896:	9a 85       	ldd	r25, Y+10	; 0x0a
    2898:	20 e0       	ldi	r18, 0x00	; 0
    289a:	30 e0       	ldi	r19, 0x00	; 0
    289c:	40 e8       	ldi	r20, 0x80	; 128
    289e:	5f e3       	ldi	r21, 0x3F	; 63
    28a0:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    28a4:	88 23       	and	r24, r24
    28a6:	2c f4       	brge	.+10     	; 0x28b2 <LCD_displayCharacter+0x84c>
		__ticks = 1;
    28a8:	81 e0       	ldi	r24, 0x01	; 1
    28aa:	90 e0       	ldi	r25, 0x00	; 0
    28ac:	9e 83       	std	Y+6, r25	; 0x06
    28ae:	8d 83       	std	Y+5, r24	; 0x05
    28b0:	3f c0       	rjmp	.+126    	; 0x2930 <LCD_displayCharacter+0x8ca>
	else if (__tmp > 65535)
    28b2:	6f 81       	ldd	r22, Y+7	; 0x07
    28b4:	78 85       	ldd	r23, Y+8	; 0x08
    28b6:	89 85       	ldd	r24, Y+9	; 0x09
    28b8:	9a 85       	ldd	r25, Y+10	; 0x0a
    28ba:	20 e0       	ldi	r18, 0x00	; 0
    28bc:	3f ef       	ldi	r19, 0xFF	; 255
    28be:	4f e7       	ldi	r20, 0x7F	; 127
    28c0:	57 e4       	ldi	r21, 0x47	; 71
    28c2:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    28c6:	18 16       	cp	r1, r24
    28c8:	4c f5       	brge	.+82     	; 0x291c <LCD_displayCharacter+0x8b6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    28ca:	6b 85       	ldd	r22, Y+11	; 0x0b
    28cc:	7c 85       	ldd	r23, Y+12	; 0x0c
    28ce:	8d 85       	ldd	r24, Y+13	; 0x0d
    28d0:	9e 85       	ldd	r25, Y+14	; 0x0e
    28d2:	20 e0       	ldi	r18, 0x00	; 0
    28d4:	30 e0       	ldi	r19, 0x00	; 0
    28d6:	40 e2       	ldi	r20, 0x20	; 32
    28d8:	51 e4       	ldi	r21, 0x41	; 65
    28da:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    28de:	dc 01       	movw	r26, r24
    28e0:	cb 01       	movw	r24, r22
    28e2:	bc 01       	movw	r22, r24
    28e4:	cd 01       	movw	r24, r26
    28e6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    28ea:	dc 01       	movw	r26, r24
    28ec:	cb 01       	movw	r24, r22
    28ee:	9e 83       	std	Y+6, r25	; 0x06
    28f0:	8d 83       	std	Y+5, r24	; 0x05
    28f2:	0f c0       	rjmp	.+30     	; 0x2912 <LCD_displayCharacter+0x8ac>
    28f4:	88 ec       	ldi	r24, 0xC8	; 200
    28f6:	90 e0       	ldi	r25, 0x00	; 0
    28f8:	9c 83       	std	Y+4, r25	; 0x04
    28fa:	8b 83       	std	Y+3, r24	; 0x03
    28fc:	8b 81       	ldd	r24, Y+3	; 0x03
    28fe:	9c 81       	ldd	r25, Y+4	; 0x04
    2900:	01 97       	sbiw	r24, 0x01	; 1
    2902:	f1 f7       	brne	.-4      	; 0x2900 <LCD_displayCharacter+0x89a>
    2904:	9c 83       	std	Y+4, r25	; 0x04
    2906:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2908:	8d 81       	ldd	r24, Y+5	; 0x05
    290a:	9e 81       	ldd	r25, Y+6	; 0x06
    290c:	01 97       	sbiw	r24, 0x01	; 1
    290e:	9e 83       	std	Y+6, r25	; 0x06
    2910:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2912:	8d 81       	ldd	r24, Y+5	; 0x05
    2914:	9e 81       	ldd	r25, Y+6	; 0x06
    2916:	00 97       	sbiw	r24, 0x00	; 0
    2918:	69 f7       	brne	.-38     	; 0x28f4 <LCD_displayCharacter+0x88e>
    291a:	14 c0       	rjmp	.+40     	; 0x2944 <LCD_displayCharacter+0x8de>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    291c:	6f 81       	ldd	r22, Y+7	; 0x07
    291e:	78 85       	ldd	r23, Y+8	; 0x08
    2920:	89 85       	ldd	r24, Y+9	; 0x09
    2922:	9a 85       	ldd	r25, Y+10	; 0x0a
    2924:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2928:	dc 01       	movw	r26, r24
    292a:	cb 01       	movw	r24, r22
    292c:	9e 83       	std	Y+6, r25	; 0x06
    292e:	8d 83       	std	Y+5, r24	; 0x05
    2930:	8d 81       	ldd	r24, Y+5	; 0x05
    2932:	9e 81       	ldd	r25, Y+6	; 0x06
    2934:	9a 83       	std	Y+2, r25	; 0x02
    2936:	89 83       	std	Y+1, r24	; 0x01
    2938:	89 81       	ldd	r24, Y+1	; 0x01
    293a:	9a 81       	ldd	r25, Y+2	; 0x02
    293c:	01 97       	sbiw	r24, 0x01	; 1
    293e:	f1 f7       	brne	.-4      	; 0x293c <LCD_displayCharacter+0x8d6>
    2940:	9a 83       	std	Y+2, r25	; 0x02
    2942:	89 83       	std	Y+1, r24	; 0x01
	GPIO_writePort(LCD_DATA_PORT_ID,data); /* out the required command to the data bus D0 --> D7 */
	_delay_ms(1); /* delay for processing Tdsw = 100ns */
	GPIO_writePin(LCD_E_PORT_ID,LCD_E_PIN_ID,LOGIC_LOW); /* Disable LCD E=0 */
	_delay_ms(1); /* delay for processing Th = 13ns */
#endif
}
    2944:	cd 59       	subi	r28, 0x9D	; 157
    2946:	df 4f       	sbci	r29, 0xFF	; 255
    2948:	0f b6       	in	r0, 0x3f	; 63
    294a:	f8 94       	cli
    294c:	de bf       	out	0x3e, r29	; 62
    294e:	0f be       	out	0x3f, r0	; 63
    2950:	cd bf       	out	0x3d, r28	; 61
    2952:	cf 91       	pop	r28
    2954:	df 91       	pop	r29
    2956:	1f 91       	pop	r17
    2958:	0f 91       	pop	r16
    295a:	08 95       	ret

0000295c <LCD_displayString>:
/*
 * Description :
 * Display the required string on the screen
 */
void LCD_displayString(const char *Str)
{
    295c:	df 93       	push	r29
    295e:	cf 93       	push	r28
    2960:	00 d0       	rcall	.+0      	; 0x2962 <LCD_displayString+0x6>
    2962:	0f 92       	push	r0
    2964:	cd b7       	in	r28, 0x3d	; 61
    2966:	de b7       	in	r29, 0x3e	; 62
    2968:	9b 83       	std	Y+3, r25	; 0x03
    296a:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
    296c:	19 82       	std	Y+1, r1	; 0x01
    296e:	0e c0       	rjmp	.+28     	; 0x298c <LCD_displayString+0x30>
	while(Str[i] != '\0')
	{
		LCD_displayCharacter(Str[i]);
    2970:	89 81       	ldd	r24, Y+1	; 0x01
    2972:	28 2f       	mov	r18, r24
    2974:	30 e0       	ldi	r19, 0x00	; 0
    2976:	8a 81       	ldd	r24, Y+2	; 0x02
    2978:	9b 81       	ldd	r25, Y+3	; 0x03
    297a:	fc 01       	movw	r30, r24
    297c:	e2 0f       	add	r30, r18
    297e:	f3 1f       	adc	r31, r19
    2980:	80 81       	ld	r24, Z
    2982:	0e 94 33 10 	call	0x2066	; 0x2066 <LCD_displayCharacter>
		i++;
    2986:	89 81       	ldd	r24, Y+1	; 0x01
    2988:	8f 5f       	subi	r24, 0xFF	; 255
    298a:	89 83       	std	Y+1, r24	; 0x01
 * Display the required string on the screen
 */
void LCD_displayString(const char *Str)
{
	uint8 i = 0;
	while(Str[i] != '\0')
    298c:	89 81       	ldd	r24, Y+1	; 0x01
    298e:	28 2f       	mov	r18, r24
    2990:	30 e0       	ldi	r19, 0x00	; 0
    2992:	8a 81       	ldd	r24, Y+2	; 0x02
    2994:	9b 81       	ldd	r25, Y+3	; 0x03
    2996:	fc 01       	movw	r30, r24
    2998:	e2 0f       	add	r30, r18
    299a:	f3 1f       	adc	r31, r19
    299c:	80 81       	ld	r24, Z
    299e:	88 23       	and	r24, r24
    29a0:	39 f7       	brne	.-50     	; 0x2970 <LCD_displayString+0x14>
	{
		LCD_displayCharacter(*Str);
		Str++;
	}		
	*********************************************************/
}
    29a2:	0f 90       	pop	r0
    29a4:	0f 90       	pop	r0
    29a6:	0f 90       	pop	r0
    29a8:	cf 91       	pop	r28
    29aa:	df 91       	pop	r29
    29ac:	08 95       	ret

000029ae <LCD_moveCursor>:
/*
 * Description :
 * Move the cursor to a specified row and column index on the screen
 */
void LCD_moveCursor(uint8 row,uint8 col)
{
    29ae:	df 93       	push	r29
    29b0:	cf 93       	push	r28
    29b2:	00 d0       	rcall	.+0      	; 0x29b4 <LCD_moveCursor+0x6>
    29b4:	00 d0       	rcall	.+0      	; 0x29b6 <LCD_moveCursor+0x8>
    29b6:	0f 92       	push	r0
    29b8:	cd b7       	in	r28, 0x3d	; 61
    29ba:	de b7       	in	r29, 0x3e	; 62
    29bc:	8a 83       	std	Y+2, r24	; 0x02
    29be:	6b 83       	std	Y+3, r22	; 0x03
	uint8 lcd_memory_address;
	
	/* Calculate the required address in the LCD DDRAM */
	switch(row)
    29c0:	8a 81       	ldd	r24, Y+2	; 0x02
    29c2:	28 2f       	mov	r18, r24
    29c4:	30 e0       	ldi	r19, 0x00	; 0
    29c6:	3d 83       	std	Y+5, r19	; 0x05
    29c8:	2c 83       	std	Y+4, r18	; 0x04
    29ca:	8c 81       	ldd	r24, Y+4	; 0x04
    29cc:	9d 81       	ldd	r25, Y+5	; 0x05
    29ce:	81 30       	cpi	r24, 0x01	; 1
    29d0:	91 05       	cpc	r25, r1
    29d2:	c1 f0       	breq	.+48     	; 0x2a04 <LCD_moveCursor+0x56>
    29d4:	2c 81       	ldd	r18, Y+4	; 0x04
    29d6:	3d 81       	ldd	r19, Y+5	; 0x05
    29d8:	22 30       	cpi	r18, 0x02	; 2
    29da:	31 05       	cpc	r19, r1
    29dc:	2c f4       	brge	.+10     	; 0x29e8 <LCD_moveCursor+0x3a>
    29de:	8c 81       	ldd	r24, Y+4	; 0x04
    29e0:	9d 81       	ldd	r25, Y+5	; 0x05
    29e2:	00 97       	sbiw	r24, 0x00	; 0
    29e4:	61 f0       	breq	.+24     	; 0x29fe <LCD_moveCursor+0x50>
    29e6:	19 c0       	rjmp	.+50     	; 0x2a1a <LCD_moveCursor+0x6c>
    29e8:	2c 81       	ldd	r18, Y+4	; 0x04
    29ea:	3d 81       	ldd	r19, Y+5	; 0x05
    29ec:	22 30       	cpi	r18, 0x02	; 2
    29ee:	31 05       	cpc	r19, r1
    29f0:	69 f0       	breq	.+26     	; 0x2a0c <LCD_moveCursor+0x5e>
    29f2:	8c 81       	ldd	r24, Y+4	; 0x04
    29f4:	9d 81       	ldd	r25, Y+5	; 0x05
    29f6:	83 30       	cpi	r24, 0x03	; 3
    29f8:	91 05       	cpc	r25, r1
    29fa:	61 f0       	breq	.+24     	; 0x2a14 <LCD_moveCursor+0x66>
    29fc:	0e c0       	rjmp	.+28     	; 0x2a1a <LCD_moveCursor+0x6c>
	{
		case 0:
			lcd_memory_address=col;
    29fe:	8b 81       	ldd	r24, Y+3	; 0x03
    2a00:	89 83       	std	Y+1, r24	; 0x01
    2a02:	0b c0       	rjmp	.+22     	; 0x2a1a <LCD_moveCursor+0x6c>
				break;
		case 1:
			lcd_memory_address=col+0x40;
    2a04:	8b 81       	ldd	r24, Y+3	; 0x03
    2a06:	80 5c       	subi	r24, 0xC0	; 192
    2a08:	89 83       	std	Y+1, r24	; 0x01
    2a0a:	07 c0       	rjmp	.+14     	; 0x2a1a <LCD_moveCursor+0x6c>
				break;
		case 2:
			lcd_memory_address=col+0x10;
    2a0c:	8b 81       	ldd	r24, Y+3	; 0x03
    2a0e:	80 5f       	subi	r24, 0xF0	; 240
    2a10:	89 83       	std	Y+1, r24	; 0x01
    2a12:	03 c0       	rjmp	.+6      	; 0x2a1a <LCD_moveCursor+0x6c>
				break;
		case 3:
			lcd_memory_address=col+0x50;
    2a14:	8b 81       	ldd	r24, Y+3	; 0x03
    2a16:	80 5b       	subi	r24, 0xB0	; 176
    2a18:	89 83       	std	Y+1, r24	; 0x01
				break;
	}					
	/* Move the LCD cursor to this specific address */
	LCD_sendCommand(lcd_memory_address | LCD_SET_CURSOR_LOCATION);
    2a1a:	89 81       	ldd	r24, Y+1	; 0x01
    2a1c:	80 68       	ori	r24, 0x80	; 128
    2a1e:	0e 94 b8 0b 	call	0x1770	; 0x1770 <LCD_sendCommand>
}
    2a22:	0f 90       	pop	r0
    2a24:	0f 90       	pop	r0
    2a26:	0f 90       	pop	r0
    2a28:	0f 90       	pop	r0
    2a2a:	0f 90       	pop	r0
    2a2c:	cf 91       	pop	r28
    2a2e:	df 91       	pop	r29
    2a30:	08 95       	ret

00002a32 <LCD_displayStringRowColumn>:
/*
 * Description :
 * Display the required string in a specified row and column index on the screen
 */
void LCD_displayStringRowColumn(uint8 row,uint8 col,const char *Str)
{
    2a32:	df 93       	push	r29
    2a34:	cf 93       	push	r28
    2a36:	00 d0       	rcall	.+0      	; 0x2a38 <LCD_displayStringRowColumn+0x6>
    2a38:	00 d0       	rcall	.+0      	; 0x2a3a <LCD_displayStringRowColumn+0x8>
    2a3a:	cd b7       	in	r28, 0x3d	; 61
    2a3c:	de b7       	in	r29, 0x3e	; 62
    2a3e:	89 83       	std	Y+1, r24	; 0x01
    2a40:	6a 83       	std	Y+2, r22	; 0x02
    2a42:	5c 83       	std	Y+4, r21	; 0x04
    2a44:	4b 83       	std	Y+3, r20	; 0x03
	LCD_moveCursor(row,col); /* go to to the required LCD position */
    2a46:	89 81       	ldd	r24, Y+1	; 0x01
    2a48:	6a 81       	ldd	r22, Y+2	; 0x02
    2a4a:	0e 94 d7 14 	call	0x29ae	; 0x29ae <LCD_moveCursor>
	LCD_displayString(Str); /* display the string */
    2a4e:	8b 81       	ldd	r24, Y+3	; 0x03
    2a50:	9c 81       	ldd	r25, Y+4	; 0x04
    2a52:	0e 94 ae 14 	call	0x295c	; 0x295c <LCD_displayString>
}
    2a56:	0f 90       	pop	r0
    2a58:	0f 90       	pop	r0
    2a5a:	0f 90       	pop	r0
    2a5c:	0f 90       	pop	r0
    2a5e:	cf 91       	pop	r28
    2a60:	df 91       	pop	r29
    2a62:	08 95       	ret

00002a64 <LCD_intgerToString>:
/*
 * Description :
 * Display the required decimal value on the screen
 */
void LCD_intgerToString(int data)
{
    2a64:	df 93       	push	r29
    2a66:	cf 93       	push	r28
    2a68:	cd b7       	in	r28, 0x3d	; 61
    2a6a:	de b7       	in	r29, 0x3e	; 62
    2a6c:	62 97       	sbiw	r28, 0x12	; 18
    2a6e:	0f b6       	in	r0, 0x3f	; 63
    2a70:	f8 94       	cli
    2a72:	de bf       	out	0x3e, r29	; 62
    2a74:	0f be       	out	0x3f, r0	; 63
    2a76:	cd bf       	out	0x3d, r28	; 61
    2a78:	9a 8b       	std	Y+18, r25	; 0x12
    2a7a:	89 8b       	std	Y+17, r24	; 0x11
   char buff[16]; /* String to hold the ASCII result */
   itoa(data,buff,10); /* Use itoa C function to convert the data to its corresponding ASCII value, 10 for decimal */
    2a7c:	89 89       	ldd	r24, Y+17	; 0x11
    2a7e:	9a 89       	ldd	r25, Y+18	; 0x12
    2a80:	9e 01       	movw	r18, r28
    2a82:	2f 5f       	subi	r18, 0xFF	; 255
    2a84:	3f 4f       	sbci	r19, 0xFF	; 255
    2a86:	b9 01       	movw	r22, r18
    2a88:	4a e0       	ldi	r20, 0x0A	; 10
    2a8a:	50 e0       	ldi	r21, 0x00	; 0
    2a8c:	0e 94 47 1d 	call	0x3a8e	; 0x3a8e <itoa>
   LCD_displayString(buff); /* Display the string */
    2a90:	ce 01       	movw	r24, r28
    2a92:	01 96       	adiw	r24, 0x01	; 1
    2a94:	0e 94 ae 14 	call	0x295c	; 0x295c <LCD_displayString>
}
    2a98:	62 96       	adiw	r28, 0x12	; 18
    2a9a:	0f b6       	in	r0, 0x3f	; 63
    2a9c:	f8 94       	cli
    2a9e:	de bf       	out	0x3e, r29	; 62
    2aa0:	0f be       	out	0x3f, r0	; 63
    2aa2:	cd bf       	out	0x3d, r28	; 61
    2aa4:	cf 91       	pop	r28
    2aa6:	df 91       	pop	r29
    2aa8:	08 95       	ret

00002aaa <LCD_clearScreen>:
/*
 * Description :
 * Send the clear screen command
 */
void LCD_clearScreen(void)
{
    2aaa:	df 93       	push	r29
    2aac:	cf 93       	push	r28
    2aae:	cd b7       	in	r28, 0x3d	; 61
    2ab0:	de b7       	in	r29, 0x3e	; 62
	LCD_sendCommand(LCD_CLEAR_COMMAND); /* Send clear display command */
    2ab2:	81 e0       	ldi	r24, 0x01	; 1
    2ab4:	0e 94 b8 0b 	call	0x1770	; 0x1770 <LCD_sendCommand>
}
    2ab8:	cf 91       	pop	r28
    2aba:	df 91       	pop	r29
    2abc:	08 95       	ret

00002abe <KEYPAD_getPressedKey>:
/*******************************************************************************
 *                      Functions Definitions                                  *
 *******************************************************************************/

uint8 KEYPAD_getPressedKey(void)
{
    2abe:	df 93       	push	r29
    2ac0:	cf 93       	push	r28
    2ac2:	cd b7       	in	r28, 0x3d	; 61
    2ac4:	de b7       	in	r29, 0x3e	; 62
    2ac6:	60 97       	sbiw	r28, 0x10	; 16
    2ac8:	0f b6       	in	r0, 0x3f	; 63
    2aca:	f8 94       	cli
    2acc:	de bf       	out	0x3e, r29	; 62
    2ace:	0f be       	out	0x3f, r0	; 63
    2ad0:	cd bf       	out	0x3d, r28	; 61
	uint8 col,row;
	GPIO_setupPinDirection(KEYPAD_ROW_PORT_ID, KEYPAD_FIRST_ROW_PIN_ID, PIN_INPUT);
    2ad2:	81 e0       	ldi	r24, 0x01	; 1
    2ad4:	64 e0       	ldi	r22, 0x04	; 4
    2ad6:	40 e0       	ldi	r20, 0x00	; 0
    2ad8:	0e 94 c8 07 	call	0xf90	; 0xf90 <GPIO_setupPinDirection>
	GPIO_setupPinDirection(KEYPAD_ROW_PORT_ID, KEYPAD_FIRST_ROW_PIN_ID+1, PIN_INPUT);
    2adc:	81 e0       	ldi	r24, 0x01	; 1
    2ade:	65 e0       	ldi	r22, 0x05	; 5
    2ae0:	40 e0       	ldi	r20, 0x00	; 0
    2ae2:	0e 94 c8 07 	call	0xf90	; 0xf90 <GPIO_setupPinDirection>
	GPIO_setupPinDirection(KEYPAD_ROW_PORT_ID, KEYPAD_FIRST_ROW_PIN_ID+2, PIN_INPUT);
    2ae6:	81 e0       	ldi	r24, 0x01	; 1
    2ae8:	66 e0       	ldi	r22, 0x06	; 6
    2aea:	40 e0       	ldi	r20, 0x00	; 0
    2aec:	0e 94 c8 07 	call	0xf90	; 0xf90 <GPIO_setupPinDirection>
	GPIO_setupPinDirection(KEYPAD_ROW_PORT_ID, KEYPAD_FIRST_ROW_PIN_ID+3, PIN_INPUT);
    2af0:	81 e0       	ldi	r24, 0x01	; 1
    2af2:	67 e0       	ldi	r22, 0x07	; 7
    2af4:	40 e0       	ldi	r20, 0x00	; 0
    2af6:	0e 94 c8 07 	call	0xf90	; 0xf90 <GPIO_setupPinDirection>

	GPIO_setupPinDirection(KEYPAD_COL_PORT_ID, KEYPAD_FIRST_COL_PIN_ID, PIN_INPUT);
    2afa:	82 e0       	ldi	r24, 0x02	; 2
    2afc:	64 e0       	ldi	r22, 0x04	; 4
    2afe:	40 e0       	ldi	r20, 0x00	; 0
    2b00:	0e 94 c8 07 	call	0xf90	; 0xf90 <GPIO_setupPinDirection>
	GPIO_setupPinDirection(KEYPAD_COL_PORT_ID, KEYPAD_FIRST_COL_PIN_ID+1, PIN_INPUT);
    2b04:	82 e0       	ldi	r24, 0x02	; 2
    2b06:	65 e0       	ldi	r22, 0x05	; 5
    2b08:	40 e0       	ldi	r20, 0x00	; 0
    2b0a:	0e 94 c8 07 	call	0xf90	; 0xf90 <GPIO_setupPinDirection>
	GPIO_setupPinDirection(KEYPAD_COL_PORT_ID, KEYPAD_FIRST_COL_PIN_ID+2, PIN_INPUT);
    2b0e:	82 e0       	ldi	r24, 0x02	; 2
    2b10:	66 e0       	ldi	r22, 0x06	; 6
    2b12:	40 e0       	ldi	r20, 0x00	; 0
    2b14:	0e 94 c8 07 	call	0xf90	; 0xf90 <GPIO_setupPinDirection>
#if(KEYPAD_NUM_COLS == 4)
	GPIO_setupPinDirection(KEYPAD_COL_PORT_ID, KEYPAD_FIRST_COL_PIN_ID+3, PIN_INPUT);
    2b18:	82 e0       	ldi	r24, 0x02	; 2
    2b1a:	67 e0       	ldi	r22, 0x07	; 7
    2b1c:	40 e0       	ldi	r20, 0x00	; 0
    2b1e:	0e 94 c8 07 	call	0xf90	; 0xf90 <GPIO_setupPinDirection>
#endif
	while(1)
	{
		for(row=0 ; row<KEYPAD_NUM_ROWS ; row++) /* loop for rows */
    2b22:	1f 86       	std	Y+15, r1	; 0x0f
    2b24:	b4 c0       	rjmp	.+360    	; 0x2c8e <KEYPAD_getPressedKey+0x1d0>
		{
			/*
			 * Each time setup the direction for all keypad port as input pins,
			 * except this row will be output pin
			 */
			GPIO_setupPinDirection(KEYPAD_ROW_PORT_ID,KEYPAD_FIRST_ROW_PIN_ID+row,PIN_OUTPUT);
    2b26:	8f 85       	ldd	r24, Y+15	; 0x0f
    2b28:	98 2f       	mov	r25, r24
    2b2a:	9c 5f       	subi	r25, 0xFC	; 252
    2b2c:	81 e0       	ldi	r24, 0x01	; 1
    2b2e:	69 2f       	mov	r22, r25
    2b30:	41 e0       	ldi	r20, 0x01	; 1
    2b32:	0e 94 c8 07 	call	0xf90	; 0xf90 <GPIO_setupPinDirection>

			/* Set/Clear the row output pin */
			GPIO_writePin(KEYPAD_ROW_PORT_ID, KEYPAD_FIRST_ROW_PIN_ID+row, KEYPAD_BUTTON_PRESSED);
    2b36:	8f 85       	ldd	r24, Y+15	; 0x0f
    2b38:	98 2f       	mov	r25, r24
    2b3a:	9c 5f       	subi	r25, 0xFC	; 252
    2b3c:	81 e0       	ldi	r24, 0x01	; 1
    2b3e:	69 2f       	mov	r22, r25
    2b40:	40 e0       	ldi	r20, 0x00	; 0
    2b42:	0e 94 b3 08 	call	0x1166	; 0x1166 <GPIO_writePin>

			for(col=0 ; col<KEYPAD_NUM_COLS ; col++) /* loop for columns */
    2b46:	18 8a       	std	Y+16, r1	; 0x10
    2b48:	22 c0       	rjmp	.+68     	; 0x2b8e <KEYPAD_getPressedKey+0xd0>
			{
				/* Check if the switch is pressed in this column */
				if(GPIO_readPin(KEYPAD_COL_PORT_ID,KEYPAD_FIRST_COL_PIN_ID+col) == KEYPAD_BUTTON_PRESSED)
    2b4a:	88 89       	ldd	r24, Y+16	; 0x10
    2b4c:	98 2f       	mov	r25, r24
    2b4e:	9c 5f       	subi	r25, 0xFC	; 252
    2b50:	82 e0       	ldi	r24, 0x02	; 2
    2b52:	69 2f       	mov	r22, r25
    2b54:	0e 94 9e 09 	call	0x133c	; 0x133c <GPIO_readPin>
    2b58:	88 23       	and	r24, r24
    2b5a:	b1 f4       	brne	.+44     	; 0x2b88 <KEYPAD_getPressedKey+0xca>
						#endif
					#elif (KEYPAD_NUM_COLS == 4)
						#ifdef STANDARD_KEYPAD
							return ((row*KEYPAD_NUM_COLS)+col+1);
						#else
							return KEYPAD_4x4_adjustKeyNumber((row*KEYPAD_NUM_COLS)+col+1);
    2b5c:	8f 85       	ldd	r24, Y+15	; 0x0f
    2b5e:	88 2f       	mov	r24, r24
    2b60:	90 e0       	ldi	r25, 0x00	; 0
    2b62:	88 0f       	add	r24, r24
    2b64:	99 1f       	adc	r25, r25
    2b66:	88 0f       	add	r24, r24
    2b68:	99 1f       	adc	r25, r25
    2b6a:	98 2f       	mov	r25, r24
    2b6c:	88 89       	ldd	r24, Y+16	; 0x10
    2b6e:	89 0f       	add	r24, r25
    2b70:	8f 5f       	subi	r24, 0xFF	; 255
    2b72:	0e 94 4c 16 	call	0x2c98	; 0x2c98 <KEYPAD_4x4_adjustKeyNumber>
			}
			GPIO_setupPinDirection(KEYPAD_ROW_PORT_ID,KEYPAD_FIRST_ROW_PIN_ID+row,PIN_INPUT);
			_delay_ms(20); /* Add small delay to fix CPU load issue in proteus */
		}
	}
}
    2b76:	60 96       	adiw	r28, 0x10	; 16
    2b78:	0f b6       	in	r0, 0x3f	; 63
    2b7a:	f8 94       	cli
    2b7c:	de bf       	out	0x3e, r29	; 62
    2b7e:	0f be       	out	0x3f, r0	; 63
    2b80:	cd bf       	out	0x3d, r28	; 61
    2b82:	cf 91       	pop	r28
    2b84:	df 91       	pop	r29
    2b86:	08 95       	ret
			GPIO_setupPinDirection(KEYPAD_ROW_PORT_ID,KEYPAD_FIRST_ROW_PIN_ID+row,PIN_OUTPUT);

			/* Set/Clear the row output pin */
			GPIO_writePin(KEYPAD_ROW_PORT_ID, KEYPAD_FIRST_ROW_PIN_ID+row, KEYPAD_BUTTON_PRESSED);

			for(col=0 ; col<KEYPAD_NUM_COLS ; col++) /* loop for columns */
    2b88:	88 89       	ldd	r24, Y+16	; 0x10
    2b8a:	8f 5f       	subi	r24, 0xFF	; 255
    2b8c:	88 8b       	std	Y+16, r24	; 0x10
    2b8e:	88 89       	ldd	r24, Y+16	; 0x10
    2b90:	84 30       	cpi	r24, 0x04	; 4
    2b92:	d8 f2       	brcs	.-74     	; 0x2b4a <KEYPAD_getPressedKey+0x8c>
							return KEYPAD_4x4_adjustKeyNumber((row*KEYPAD_NUM_COLS)+col+1);
						#endif
					#endif
				}
			}
			GPIO_setupPinDirection(KEYPAD_ROW_PORT_ID,KEYPAD_FIRST_ROW_PIN_ID+row,PIN_INPUT);
    2b94:	8f 85       	ldd	r24, Y+15	; 0x0f
    2b96:	98 2f       	mov	r25, r24
    2b98:	9c 5f       	subi	r25, 0xFC	; 252
    2b9a:	81 e0       	ldi	r24, 0x01	; 1
    2b9c:	69 2f       	mov	r22, r25
    2b9e:	40 e0       	ldi	r20, 0x00	; 0
    2ba0:	0e 94 c8 07 	call	0xf90	; 0xf90 <GPIO_setupPinDirection>
    2ba4:	80 e0       	ldi	r24, 0x00	; 0
    2ba6:	90 e0       	ldi	r25, 0x00	; 0
    2ba8:	a0 ea       	ldi	r26, 0xA0	; 160
    2baa:	b1 e4       	ldi	r27, 0x41	; 65
    2bac:	8b 87       	std	Y+11, r24	; 0x0b
    2bae:	9c 87       	std	Y+12, r25	; 0x0c
    2bb0:	ad 87       	std	Y+13, r26	; 0x0d
    2bb2:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2bb4:	6b 85       	ldd	r22, Y+11	; 0x0b
    2bb6:	7c 85       	ldd	r23, Y+12	; 0x0c
    2bb8:	8d 85       	ldd	r24, Y+13	; 0x0d
    2bba:	9e 85       	ldd	r25, Y+14	; 0x0e
    2bbc:	20 e0       	ldi	r18, 0x00	; 0
    2bbe:	30 e0       	ldi	r19, 0x00	; 0
    2bc0:	4a ef       	ldi	r20, 0xFA	; 250
    2bc2:	54 e4       	ldi	r21, 0x44	; 68
    2bc4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2bc8:	dc 01       	movw	r26, r24
    2bca:	cb 01       	movw	r24, r22
    2bcc:	8f 83       	std	Y+7, r24	; 0x07
    2bce:	98 87       	std	Y+8, r25	; 0x08
    2bd0:	a9 87       	std	Y+9, r26	; 0x09
    2bd2:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2bd4:	6f 81       	ldd	r22, Y+7	; 0x07
    2bd6:	78 85       	ldd	r23, Y+8	; 0x08
    2bd8:	89 85       	ldd	r24, Y+9	; 0x09
    2bda:	9a 85       	ldd	r25, Y+10	; 0x0a
    2bdc:	20 e0       	ldi	r18, 0x00	; 0
    2bde:	30 e0       	ldi	r19, 0x00	; 0
    2be0:	40 e8       	ldi	r20, 0x80	; 128
    2be2:	5f e3       	ldi	r21, 0x3F	; 63
    2be4:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    2be8:	88 23       	and	r24, r24
    2bea:	2c f4       	brge	.+10     	; 0x2bf6 <KEYPAD_getPressedKey+0x138>
		__ticks = 1;
    2bec:	81 e0       	ldi	r24, 0x01	; 1
    2bee:	90 e0       	ldi	r25, 0x00	; 0
    2bf0:	9e 83       	std	Y+6, r25	; 0x06
    2bf2:	8d 83       	std	Y+5, r24	; 0x05
    2bf4:	3f c0       	rjmp	.+126    	; 0x2c74 <KEYPAD_getPressedKey+0x1b6>
	else if (__tmp > 65535)
    2bf6:	6f 81       	ldd	r22, Y+7	; 0x07
    2bf8:	78 85       	ldd	r23, Y+8	; 0x08
    2bfa:	89 85       	ldd	r24, Y+9	; 0x09
    2bfc:	9a 85       	ldd	r25, Y+10	; 0x0a
    2bfe:	20 e0       	ldi	r18, 0x00	; 0
    2c00:	3f ef       	ldi	r19, 0xFF	; 255
    2c02:	4f e7       	ldi	r20, 0x7F	; 127
    2c04:	57 e4       	ldi	r21, 0x47	; 71
    2c06:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    2c0a:	18 16       	cp	r1, r24
    2c0c:	4c f5       	brge	.+82     	; 0x2c60 <KEYPAD_getPressedKey+0x1a2>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2c0e:	6b 85       	ldd	r22, Y+11	; 0x0b
    2c10:	7c 85       	ldd	r23, Y+12	; 0x0c
    2c12:	8d 85       	ldd	r24, Y+13	; 0x0d
    2c14:	9e 85       	ldd	r25, Y+14	; 0x0e
    2c16:	20 e0       	ldi	r18, 0x00	; 0
    2c18:	30 e0       	ldi	r19, 0x00	; 0
    2c1a:	40 e2       	ldi	r20, 0x20	; 32
    2c1c:	51 e4       	ldi	r21, 0x41	; 65
    2c1e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2c22:	dc 01       	movw	r26, r24
    2c24:	cb 01       	movw	r24, r22
    2c26:	bc 01       	movw	r22, r24
    2c28:	cd 01       	movw	r24, r26
    2c2a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2c2e:	dc 01       	movw	r26, r24
    2c30:	cb 01       	movw	r24, r22
    2c32:	9e 83       	std	Y+6, r25	; 0x06
    2c34:	8d 83       	std	Y+5, r24	; 0x05
    2c36:	0f c0       	rjmp	.+30     	; 0x2c56 <KEYPAD_getPressedKey+0x198>
    2c38:	88 ec       	ldi	r24, 0xC8	; 200
    2c3a:	90 e0       	ldi	r25, 0x00	; 0
    2c3c:	9c 83       	std	Y+4, r25	; 0x04
    2c3e:	8b 83       	std	Y+3, r24	; 0x03
    2c40:	8b 81       	ldd	r24, Y+3	; 0x03
    2c42:	9c 81       	ldd	r25, Y+4	; 0x04
    2c44:	01 97       	sbiw	r24, 0x01	; 1
    2c46:	f1 f7       	brne	.-4      	; 0x2c44 <KEYPAD_getPressedKey+0x186>
    2c48:	9c 83       	std	Y+4, r25	; 0x04
    2c4a:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2c4c:	8d 81       	ldd	r24, Y+5	; 0x05
    2c4e:	9e 81       	ldd	r25, Y+6	; 0x06
    2c50:	01 97       	sbiw	r24, 0x01	; 1
    2c52:	9e 83       	std	Y+6, r25	; 0x06
    2c54:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2c56:	8d 81       	ldd	r24, Y+5	; 0x05
    2c58:	9e 81       	ldd	r25, Y+6	; 0x06
    2c5a:	00 97       	sbiw	r24, 0x00	; 0
    2c5c:	69 f7       	brne	.-38     	; 0x2c38 <KEYPAD_getPressedKey+0x17a>
    2c5e:	14 c0       	rjmp	.+40     	; 0x2c88 <KEYPAD_getPressedKey+0x1ca>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2c60:	6f 81       	ldd	r22, Y+7	; 0x07
    2c62:	78 85       	ldd	r23, Y+8	; 0x08
    2c64:	89 85       	ldd	r24, Y+9	; 0x09
    2c66:	9a 85       	ldd	r25, Y+10	; 0x0a
    2c68:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2c6c:	dc 01       	movw	r26, r24
    2c6e:	cb 01       	movw	r24, r22
    2c70:	9e 83       	std	Y+6, r25	; 0x06
    2c72:	8d 83       	std	Y+5, r24	; 0x05
    2c74:	8d 81       	ldd	r24, Y+5	; 0x05
    2c76:	9e 81       	ldd	r25, Y+6	; 0x06
    2c78:	9a 83       	std	Y+2, r25	; 0x02
    2c7a:	89 83       	std	Y+1, r24	; 0x01
    2c7c:	89 81       	ldd	r24, Y+1	; 0x01
    2c7e:	9a 81       	ldd	r25, Y+2	; 0x02
    2c80:	01 97       	sbiw	r24, 0x01	; 1
    2c82:	f1 f7       	brne	.-4      	; 0x2c80 <KEYPAD_getPressedKey+0x1c2>
    2c84:	9a 83       	std	Y+2, r25	; 0x02
    2c86:	89 83       	std	Y+1, r24	; 0x01
#if(KEYPAD_NUM_COLS == 4)
	GPIO_setupPinDirection(KEYPAD_COL_PORT_ID, KEYPAD_FIRST_COL_PIN_ID+3, PIN_INPUT);
#endif
	while(1)
	{
		for(row=0 ; row<KEYPAD_NUM_ROWS ; row++) /* loop for rows */
    2c88:	8f 85       	ldd	r24, Y+15	; 0x0f
    2c8a:	8f 5f       	subi	r24, 0xFF	; 255
    2c8c:	8f 87       	std	Y+15, r24	; 0x0f
    2c8e:	8f 85       	ldd	r24, Y+15	; 0x0f
    2c90:	84 30       	cpi	r24, 0x04	; 4
    2c92:	08 f4       	brcc	.+2      	; 0x2c96 <KEYPAD_getPressedKey+0x1d8>
    2c94:	48 cf       	rjmp	.-368    	; 0x2b26 <KEYPAD_getPressedKey+0x68>
    2c96:	45 cf       	rjmp	.-374    	; 0x2b22 <KEYPAD_getPressedKey+0x64>

00002c98 <KEYPAD_4x4_adjustKeyNumber>:
/*
 * Description :
 * Update the keypad pressed button value with the correct one in keypad 4x4 shape
 */
static uint8 KEYPAD_4x4_adjustKeyNumber(uint8 button_number)
{
    2c98:	df 93       	push	r29
    2c9a:	cf 93       	push	r28
    2c9c:	00 d0       	rcall	.+0      	; 0x2c9e <KEYPAD_4x4_adjustKeyNumber+0x6>
    2c9e:	00 d0       	rcall	.+0      	; 0x2ca0 <KEYPAD_4x4_adjustKeyNumber+0x8>
    2ca0:	cd b7       	in	r28, 0x3d	; 61
    2ca2:	de b7       	in	r29, 0x3e	; 62
    2ca4:	8a 83       	std	Y+2, r24	; 0x02
	uint8 keypad_button = 0;
    2ca6:	19 82       	std	Y+1, r1	; 0x01
	switch(button_number)
    2ca8:	8a 81       	ldd	r24, Y+2	; 0x02
    2caa:	28 2f       	mov	r18, r24
    2cac:	30 e0       	ldi	r19, 0x00	; 0
    2cae:	3c 83       	std	Y+4, r19	; 0x04
    2cb0:	2b 83       	std	Y+3, r18	; 0x03
    2cb2:	8b 81       	ldd	r24, Y+3	; 0x03
    2cb4:	9c 81       	ldd	r25, Y+4	; 0x04
    2cb6:	88 30       	cpi	r24, 0x08	; 8
    2cb8:	91 05       	cpc	r25, r1
    2cba:	09 f4       	brne	.+2      	; 0x2cbe <KEYPAD_4x4_adjustKeyNumber+0x26>
    2cbc:	70 c0       	rjmp	.+224    	; 0x2d9e <KEYPAD_4x4_adjustKeyNumber+0x106>
    2cbe:	2b 81       	ldd	r18, Y+3	; 0x03
    2cc0:	3c 81       	ldd	r19, Y+4	; 0x04
    2cc2:	29 30       	cpi	r18, 0x09	; 9
    2cc4:	31 05       	cpc	r19, r1
    2cc6:	5c f5       	brge	.+86     	; 0x2d1e <KEYPAD_4x4_adjustKeyNumber+0x86>
    2cc8:	8b 81       	ldd	r24, Y+3	; 0x03
    2cca:	9c 81       	ldd	r25, Y+4	; 0x04
    2ccc:	84 30       	cpi	r24, 0x04	; 4
    2cce:	91 05       	cpc	r25, r1
    2cd0:	09 f4       	brne	.+2      	; 0x2cd4 <KEYPAD_4x4_adjustKeyNumber+0x3c>
    2cd2:	59 c0       	rjmp	.+178    	; 0x2d86 <KEYPAD_4x4_adjustKeyNumber+0xee>
    2cd4:	2b 81       	ldd	r18, Y+3	; 0x03
    2cd6:	3c 81       	ldd	r19, Y+4	; 0x04
    2cd8:	25 30       	cpi	r18, 0x05	; 5
    2cda:	31 05       	cpc	r19, r1
    2cdc:	9c f4       	brge	.+38     	; 0x2d04 <KEYPAD_4x4_adjustKeyNumber+0x6c>
    2cde:	8b 81       	ldd	r24, Y+3	; 0x03
    2ce0:	9c 81       	ldd	r25, Y+4	; 0x04
    2ce2:	82 30       	cpi	r24, 0x02	; 2
    2ce4:	91 05       	cpc	r25, r1
    2ce6:	09 f4       	brne	.+2      	; 0x2cea <KEYPAD_4x4_adjustKeyNumber+0x52>
    2ce8:	48 c0       	rjmp	.+144    	; 0x2d7a <KEYPAD_4x4_adjustKeyNumber+0xe2>
    2cea:	2b 81       	ldd	r18, Y+3	; 0x03
    2cec:	3c 81       	ldd	r19, Y+4	; 0x04
    2cee:	23 30       	cpi	r18, 0x03	; 3
    2cf0:	31 05       	cpc	r19, r1
    2cf2:	0c f0       	brlt	.+2      	; 0x2cf6 <KEYPAD_4x4_adjustKeyNumber+0x5e>
    2cf4:	45 c0       	rjmp	.+138    	; 0x2d80 <KEYPAD_4x4_adjustKeyNumber+0xe8>
    2cf6:	8b 81       	ldd	r24, Y+3	; 0x03
    2cf8:	9c 81       	ldd	r25, Y+4	; 0x04
    2cfa:	81 30       	cpi	r24, 0x01	; 1
    2cfc:	91 05       	cpc	r25, r1
    2cfe:	09 f4       	brne	.+2      	; 0x2d02 <KEYPAD_4x4_adjustKeyNumber+0x6a>
    2d00:	39 c0       	rjmp	.+114    	; 0x2d74 <KEYPAD_4x4_adjustKeyNumber+0xdc>
    2d02:	67 c0       	rjmp	.+206    	; 0x2dd2 <KEYPAD_4x4_adjustKeyNumber+0x13a>
    2d04:	2b 81       	ldd	r18, Y+3	; 0x03
    2d06:	3c 81       	ldd	r19, Y+4	; 0x04
    2d08:	26 30       	cpi	r18, 0x06	; 6
    2d0a:	31 05       	cpc	r19, r1
    2d0c:	09 f4       	brne	.+2      	; 0x2d10 <KEYPAD_4x4_adjustKeyNumber+0x78>
    2d0e:	41 c0       	rjmp	.+130    	; 0x2d92 <KEYPAD_4x4_adjustKeyNumber+0xfa>
    2d10:	8b 81       	ldd	r24, Y+3	; 0x03
    2d12:	9c 81       	ldd	r25, Y+4	; 0x04
    2d14:	87 30       	cpi	r24, 0x07	; 7
    2d16:	91 05       	cpc	r25, r1
    2d18:	0c f0       	brlt	.+2      	; 0x2d1c <KEYPAD_4x4_adjustKeyNumber+0x84>
    2d1a:	3e c0       	rjmp	.+124    	; 0x2d98 <KEYPAD_4x4_adjustKeyNumber+0x100>
    2d1c:	37 c0       	rjmp	.+110    	; 0x2d8c <KEYPAD_4x4_adjustKeyNumber+0xf4>
    2d1e:	2b 81       	ldd	r18, Y+3	; 0x03
    2d20:	3c 81       	ldd	r19, Y+4	; 0x04
    2d22:	2c 30       	cpi	r18, 0x0C	; 12
    2d24:	31 05       	cpc	r19, r1
    2d26:	09 f4       	brne	.+2      	; 0x2d2a <KEYPAD_4x4_adjustKeyNumber+0x92>
    2d28:	46 c0       	rjmp	.+140    	; 0x2db6 <KEYPAD_4x4_adjustKeyNumber+0x11e>
    2d2a:	8b 81       	ldd	r24, Y+3	; 0x03
    2d2c:	9c 81       	ldd	r25, Y+4	; 0x04
    2d2e:	8d 30       	cpi	r24, 0x0D	; 13
    2d30:	91 05       	cpc	r25, r1
    2d32:	5c f4       	brge	.+22     	; 0x2d4a <KEYPAD_4x4_adjustKeyNumber+0xb2>
    2d34:	2b 81       	ldd	r18, Y+3	; 0x03
    2d36:	3c 81       	ldd	r19, Y+4	; 0x04
    2d38:	2a 30       	cpi	r18, 0x0A	; 10
    2d3a:	31 05       	cpc	r19, r1
    2d3c:	b1 f1       	breq	.+108    	; 0x2daa <KEYPAD_4x4_adjustKeyNumber+0x112>
    2d3e:	8b 81       	ldd	r24, Y+3	; 0x03
    2d40:	9c 81       	ldd	r25, Y+4	; 0x04
    2d42:	8b 30       	cpi	r24, 0x0B	; 11
    2d44:	91 05       	cpc	r25, r1
    2d46:	a4 f5       	brge	.+104    	; 0x2db0 <KEYPAD_4x4_adjustKeyNumber+0x118>
    2d48:	2d c0       	rjmp	.+90     	; 0x2da4 <KEYPAD_4x4_adjustKeyNumber+0x10c>
    2d4a:	2b 81       	ldd	r18, Y+3	; 0x03
    2d4c:	3c 81       	ldd	r19, Y+4	; 0x04
    2d4e:	2e 30       	cpi	r18, 0x0E	; 14
    2d50:	31 05       	cpc	r19, r1
    2d52:	b9 f1       	breq	.+110    	; 0x2dc2 <KEYPAD_4x4_adjustKeyNumber+0x12a>
    2d54:	8b 81       	ldd	r24, Y+3	; 0x03
    2d56:	9c 81       	ldd	r25, Y+4	; 0x04
    2d58:	8e 30       	cpi	r24, 0x0E	; 14
    2d5a:	91 05       	cpc	r25, r1
    2d5c:	7c f1       	brlt	.+94     	; 0x2dbc <KEYPAD_4x4_adjustKeyNumber+0x124>
    2d5e:	2b 81       	ldd	r18, Y+3	; 0x03
    2d60:	3c 81       	ldd	r19, Y+4	; 0x04
    2d62:	2f 30       	cpi	r18, 0x0F	; 15
    2d64:	31 05       	cpc	r19, r1
    2d66:	79 f1       	breq	.+94     	; 0x2dc6 <KEYPAD_4x4_adjustKeyNumber+0x12e>
    2d68:	8b 81       	ldd	r24, Y+3	; 0x03
    2d6a:	9c 81       	ldd	r25, Y+4	; 0x04
    2d6c:	80 31       	cpi	r24, 0x10	; 16
    2d6e:	91 05       	cpc	r25, r1
    2d70:	69 f1       	breq	.+90     	; 0x2dcc <KEYPAD_4x4_adjustKeyNumber+0x134>
    2d72:	2f c0       	rjmp	.+94     	; 0x2dd2 <KEYPAD_4x4_adjustKeyNumber+0x13a>
	{
		case 1: keypad_button = 7;
    2d74:	87 e0       	ldi	r24, 0x07	; 7
    2d76:	89 83       	std	Y+1, r24	; 0x01
    2d78:	2e c0       	rjmp	.+92     	; 0x2dd6 <KEYPAD_4x4_adjustKeyNumber+0x13e>
				break;
		case 2: keypad_button = 8;
    2d7a:	88 e0       	ldi	r24, 0x08	; 8
    2d7c:	89 83       	std	Y+1, r24	; 0x01
    2d7e:	2b c0       	rjmp	.+86     	; 0x2dd6 <KEYPAD_4x4_adjustKeyNumber+0x13e>
				break;
		case 3: keypad_button = 9;
    2d80:	89 e0       	ldi	r24, 0x09	; 9
    2d82:	89 83       	std	Y+1, r24	; 0x01
    2d84:	28 c0       	rjmp	.+80     	; 0x2dd6 <KEYPAD_4x4_adjustKeyNumber+0x13e>
				break;
		case 4: keypad_button = '%'; // ASCII Code of %
    2d86:	85 e2       	ldi	r24, 0x25	; 37
    2d88:	89 83       	std	Y+1, r24	; 0x01
    2d8a:	25 c0       	rjmp	.+74     	; 0x2dd6 <KEYPAD_4x4_adjustKeyNumber+0x13e>
				break;
		case 5: keypad_button = 4;
    2d8c:	84 e0       	ldi	r24, 0x04	; 4
    2d8e:	89 83       	std	Y+1, r24	; 0x01
    2d90:	22 c0       	rjmp	.+68     	; 0x2dd6 <KEYPAD_4x4_adjustKeyNumber+0x13e>
				break;
		case 6: keypad_button = 5;
    2d92:	85 e0       	ldi	r24, 0x05	; 5
    2d94:	89 83       	std	Y+1, r24	; 0x01
    2d96:	1f c0       	rjmp	.+62     	; 0x2dd6 <KEYPAD_4x4_adjustKeyNumber+0x13e>
				break;
		case 7: keypad_button = 6;
    2d98:	86 e0       	ldi	r24, 0x06	; 6
    2d9a:	89 83       	std	Y+1, r24	; 0x01
    2d9c:	1c c0       	rjmp	.+56     	; 0x2dd6 <KEYPAD_4x4_adjustKeyNumber+0x13e>
				break;
		case 8: keypad_button = '*'; /* ASCII Code of '*' */
    2d9e:	8a e2       	ldi	r24, 0x2A	; 42
    2da0:	89 83       	std	Y+1, r24	; 0x01
    2da2:	19 c0       	rjmp	.+50     	; 0x2dd6 <KEYPAD_4x4_adjustKeyNumber+0x13e>
				break;
		case 9: keypad_button = 1;
    2da4:	81 e0       	ldi	r24, 0x01	; 1
    2da6:	89 83       	std	Y+1, r24	; 0x01
    2da8:	16 c0       	rjmp	.+44     	; 0x2dd6 <KEYPAD_4x4_adjustKeyNumber+0x13e>
				break;
		case 10: keypad_button = 2;
    2daa:	82 e0       	ldi	r24, 0x02	; 2
    2dac:	89 83       	std	Y+1, r24	; 0x01
    2dae:	13 c0       	rjmp	.+38     	; 0x2dd6 <KEYPAD_4x4_adjustKeyNumber+0x13e>
				break;
		case 11: keypad_button = 3;
    2db0:	83 e0       	ldi	r24, 0x03	; 3
    2db2:	89 83       	std	Y+1, r24	; 0x01
    2db4:	10 c0       	rjmp	.+32     	; 0x2dd6 <KEYPAD_4x4_adjustKeyNumber+0x13e>
				break;
		case 12: keypad_button = '-'; /* ASCII Code of '-' */
    2db6:	8d e2       	ldi	r24, 0x2D	; 45
    2db8:	89 83       	std	Y+1, r24	; 0x01
    2dba:	0d c0       	rjmp	.+26     	; 0x2dd6 <KEYPAD_4x4_adjustKeyNumber+0x13e>
				break;
		case 13: keypad_button = 13;  /* ASCII of Enter */
    2dbc:	8d e0       	ldi	r24, 0x0D	; 13
    2dbe:	89 83       	std	Y+1, r24	; 0x01
    2dc0:	0a c0       	rjmp	.+20     	; 0x2dd6 <KEYPAD_4x4_adjustKeyNumber+0x13e>
				break;
		case 14: keypad_button = 0;
    2dc2:	19 82       	std	Y+1, r1	; 0x01
    2dc4:	08 c0       	rjmp	.+16     	; 0x2dd6 <KEYPAD_4x4_adjustKeyNumber+0x13e>
				break;
		case 15: keypad_button = '='; /* ASCII Code of '=' */
    2dc6:	8d e3       	ldi	r24, 0x3D	; 61
    2dc8:	89 83       	std	Y+1, r24	; 0x01
    2dca:	05 c0       	rjmp	.+10     	; 0x2dd6 <KEYPAD_4x4_adjustKeyNumber+0x13e>
				break;
		case 16: keypad_button = '+'; /* ASCII Code of '+' */
    2dcc:	8b e2       	ldi	r24, 0x2B	; 43
    2dce:	89 83       	std	Y+1, r24	; 0x01
    2dd0:	02 c0       	rjmp	.+4      	; 0x2dd6 <KEYPAD_4x4_adjustKeyNumber+0x13e>
				break;
		default: keypad_button = button_number;
    2dd2:	8a 81       	ldd	r24, Y+2	; 0x02
    2dd4:	89 83       	std	Y+1, r24	; 0x01
				break;
	}
	return keypad_button;
    2dd6:	89 81       	ldd	r24, Y+1	; 0x01
}
    2dd8:	0f 90       	pop	r0
    2dda:	0f 90       	pop	r0
    2ddc:	0f 90       	pop	r0
    2dde:	0f 90       	pop	r0
    2de0:	cf 91       	pop	r28
    2de2:	df 91       	pop	r29
    2de4:	08 95       	ret

00002de6 <main>:
/* Global flag */
uint8 volatile g_errorCount = 0;

/////////////////////////////////////////////////////////////////////////////

int main() {
    2de6:	df 93       	push	r29
    2de8:	cf 93       	push	r28
    2dea:	cd b7       	in	r28, 0x3d	; 61
    2dec:	de b7       	in	r29, 0x3e	; 62
    2dee:	c3 54       	subi	r28, 0x43	; 67
    2df0:	d0 40       	sbci	r29, 0x00	; 0
    2df2:	0f b6       	in	r0, 0x3f	; 63
    2df4:	f8 94       	cli
    2df6:	de bf       	out	0x3e, r29	; 62
    2df8:	0f be       	out	0x3f, r0	; 63
    2dfa:	cd bf       	out	0x3d, r28	; 61
	LCD_init();
    2dfc:	0e 94 06 0b 	call	0x160c	; 0x160c <LCD_init>
	UART_ConfigType UARTConfiguration = { BIT_8, Disabled, BIT_1, 9600 };
    2e00:	9e 01       	movw	r18, r28
    2e02:	25 5d       	subi	r18, 0xD5	; 213
    2e04:	3f 4f       	sbci	r19, 0xFF	; 255
    2e06:	3b af       	std	Y+59, r19	; 0x3b
    2e08:	2a af       	std	Y+58, r18	; 0x3a
    2e0a:	82 e4       	ldi	r24, 0x42	; 66
    2e0c:	91 e0       	ldi	r25, 0x01	; 1
    2e0e:	9d af       	std	Y+61, r25	; 0x3d
    2e10:	8c af       	std	Y+60, r24	; 0x3c
    2e12:	97 e0       	ldi	r25, 0x07	; 7
    2e14:	9e af       	std	Y+62, r25	; 0x3e
    2e16:	ec ad       	ldd	r30, Y+60	; 0x3c
    2e18:	fd ad       	ldd	r31, Y+61	; 0x3d
    2e1a:	00 80       	ld	r0, Z
    2e1c:	2c ad       	ldd	r18, Y+60	; 0x3c
    2e1e:	3d ad       	ldd	r19, Y+61	; 0x3d
    2e20:	2f 5f       	subi	r18, 0xFF	; 255
    2e22:	3f 4f       	sbci	r19, 0xFF	; 255
    2e24:	3d af       	std	Y+61, r19	; 0x3d
    2e26:	2c af       	std	Y+60, r18	; 0x3c
    2e28:	ea ad       	ldd	r30, Y+58	; 0x3a
    2e2a:	fb ad       	ldd	r31, Y+59	; 0x3b
    2e2c:	00 82       	st	Z, r0
    2e2e:	2a ad       	ldd	r18, Y+58	; 0x3a
    2e30:	3b ad       	ldd	r19, Y+59	; 0x3b
    2e32:	2f 5f       	subi	r18, 0xFF	; 255
    2e34:	3f 4f       	sbci	r19, 0xFF	; 255
    2e36:	3b af       	std	Y+59, r19	; 0x3b
    2e38:	2a af       	std	Y+58, r18	; 0x3a
    2e3a:	3e ad       	ldd	r19, Y+62	; 0x3e
    2e3c:	31 50       	subi	r19, 0x01	; 1
    2e3e:	3e af       	std	Y+62, r19	; 0x3e
    2e40:	8e ad       	ldd	r24, Y+62	; 0x3e
    2e42:	88 23       	and	r24, r24
    2e44:	41 f7       	brne	.-48     	; 0x2e16 <main+0x30>
	UART_init(&UARTConfiguration);
    2e46:	ce 01       	movw	r24, r28
    2e48:	8b 96       	adiw	r24, 0x2b	; 43
    2e4a:	0e 94 a3 05 	call	0xb46	; 0xb46 <UART_init>
	Timer1_ConfigType TimerConfiguration = { 0, 31250, CLK_256, COMPARE };
    2e4e:	fe 01       	movw	r30, r28
    2e50:	f2 96       	adiw	r30, 0x32	; 50
    2e52:	21 96       	adiw	r28, 0x01	; 1
    2e54:	ff af       	std	Y+63, r31	; 0x3f
    2e56:	ee af       	std	Y+62, r30	; 0x3e
    2e58:	21 97       	sbiw	r28, 0x01	; 1
    2e5a:	2c e3       	ldi	r18, 0x3C	; 60
    2e5c:	31 e0       	ldi	r19, 0x01	; 1
    2e5e:	23 96       	adiw	r28, 0x03	; 3
    2e60:	3f af       	std	Y+63, r19	; 0x3f
    2e62:	2e af       	std	Y+62, r18	; 0x3e
    2e64:	23 97       	sbiw	r28, 0x03	; 3
    2e66:	36 e0       	ldi	r19, 0x06	; 6
    2e68:	24 96       	adiw	r28, 0x04	; 4
    2e6a:	3f af       	std	Y+63, r19	; 0x3f
    2e6c:	24 97       	sbiw	r28, 0x04	; 4
    2e6e:	23 96       	adiw	r28, 0x03	; 3
    2e70:	ee ad       	ldd	r30, Y+62	; 0x3e
    2e72:	ff ad       	ldd	r31, Y+63	; 0x3f
    2e74:	23 97       	sbiw	r28, 0x03	; 3
    2e76:	00 80       	ld	r0, Z
    2e78:	23 96       	adiw	r28, 0x03	; 3
    2e7a:	2e ad       	ldd	r18, Y+62	; 0x3e
    2e7c:	3f ad       	ldd	r19, Y+63	; 0x3f
    2e7e:	23 97       	sbiw	r28, 0x03	; 3
    2e80:	2f 5f       	subi	r18, 0xFF	; 255
    2e82:	3f 4f       	sbci	r19, 0xFF	; 255
    2e84:	23 96       	adiw	r28, 0x03	; 3
    2e86:	3f af       	std	Y+63, r19	; 0x3f
    2e88:	2e af       	std	Y+62, r18	; 0x3e
    2e8a:	23 97       	sbiw	r28, 0x03	; 3
    2e8c:	21 96       	adiw	r28, 0x01	; 1
    2e8e:	ee ad       	ldd	r30, Y+62	; 0x3e
    2e90:	ff ad       	ldd	r31, Y+63	; 0x3f
    2e92:	21 97       	sbiw	r28, 0x01	; 1
    2e94:	00 82       	st	Z, r0
    2e96:	21 96       	adiw	r28, 0x01	; 1
    2e98:	2e ad       	ldd	r18, Y+62	; 0x3e
    2e9a:	3f ad       	ldd	r19, Y+63	; 0x3f
    2e9c:	21 97       	sbiw	r28, 0x01	; 1
    2e9e:	2f 5f       	subi	r18, 0xFF	; 255
    2ea0:	3f 4f       	sbci	r19, 0xFF	; 255
    2ea2:	21 96       	adiw	r28, 0x01	; 1
    2ea4:	3f af       	std	Y+63, r19	; 0x3f
    2ea6:	2e af       	std	Y+62, r18	; 0x3e
    2ea8:	21 97       	sbiw	r28, 0x01	; 1
    2eaa:	24 96       	adiw	r28, 0x04	; 4
    2eac:	3f ad       	ldd	r19, Y+63	; 0x3f
    2eae:	24 97       	sbiw	r28, 0x04	; 4
    2eb0:	31 50       	subi	r19, 0x01	; 1
    2eb2:	24 96       	adiw	r28, 0x04	; 4
    2eb4:	3f af       	std	Y+63, r19	; 0x3f
    2eb6:	24 97       	sbiw	r28, 0x04	; 4
    2eb8:	24 96       	adiw	r28, 0x04	; 4
    2eba:	8f ad       	ldd	r24, Y+63	; 0x3f
    2ebc:	24 97       	sbiw	r28, 0x04	; 4
    2ebe:	88 23       	and	r24, r24
    2ec0:	b1 f6       	brne	.-84     	; 0x2e6e <main+0x88>
	Timer1_setCallBack(TimerCounterCallBack);
    2ec2:	87 e4       	ldi	r24, 0x47	; 71
    2ec4:	9c e1       	ldi	r25, 0x1C	; 28
    2ec6:	0e 94 a1 07 	call	0xf42	; 0xf42 <Timer1_setCallBack>

	UART_sendByte(HMI_ECU_READY);
    2eca:	80 e1       	ldi	r24, 0x10	; 16
    2ecc:	0e 94 4a 06 	call	0xc94	; 0xc94 <UART_sendByte>
	while (UART_receiveByte() != CONTROL_ECU_READY) {
    2ed0:	0e 94 3b 06 	call	0xc76	; 0xc76 <UART_receiveByte>
    2ed4:	80 32       	cpi	r24, 0x20	; 32
    2ed6:	e1 f7       	brne	.-8      	; 0x2ed0 <main+0xea>
	}

	while (1) {
		g_uart_order = UART_receiveByte();
    2ed8:	0e 94 3b 06 	call	0xc76	; 0xc76 <UART_receiveByte>
    2edc:	80 93 4c 01 	sts	0x014C, r24
		switch (g_uart_order) {
    2ee0:	80 91 4c 01 	lds	r24, 0x014C
    2ee4:	e8 2f       	mov	r30, r24
    2ee6:	f0 e0       	ldi	r31, 0x00	; 0
    2ee8:	f9 af       	std	Y+57, r31	; 0x39
    2eea:	e8 af       	std	Y+56, r30	; 0x38
    2eec:	28 ad       	ldd	r18, Y+56	; 0x38
    2eee:	39 ad       	ldd	r19, Y+57	; 0x39
    2ef0:	29 34       	cpi	r18, 0x49	; 73
    2ef2:	31 05       	cpc	r19, r1
    2ef4:	09 f4       	brne	.+2      	; 0x2ef8 <main+0x112>
    2ef6:	c5 c0       	rjmp	.+394    	; 0x3082 <main+0x29c>
    2ef8:	88 ad       	ldd	r24, Y+56	; 0x38
    2efa:	99 ad       	ldd	r25, Y+57	; 0x39
    2efc:	8a 34       	cpi	r24, 0x4A	; 74
    2efe:	91 05       	cpc	r25, r1
    2f00:	8c f4       	brge	.+34     	; 0x2f24 <main+0x13e>
    2f02:	e8 ad       	ldd	r30, Y+56	; 0x38
    2f04:	f9 ad       	ldd	r31, Y+57	; 0x39
    2f06:	e4 34       	cpi	r30, 0x44	; 68
    2f08:	f1 05       	cpc	r31, r1
    2f0a:	a1 f1       	breq	.+104    	; 0x2f74 <main+0x18e>
    2f0c:	28 ad       	ldd	r18, Y+56	; 0x38
    2f0e:	39 ad       	ldd	r19, Y+57	; 0x39
    2f10:	25 34       	cpi	r18, 0x45	; 69
    2f12:	31 05       	cpc	r19, r1
    2f14:	e1 f0       	breq	.+56     	; 0x2f4e <main+0x168>
    2f16:	88 ad       	ldd	r24, Y+56	; 0x38
    2f18:	99 ad       	ldd	r25, Y+57	; 0x39
    2f1a:	81 34       	cpi	r24, 0x41	; 65
    2f1c:	91 05       	cpc	r25, r1
    2f1e:	09 f4       	brne	.+2      	; 0x2f22 <main+0x13c>
    2f20:	32 c1       	rjmp	.+612    	; 0x3186 <main+0x3a0>
    2f22:	da cf       	rjmp	.-76     	; 0x2ed8 <main+0xf2>
    2f24:	e8 ad       	ldd	r30, Y+56	; 0x38
    2f26:	f9 ad       	ldd	r31, Y+57	; 0x39
    2f28:	ef 34       	cpi	r30, 0x4F	; 79
    2f2a:	f1 05       	cpc	r31, r1
    2f2c:	09 f4       	brne	.+2      	; 0x2f30 <main+0x14a>
    2f2e:	1a c2       	rjmp	.+1076   	; 0x3364 <main+0x57e>
    2f30:	28 ad       	ldd	r18, Y+56	; 0x38
    2f32:	39 ad       	ldd	r19, Y+57	; 0x39
    2f34:	27 36       	cpi	r18, 0x67	; 103
    2f36:	31 05       	cpc	r19, r1
    2f38:	39 f0       	breq	.+14     	; 0x2f48 <main+0x162>
    2f3a:	88 ad       	ldd	r24, Y+56	; 0x38
    2f3c:	99 ad       	ldd	r25, Y+57	; 0x39
    2f3e:	8d 34       	cpi	r24, 0x4D	; 77
    2f40:	91 05       	cpc	r25, r1
    2f42:	09 f4       	brne	.+2      	; 0x2f46 <main+0x160>
    2f44:	2c c1       	rjmp	.+600    	; 0x319e <main+0x3b8>
    2f46:	c8 cf       	rjmp	.-112    	; 0x2ed8 <main+0xf2>

		case MainMenu:
			SYS_MainMenu_HMI();
    2f48:	0e 94 fd 1b 	call	0x37fa	; 0x37fa <SYS_MainMenu_HMI>
    2f4c:	c5 cf       	rjmp	.-118    	; 0x2ed8 <main+0xf2>
			break;

		case SetNewPassword:
			g_uart_order = 0;
    2f4e:	10 92 4c 01 	sts	0x014C, r1
			SYS_Create_Password_HMI();
    2f52:	0e 94 d6 19 	call	0x33ac	; 0x33ac <SYS_Create_Password_HMI>
			////////////////////////////////
			UART_sendByte(Password1Ready);
    2f56:	84 e4       	ldi	r24, 0x44	; 68
    2f58:	0e 94 4a 06 	call	0xc94	; 0xc94 <UART_sendByte>
			SYS_Send_Password_HMI(passArray1);
    2f5c:	80 e5       	ldi	r24, 0x50	; 80
    2f5e:	91 e0       	ldi	r25, 0x01	; 1
    2f60:	0e 94 31 1b 	call	0x3662	; 0x3662 <SYS_Send_Password_HMI>
			UART_sendByte(Password2Ready);
    2f64:	85 e6       	ldi	r24, 0x65	; 101
    2f66:	0e 94 4a 06 	call	0xc94	; 0xc94 <UART_sendByte>
			SYS_Send_Password_HMI(passArray2);
    2f6a:	8a e5       	ldi	r24, 0x5A	; 90
    2f6c:	91 e0       	ldi	r25, 0x01	; 1
    2f6e:	0e 94 31 1b 	call	0x3662	; 0x3662 <SYS_Send_Password_HMI>
    2f72:	b2 cf       	rjmp	.-156    	; 0x2ed8 <main+0xf2>
			//////////////////////////////////
			break;
		case PasswordUnmatched:
			g_uart_order = 0;
    2f74:	10 92 4c 01 	sts	0x014C, r1
			LCD_clearScreen();
    2f78:	0e 94 55 15 	call	0x2aaa	; 0x2aaa <LCD_clearScreen>
			LCD_displayStringRowColumn(0, 0, "Password");
    2f7c:	20 e6       	ldi	r18, 0x60	; 96
    2f7e:	30 e0       	ldi	r19, 0x00	; 0
    2f80:	80 e0       	ldi	r24, 0x00	; 0
    2f82:	60 e0       	ldi	r22, 0x00	; 0
    2f84:	a9 01       	movw	r20, r18
    2f86:	0e 94 19 15 	call	0x2a32	; 0x2a32 <LCD_displayStringRowColumn>
			LCD_displayStringRowColumn(1, 0, "Unmatched");
    2f8a:	29 e6       	ldi	r18, 0x69	; 105
    2f8c:	30 e0       	ldi	r19, 0x00	; 0
    2f8e:	81 e0       	ldi	r24, 0x01	; 1
    2f90:	60 e0       	ldi	r22, 0x00	; 0
    2f92:	a9 01       	movw	r20, r18
    2f94:	0e 94 19 15 	call	0x2a32	; 0x2a32 <LCD_displayStringRowColumn>
    2f98:	80 e0       	ldi	r24, 0x00	; 0
    2f9a:	90 e8       	ldi	r25, 0x80	; 128
    2f9c:	ab eb       	ldi	r26, 0xBB	; 187
    2f9e:	b4 e4       	ldi	r27, 0x44	; 68
    2fa0:	8f a3       	std	Y+39, r24	; 0x27
    2fa2:	98 a7       	std	Y+40, r25	; 0x28
    2fa4:	a9 a7       	std	Y+41, r26	; 0x29
    2fa6:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2fa8:	6f a1       	ldd	r22, Y+39	; 0x27
    2faa:	78 a5       	ldd	r23, Y+40	; 0x28
    2fac:	89 a5       	ldd	r24, Y+41	; 0x29
    2fae:	9a a5       	ldd	r25, Y+42	; 0x2a
    2fb0:	20 e0       	ldi	r18, 0x00	; 0
    2fb2:	30 e0       	ldi	r19, 0x00	; 0
    2fb4:	4a ef       	ldi	r20, 0xFA	; 250
    2fb6:	54 e4       	ldi	r21, 0x44	; 68
    2fb8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2fbc:	dc 01       	movw	r26, r24
    2fbe:	cb 01       	movw	r24, r22
    2fc0:	8b a3       	std	Y+35, r24	; 0x23
    2fc2:	9c a3       	std	Y+36, r25	; 0x24
    2fc4:	ad a3       	std	Y+37, r26	; 0x25
    2fc6:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    2fc8:	6b a1       	ldd	r22, Y+35	; 0x23
    2fca:	7c a1       	ldd	r23, Y+36	; 0x24
    2fcc:	8d a1       	ldd	r24, Y+37	; 0x25
    2fce:	9e a1       	ldd	r25, Y+38	; 0x26
    2fd0:	20 e0       	ldi	r18, 0x00	; 0
    2fd2:	30 e0       	ldi	r19, 0x00	; 0
    2fd4:	40 e8       	ldi	r20, 0x80	; 128
    2fd6:	5f e3       	ldi	r21, 0x3F	; 63
    2fd8:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    2fdc:	88 23       	and	r24, r24
    2fde:	2c f4       	brge	.+10     	; 0x2fea <main+0x204>
		__ticks = 1;
    2fe0:	81 e0       	ldi	r24, 0x01	; 1
    2fe2:	90 e0       	ldi	r25, 0x00	; 0
    2fe4:	9a a3       	std	Y+34, r25	; 0x22
    2fe6:	89 a3       	std	Y+33, r24	; 0x21
    2fe8:	3f c0       	rjmp	.+126    	; 0x3068 <main+0x282>
	else if (__tmp > 65535)
    2fea:	6b a1       	ldd	r22, Y+35	; 0x23
    2fec:	7c a1       	ldd	r23, Y+36	; 0x24
    2fee:	8d a1       	ldd	r24, Y+37	; 0x25
    2ff0:	9e a1       	ldd	r25, Y+38	; 0x26
    2ff2:	20 e0       	ldi	r18, 0x00	; 0
    2ff4:	3f ef       	ldi	r19, 0xFF	; 255
    2ff6:	4f e7       	ldi	r20, 0x7F	; 127
    2ff8:	57 e4       	ldi	r21, 0x47	; 71
    2ffa:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    2ffe:	18 16       	cp	r1, r24
    3000:	4c f5       	brge	.+82     	; 0x3054 <main+0x26e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3002:	6f a1       	ldd	r22, Y+39	; 0x27
    3004:	78 a5       	ldd	r23, Y+40	; 0x28
    3006:	89 a5       	ldd	r24, Y+41	; 0x29
    3008:	9a a5       	ldd	r25, Y+42	; 0x2a
    300a:	20 e0       	ldi	r18, 0x00	; 0
    300c:	30 e0       	ldi	r19, 0x00	; 0
    300e:	40 e2       	ldi	r20, 0x20	; 32
    3010:	51 e4       	ldi	r21, 0x41	; 65
    3012:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3016:	dc 01       	movw	r26, r24
    3018:	cb 01       	movw	r24, r22
    301a:	bc 01       	movw	r22, r24
    301c:	cd 01       	movw	r24, r26
    301e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3022:	dc 01       	movw	r26, r24
    3024:	cb 01       	movw	r24, r22
    3026:	9a a3       	std	Y+34, r25	; 0x22
    3028:	89 a3       	std	Y+33, r24	; 0x21
    302a:	0f c0       	rjmp	.+30     	; 0x304a <main+0x264>
    302c:	88 ec       	ldi	r24, 0xC8	; 200
    302e:	90 e0       	ldi	r25, 0x00	; 0
    3030:	98 a3       	std	Y+32, r25	; 0x20
    3032:	8f 8f       	std	Y+31, r24	; 0x1f
    3034:	8f 8d       	ldd	r24, Y+31	; 0x1f
    3036:	98 a1       	ldd	r25, Y+32	; 0x20
    3038:	01 97       	sbiw	r24, 0x01	; 1
    303a:	f1 f7       	brne	.-4      	; 0x3038 <main+0x252>
    303c:	98 a3       	std	Y+32, r25	; 0x20
    303e:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3040:	89 a1       	ldd	r24, Y+33	; 0x21
    3042:	9a a1       	ldd	r25, Y+34	; 0x22
    3044:	01 97       	sbiw	r24, 0x01	; 1
    3046:	9a a3       	std	Y+34, r25	; 0x22
    3048:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    304a:	89 a1       	ldd	r24, Y+33	; 0x21
    304c:	9a a1       	ldd	r25, Y+34	; 0x22
    304e:	00 97       	sbiw	r24, 0x00	; 0
    3050:	69 f7       	brne	.-38     	; 0x302c <main+0x246>
    3052:	14 c0       	rjmp	.+40     	; 0x307c <main+0x296>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3054:	6b a1       	ldd	r22, Y+35	; 0x23
    3056:	7c a1       	ldd	r23, Y+36	; 0x24
    3058:	8d a1       	ldd	r24, Y+37	; 0x25
    305a:	9e a1       	ldd	r25, Y+38	; 0x26
    305c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3060:	dc 01       	movw	r26, r24
    3062:	cb 01       	movw	r24, r22
    3064:	9a a3       	std	Y+34, r25	; 0x22
    3066:	89 a3       	std	Y+33, r24	; 0x21
    3068:	89 a1       	ldd	r24, Y+33	; 0x21
    306a:	9a a1       	ldd	r25, Y+34	; 0x22
    306c:	9e 8f       	std	Y+30, r25	; 0x1e
    306e:	8d 8f       	std	Y+29, r24	; 0x1d
    3070:	8d 8d       	ldd	r24, Y+29	; 0x1d
    3072:	9e 8d       	ldd	r25, Y+30	; 0x1e
    3074:	01 97       	sbiw	r24, 0x01	; 1
    3076:	f1 f7       	brne	.-4      	; 0x3074 <main+0x28e>
    3078:	9e 8f       	std	Y+30, r25	; 0x1e
    307a:	8d 8f       	std	Y+29, r24	; 0x1d
			_delay_ms(1500);
			LCD_clearScreen();
    307c:	0e 94 55 15 	call	0x2aaa	; 0x2aaa <LCD_clearScreen>
    3080:	2b cf       	rjmp	.-426    	; 0x2ed8 <main+0xf2>
			break;
		case PasswordMatched:
			g_uart_order = 0;
    3082:	10 92 4c 01 	sts	0x014C, r1
			LCD_clearScreen();
    3086:	0e 94 55 15 	call	0x2aaa	; 0x2aaa <LCD_clearScreen>
			LCD_displayStringRowColumn(1, 0, "Correct");
    308a:	23 e7       	ldi	r18, 0x73	; 115
    308c:	30 e0       	ldi	r19, 0x00	; 0
    308e:	81 e0       	ldi	r24, 0x01	; 1
    3090:	60 e0       	ldi	r22, 0x00	; 0
    3092:	a9 01       	movw	r20, r18
    3094:	0e 94 19 15 	call	0x2a32	; 0x2a32 <LCD_displayStringRowColumn>
    3098:	80 e0       	ldi	r24, 0x00	; 0
    309a:	90 e8       	ldi	r25, 0x80	; 128
    309c:	ab eb       	ldi	r26, 0xBB	; 187
    309e:	b4 e4       	ldi	r27, 0x44	; 68
    30a0:	89 8f       	std	Y+25, r24	; 0x19
    30a2:	9a 8f       	std	Y+26, r25	; 0x1a
    30a4:	ab 8f       	std	Y+27, r26	; 0x1b
    30a6:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    30a8:	69 8d       	ldd	r22, Y+25	; 0x19
    30aa:	7a 8d       	ldd	r23, Y+26	; 0x1a
    30ac:	8b 8d       	ldd	r24, Y+27	; 0x1b
    30ae:	9c 8d       	ldd	r25, Y+28	; 0x1c
    30b0:	20 e0       	ldi	r18, 0x00	; 0
    30b2:	30 e0       	ldi	r19, 0x00	; 0
    30b4:	4a ef       	ldi	r20, 0xFA	; 250
    30b6:	54 e4       	ldi	r21, 0x44	; 68
    30b8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    30bc:	dc 01       	movw	r26, r24
    30be:	cb 01       	movw	r24, r22
    30c0:	8d 8b       	std	Y+21, r24	; 0x15
    30c2:	9e 8b       	std	Y+22, r25	; 0x16
    30c4:	af 8b       	std	Y+23, r26	; 0x17
    30c6:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    30c8:	6d 89       	ldd	r22, Y+21	; 0x15
    30ca:	7e 89       	ldd	r23, Y+22	; 0x16
    30cc:	8f 89       	ldd	r24, Y+23	; 0x17
    30ce:	98 8d       	ldd	r25, Y+24	; 0x18
    30d0:	20 e0       	ldi	r18, 0x00	; 0
    30d2:	30 e0       	ldi	r19, 0x00	; 0
    30d4:	40 e8       	ldi	r20, 0x80	; 128
    30d6:	5f e3       	ldi	r21, 0x3F	; 63
    30d8:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    30dc:	88 23       	and	r24, r24
    30de:	2c f4       	brge	.+10     	; 0x30ea <main+0x304>
		__ticks = 1;
    30e0:	81 e0       	ldi	r24, 0x01	; 1
    30e2:	90 e0       	ldi	r25, 0x00	; 0
    30e4:	9c 8b       	std	Y+20, r25	; 0x14
    30e6:	8b 8b       	std	Y+19, r24	; 0x13
    30e8:	3f c0       	rjmp	.+126    	; 0x3168 <main+0x382>
	else if (__tmp > 65535)
    30ea:	6d 89       	ldd	r22, Y+21	; 0x15
    30ec:	7e 89       	ldd	r23, Y+22	; 0x16
    30ee:	8f 89       	ldd	r24, Y+23	; 0x17
    30f0:	98 8d       	ldd	r25, Y+24	; 0x18
    30f2:	20 e0       	ldi	r18, 0x00	; 0
    30f4:	3f ef       	ldi	r19, 0xFF	; 255
    30f6:	4f e7       	ldi	r20, 0x7F	; 127
    30f8:	57 e4       	ldi	r21, 0x47	; 71
    30fa:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    30fe:	18 16       	cp	r1, r24
    3100:	4c f5       	brge	.+82     	; 0x3154 <main+0x36e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3102:	69 8d       	ldd	r22, Y+25	; 0x19
    3104:	7a 8d       	ldd	r23, Y+26	; 0x1a
    3106:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3108:	9c 8d       	ldd	r25, Y+28	; 0x1c
    310a:	20 e0       	ldi	r18, 0x00	; 0
    310c:	30 e0       	ldi	r19, 0x00	; 0
    310e:	40 e2       	ldi	r20, 0x20	; 32
    3110:	51 e4       	ldi	r21, 0x41	; 65
    3112:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3116:	dc 01       	movw	r26, r24
    3118:	cb 01       	movw	r24, r22
    311a:	bc 01       	movw	r22, r24
    311c:	cd 01       	movw	r24, r26
    311e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3122:	dc 01       	movw	r26, r24
    3124:	cb 01       	movw	r24, r22
    3126:	9c 8b       	std	Y+20, r25	; 0x14
    3128:	8b 8b       	std	Y+19, r24	; 0x13
    312a:	0f c0       	rjmp	.+30     	; 0x314a <main+0x364>
    312c:	88 ec       	ldi	r24, 0xC8	; 200
    312e:	90 e0       	ldi	r25, 0x00	; 0
    3130:	9a 8b       	std	Y+18, r25	; 0x12
    3132:	89 8b       	std	Y+17, r24	; 0x11
    3134:	89 89       	ldd	r24, Y+17	; 0x11
    3136:	9a 89       	ldd	r25, Y+18	; 0x12
    3138:	01 97       	sbiw	r24, 0x01	; 1
    313a:	f1 f7       	brne	.-4      	; 0x3138 <main+0x352>
    313c:	9a 8b       	std	Y+18, r25	; 0x12
    313e:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3140:	8b 89       	ldd	r24, Y+19	; 0x13
    3142:	9c 89       	ldd	r25, Y+20	; 0x14
    3144:	01 97       	sbiw	r24, 0x01	; 1
    3146:	9c 8b       	std	Y+20, r25	; 0x14
    3148:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    314a:	8b 89       	ldd	r24, Y+19	; 0x13
    314c:	9c 89       	ldd	r25, Y+20	; 0x14
    314e:	00 97       	sbiw	r24, 0x00	; 0
    3150:	69 f7       	brne	.-38     	; 0x312c <main+0x346>
    3152:	14 c0       	rjmp	.+40     	; 0x317c <main+0x396>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3154:	6d 89       	ldd	r22, Y+21	; 0x15
    3156:	7e 89       	ldd	r23, Y+22	; 0x16
    3158:	8f 89       	ldd	r24, Y+23	; 0x17
    315a:	98 8d       	ldd	r25, Y+24	; 0x18
    315c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3160:	dc 01       	movw	r26, r24
    3162:	cb 01       	movw	r24, r22
    3164:	9c 8b       	std	Y+20, r25	; 0x14
    3166:	8b 8b       	std	Y+19, r24	; 0x13
    3168:	8b 89       	ldd	r24, Y+19	; 0x13
    316a:	9c 89       	ldd	r25, Y+20	; 0x14
    316c:	98 8b       	std	Y+16, r25	; 0x10
    316e:	8f 87       	std	Y+15, r24	; 0x0f
    3170:	8f 85       	ldd	r24, Y+15	; 0x0f
    3172:	98 89       	ldd	r25, Y+16	; 0x10
    3174:	01 97       	sbiw	r24, 0x01	; 1
    3176:	f1 f7       	brne	.-4      	; 0x3174 <main+0x38e>
    3178:	98 8b       	std	Y+16, r25	; 0x10
    317a:	8f 87       	std	Y+15, r24	; 0x0f
			_delay_ms(1500);
			LCD_clearScreen();
    317c:	0e 94 55 15 	call	0x2aaa	; 0x2aaa <LCD_clearScreen>
			SYS_MainMenu_HMI();
    3180:	0e 94 fd 1b 	call	0x37fa	; 0x37fa <SYS_MainMenu_HMI>
    3184:	a9 ce       	rjmp	.-686    	; 0x2ed8 <main+0xf2>
			break;

		case PasswordInCorrect:
			SYS_IncorrectPass();
    3186:	0e 94 57 1c 	call	0x38ae	; 0x38ae <SYS_IncorrectPass>
			SYS_Check_Password_HMI();
    318a:	0e 94 52 1b 	call	0x36a4	; 0x36a4 <SYS_Check_Password_HMI>
			UART_sendByte(SendRequestedPass);
    318e:	80 e5       	ldi	r24, 0x50	; 80
    3190:	0e 94 4a 06 	call	0xc94	; 0xc94 <UART_sendByte>
			SYS_Send_Password_HMI(passArray3);
    3194:	85 e5       	ldi	r24, 0x55	; 85
    3196:	91 e0       	ldi	r25, 0x01	; 1
    3198:	0e 94 31 1b 	call	0x3662	; 0x3662 <SYS_Send_Password_HMI>
    319c:	9d ce       	rjmp	.-710    	; 0x2ed8 <main+0xf2>
			break;

		case PasswordCorrect:
			g_uart_order = 0;
    319e:	10 92 4c 01 	sts	0x014C, r1
			if (g_keyPressed == '+') {
    31a2:	80 91 5f 01 	lds	r24, 0x015F
    31a6:	8b 32       	cpi	r24, 0x2B	; 43
    31a8:	09 f0       	breq	.+2      	; 0x31ac <main+0x3c6>
    31aa:	56 c0       	rjmp	.+172    	; 0x3258 <main+0x472>
				g_keyPressed = 0;
    31ac:	10 92 5f 01 	sts	0x015F, r1
				LCD_clearScreen();
    31b0:	0e 94 55 15 	call	0x2aaa	; 0x2aaa <LCD_clearScreen>
				UART_sendByte(OpenDoor);
    31b4:	84 e7       	ldi	r24, 0x74	; 116
    31b6:	0e 94 4a 06 	call	0xc94	; 0xc94 <UART_sendByte>
				Timer1_init(&TimerConfiguration);
    31ba:	ce 01       	movw	r24, r28
    31bc:	c2 96       	adiw	r24, 0x32	; 50
    31be:	0e 94 33 07 	call	0xe66	; 0xe66 <Timer1_init>
				LCD_displayStringRowColumn(0, 0, "Door is Unlocking");
    31c2:	2b e7       	ldi	r18, 0x7B	; 123
    31c4:	30 e0       	ldi	r19, 0x00	; 0
    31c6:	80 e0       	ldi	r24, 0x00	; 0
    31c8:	60 e0       	ldi	r22, 0x00	; 0
    31ca:	a9 01       	movw	r20, r18
    31cc:	0e 94 19 15 	call	0x2a32	; 0x2a32 <LCD_displayStringRowColumn>
				while (g_timerCounts != 2) {
    31d0:	80 91 4d 01 	lds	r24, 0x014D
    31d4:	90 91 4e 01 	lds	r25, 0x014E
    31d8:	82 30       	cpi	r24, 0x02	; 2
    31da:	91 05       	cpc	r25, r1
    31dc:	c9 f7       	brne	.-14     	; 0x31d0 <main+0x3ea>
				}
				g_timerCounts = 0;
    31de:	10 92 4e 01 	sts	0x014E, r1
    31e2:	10 92 4d 01 	sts	0x014D, r1
				Timer1_deInit();
    31e6:	0e 94 b3 07 	call	0xf66	; 0xf66 <Timer1_deInit>
				LCD_clearScreen();
    31ea:	0e 94 55 15 	call	0x2aaa	; 0x2aaa <LCD_clearScreen>
				Timer1_init(&TimerConfiguration);
    31ee:	ce 01       	movw	r24, r28
    31f0:	c2 96       	adiw	r24, 0x32	; 50
    31f2:	0e 94 33 07 	call	0xe66	; 0xe66 <Timer1_init>
				LCD_displayStringRowColumn(0, 0, "Door Stopped");
    31f6:	2d e8       	ldi	r18, 0x8D	; 141
    31f8:	30 e0       	ldi	r19, 0x00	; 0
    31fa:	80 e0       	ldi	r24, 0x00	; 0
    31fc:	60 e0       	ldi	r22, 0x00	; 0
    31fe:	a9 01       	movw	r20, r18
    3200:	0e 94 19 15 	call	0x2a32	; 0x2a32 <LCD_displayStringRowColumn>
				while (g_timerCounts != 2) {
    3204:	80 91 4d 01 	lds	r24, 0x014D
    3208:	90 91 4e 01 	lds	r25, 0x014E
    320c:	82 30       	cpi	r24, 0x02	; 2
    320e:	91 05       	cpc	r25, r1
    3210:	c9 f7       	brne	.-14     	; 0x3204 <main+0x41e>
				}
				g_timerCounts = 0;
    3212:	10 92 4e 01 	sts	0x014E, r1
    3216:	10 92 4d 01 	sts	0x014D, r1
				Timer1_deInit();
    321a:	0e 94 b3 07 	call	0xf66	; 0xf66 <Timer1_deInit>
				LCD_clearScreen();
    321e:	0e 94 55 15 	call	0x2aaa	; 0x2aaa <LCD_clearScreen>
				Timer1_init(&TimerConfiguration);
    3222:	ce 01       	movw	r24, r28
    3224:	c2 96       	adiw	r24, 0x32	; 50
    3226:	0e 94 33 07 	call	0xe66	; 0xe66 <Timer1_init>
				LCD_displayStringRowColumn(0, 0, "Door is Locking");
    322a:	2a e9       	ldi	r18, 0x9A	; 154
    322c:	30 e0       	ldi	r19, 0x00	; 0
    322e:	80 e0       	ldi	r24, 0x00	; 0
    3230:	60 e0       	ldi	r22, 0x00	; 0
    3232:	a9 01       	movw	r20, r18
    3234:	0e 94 19 15 	call	0x2a32	; 0x2a32 <LCD_displayStringRowColumn>
				g_timerCounts = 0;
    3238:	10 92 4e 01 	sts	0x014E, r1
    323c:	10 92 4d 01 	sts	0x014D, r1
				while (g_timerCounts != 2) {
    3240:	80 91 4d 01 	lds	r24, 0x014D
    3244:	90 91 4e 01 	lds	r25, 0x014E
    3248:	82 30       	cpi	r24, 0x02	; 2
    324a:	91 05       	cpc	r25, r1
    324c:	c9 f7       	brne	.-14     	; 0x3240 <main+0x45a>
				}
				Timer1_deInit();
    324e:	0e 94 b3 07 	call	0xf66	; 0xf66 <Timer1_deInit>
				UART_sendByte(MainMenu);
    3252:	87 e6       	ldi	r24, 0x67	; 103
    3254:	0e 94 4a 06 	call	0xc94	; 0xc94 <UART_sendByte>

			}
			if (g_keyPressed == '-') {
    3258:	80 91 5f 01 	lds	r24, 0x015F
    325c:	8d 32       	cpi	r24, 0x2D	; 45
    325e:	09 f0       	breq	.+2      	; 0x3262 <main+0x47c>
    3260:	3b ce       	rjmp	.-906    	; 0x2ed8 <main+0xf2>
				LCD_clearScreen();
    3262:	0e 94 55 15 	call	0x2aaa	; 0x2aaa <LCD_clearScreen>
				LCD_displayStringRowColumn(0, 0, "Change Request");
    3266:	2a ea       	ldi	r18, 0xAA	; 170
    3268:	30 e0       	ldi	r19, 0x00	; 0
    326a:	80 e0       	ldi	r24, 0x00	; 0
    326c:	60 e0       	ldi	r22, 0x00	; 0
    326e:	a9 01       	movw	r20, r18
    3270:	0e 94 19 15 	call	0x2a32	; 0x2a32 <LCD_displayStringRowColumn>
    3274:	80 e0       	ldi	r24, 0x00	; 0
    3276:	90 e0       	ldi	r25, 0x00	; 0
    3278:	aa e7       	ldi	r26, 0x7A	; 122
    327a:	b4 e4       	ldi	r27, 0x44	; 68
    327c:	8b 87       	std	Y+11, r24	; 0x0b
    327e:	9c 87       	std	Y+12, r25	; 0x0c
    3280:	ad 87       	std	Y+13, r26	; 0x0d
    3282:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3284:	6b 85       	ldd	r22, Y+11	; 0x0b
    3286:	7c 85       	ldd	r23, Y+12	; 0x0c
    3288:	8d 85       	ldd	r24, Y+13	; 0x0d
    328a:	9e 85       	ldd	r25, Y+14	; 0x0e
    328c:	20 e0       	ldi	r18, 0x00	; 0
    328e:	30 e0       	ldi	r19, 0x00	; 0
    3290:	4a ef       	ldi	r20, 0xFA	; 250
    3292:	54 e4       	ldi	r21, 0x44	; 68
    3294:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3298:	dc 01       	movw	r26, r24
    329a:	cb 01       	movw	r24, r22
    329c:	8f 83       	std	Y+7, r24	; 0x07
    329e:	98 87       	std	Y+8, r25	; 0x08
    32a0:	a9 87       	std	Y+9, r26	; 0x09
    32a2:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    32a4:	6f 81       	ldd	r22, Y+7	; 0x07
    32a6:	78 85       	ldd	r23, Y+8	; 0x08
    32a8:	89 85       	ldd	r24, Y+9	; 0x09
    32aa:	9a 85       	ldd	r25, Y+10	; 0x0a
    32ac:	20 e0       	ldi	r18, 0x00	; 0
    32ae:	30 e0       	ldi	r19, 0x00	; 0
    32b0:	40 e8       	ldi	r20, 0x80	; 128
    32b2:	5f e3       	ldi	r21, 0x3F	; 63
    32b4:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    32b8:	88 23       	and	r24, r24
    32ba:	2c f4       	brge	.+10     	; 0x32c6 <main+0x4e0>
		__ticks = 1;
    32bc:	81 e0       	ldi	r24, 0x01	; 1
    32be:	90 e0       	ldi	r25, 0x00	; 0
    32c0:	9e 83       	std	Y+6, r25	; 0x06
    32c2:	8d 83       	std	Y+5, r24	; 0x05
    32c4:	3f c0       	rjmp	.+126    	; 0x3344 <main+0x55e>
	else if (__tmp > 65535)
    32c6:	6f 81       	ldd	r22, Y+7	; 0x07
    32c8:	78 85       	ldd	r23, Y+8	; 0x08
    32ca:	89 85       	ldd	r24, Y+9	; 0x09
    32cc:	9a 85       	ldd	r25, Y+10	; 0x0a
    32ce:	20 e0       	ldi	r18, 0x00	; 0
    32d0:	3f ef       	ldi	r19, 0xFF	; 255
    32d2:	4f e7       	ldi	r20, 0x7F	; 127
    32d4:	57 e4       	ldi	r21, 0x47	; 71
    32d6:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    32da:	18 16       	cp	r1, r24
    32dc:	4c f5       	brge	.+82     	; 0x3330 <main+0x54a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    32de:	6b 85       	ldd	r22, Y+11	; 0x0b
    32e0:	7c 85       	ldd	r23, Y+12	; 0x0c
    32e2:	8d 85       	ldd	r24, Y+13	; 0x0d
    32e4:	9e 85       	ldd	r25, Y+14	; 0x0e
    32e6:	20 e0       	ldi	r18, 0x00	; 0
    32e8:	30 e0       	ldi	r19, 0x00	; 0
    32ea:	40 e2       	ldi	r20, 0x20	; 32
    32ec:	51 e4       	ldi	r21, 0x41	; 65
    32ee:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    32f2:	dc 01       	movw	r26, r24
    32f4:	cb 01       	movw	r24, r22
    32f6:	bc 01       	movw	r22, r24
    32f8:	cd 01       	movw	r24, r26
    32fa:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    32fe:	dc 01       	movw	r26, r24
    3300:	cb 01       	movw	r24, r22
    3302:	9e 83       	std	Y+6, r25	; 0x06
    3304:	8d 83       	std	Y+5, r24	; 0x05
    3306:	0f c0       	rjmp	.+30     	; 0x3326 <main+0x540>
    3308:	88 ec       	ldi	r24, 0xC8	; 200
    330a:	90 e0       	ldi	r25, 0x00	; 0
    330c:	9c 83       	std	Y+4, r25	; 0x04
    330e:	8b 83       	std	Y+3, r24	; 0x03
    3310:	8b 81       	ldd	r24, Y+3	; 0x03
    3312:	9c 81       	ldd	r25, Y+4	; 0x04
    3314:	01 97       	sbiw	r24, 0x01	; 1
    3316:	f1 f7       	brne	.-4      	; 0x3314 <main+0x52e>
    3318:	9c 83       	std	Y+4, r25	; 0x04
    331a:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    331c:	8d 81       	ldd	r24, Y+5	; 0x05
    331e:	9e 81       	ldd	r25, Y+6	; 0x06
    3320:	01 97       	sbiw	r24, 0x01	; 1
    3322:	9e 83       	std	Y+6, r25	; 0x06
    3324:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3326:	8d 81       	ldd	r24, Y+5	; 0x05
    3328:	9e 81       	ldd	r25, Y+6	; 0x06
    332a:	00 97       	sbiw	r24, 0x00	; 0
    332c:	69 f7       	brne	.-38     	; 0x3308 <main+0x522>
    332e:	14 c0       	rjmp	.+40     	; 0x3358 <main+0x572>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3330:	6f 81       	ldd	r22, Y+7	; 0x07
    3332:	78 85       	ldd	r23, Y+8	; 0x08
    3334:	89 85       	ldd	r24, Y+9	; 0x09
    3336:	9a 85       	ldd	r25, Y+10	; 0x0a
    3338:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    333c:	dc 01       	movw	r26, r24
    333e:	cb 01       	movw	r24, r22
    3340:	9e 83       	std	Y+6, r25	; 0x06
    3342:	8d 83       	std	Y+5, r24	; 0x05
    3344:	8d 81       	ldd	r24, Y+5	; 0x05
    3346:	9e 81       	ldd	r25, Y+6	; 0x06
    3348:	9a 83       	std	Y+2, r25	; 0x02
    334a:	89 83       	std	Y+1, r24	; 0x01
    334c:	89 81       	ldd	r24, Y+1	; 0x01
    334e:	9a 81       	ldd	r25, Y+2	; 0x02
    3350:	01 97       	sbiw	r24, 0x01	; 1
    3352:	f1 f7       	brne	.-4      	; 0x3350 <main+0x56a>
    3354:	9a 83       	std	Y+2, r25	; 0x02
    3356:	89 83       	std	Y+1, r24	; 0x01
				_delay_ms(1000);
				g_keyPressed = 0;
    3358:	10 92 5f 01 	sts	0x015F, r1
				UART_sendByte(SetNewPassword);
    335c:	85 e4       	ldi	r24, 0x45	; 69
    335e:	0e 94 4a 06 	call	0xc94	; 0xc94 <UART_sendByte>
    3362:	ba cd       	rjmp	.-1164   	; 0x2ed8 <main+0xf2>
			}
			break;

		case THEIF:
			g_uart_order = 0;
    3364:	10 92 4c 01 	sts	0x014C, r1
			LCD_clearScreen();
    3368:	0e 94 55 15 	call	0x2aaa	; 0x2aaa <LCD_clearScreen>
			UART_sendByte(THEIF);
    336c:	8f e4       	ldi	r24, 0x4F	; 79
    336e:	0e 94 4a 06 	call	0xc94	; 0xc94 <UART_sendByte>
			LCD_displayStringRowColumn(0, 0, "ERROR");
    3372:	29 eb       	ldi	r18, 0xB9	; 185
    3374:	30 e0       	ldi	r19, 0x00	; 0
    3376:	80 e0       	ldi	r24, 0x00	; 0
    3378:	60 e0       	ldi	r22, 0x00	; 0
    337a:	a9 01       	movw	r20, r18
    337c:	0e 94 19 15 	call	0x2a32	; 0x2a32 <LCD_displayStringRowColumn>
			Timer1_init(&TimerConfiguration);
    3380:	ce 01       	movw	r24, r28
    3382:	c2 96       	adiw	r24, 0x32	; 50
    3384:	0e 94 33 07 	call	0xe66	; 0xe66 <Timer1_init>
			while (g_timerCounts != 2) {
    3388:	80 91 4d 01 	lds	r24, 0x014D
    338c:	90 91 4e 01 	lds	r25, 0x014E
    3390:	82 30       	cpi	r24, 0x02	; 2
    3392:	91 05       	cpc	r25, r1
    3394:	c9 f7       	brne	.-14     	; 0x3388 <main+0x5a2>
			}
			g_timerCounts = 0;
    3396:	10 92 4e 01 	sts	0x014E, r1
    339a:	10 92 4d 01 	sts	0x014D, r1
			Timer1_deInit();
    339e:	0e 94 b3 07 	call	0xf66	; 0xf66 <Timer1_deInit>
			LCD_clearScreen();
    33a2:	0e 94 55 15 	call	0x2aaa	; 0x2aaa <LCD_clearScreen>
			SYS_MainMenu_HMI();
    33a6:	0e 94 fd 1b 	call	0x37fa	; 0x37fa <SYS_MainMenu_HMI>
    33aa:	96 cd       	rjmp	.-1236   	; 0x2ed8 <main+0xf2>

000033ac <SYS_Create_Password_HMI>:

	}

}

void SYS_Create_Password_HMI(void) {
    33ac:	0f 93       	push	r16
    33ae:	1f 93       	push	r17
    33b0:	df 93       	push	r29
    33b2:	cf 93       	push	r28
    33b4:	cd b7       	in	r28, 0x3d	; 61
    33b6:	de b7       	in	r29, 0x3e	; 62
    33b8:	6d 97       	sbiw	r28, 0x1d	; 29
    33ba:	0f b6       	in	r0, 0x3f	; 63
    33bc:	f8 94       	cli
    33be:	de bf       	out	0x3e, r29	; 62
    33c0:	0f be       	out	0x3f, r0	; 63
    33c2:	cd bf       	out	0x3d, r28	; 61
	uint8 i;
	LCD_clearScreen();
    33c4:	0e 94 55 15 	call	0x2aaa	; 0x2aaa <LCD_clearScreen>
	LCD_displayStringRowColumn(0, 0, "Enter Password :");
    33c8:	2f eb       	ldi	r18, 0xBF	; 191
    33ca:	30 e0       	ldi	r19, 0x00	; 0
    33cc:	80 e0       	ldi	r24, 0x00	; 0
    33ce:	60 e0       	ldi	r22, 0x00	; 0
    33d0:	a9 01       	movw	r20, r18
    33d2:	0e 94 19 15 	call	0x2a32	; 0x2a32 <LCD_displayStringRowColumn>
	LCD_moveCursor(1, 0);
    33d6:	81 e0       	ldi	r24, 0x01	; 1
    33d8:	60 e0       	ldi	r22, 0x00	; 0
    33da:	0e 94 d7 14 	call	0x29ae	; 0x29ae <LCD_moveCursor>
	for (i = 0; i < PasswordSize; i++) {
    33de:	1d 8e       	std	Y+29, r1	; 0x1d
    33e0:	81 c0       	rjmp	.+258    	; 0x34e4 <SYS_Create_Password_HMI+0x138>
		passArray1[i] = KEYPAD_getPressedKey();
    33e2:	8d 8d       	ldd	r24, Y+29	; 0x1d
    33e4:	08 2f       	mov	r16, r24
    33e6:	10 e0       	ldi	r17, 0x00	; 0
    33e8:	0e 94 5f 15 	call	0x2abe	; 0x2abe <KEYPAD_getPressedKey>
    33ec:	f8 01       	movw	r30, r16
    33ee:	e0 5b       	subi	r30, 0xB0	; 176
    33f0:	fe 4f       	sbci	r31, 0xFE	; 254
    33f2:	80 83       	st	Z, r24
		//password1 = password1 * 10 + passArray1[i];
		LCD_displayCharacter('*');
    33f4:	8a e2       	ldi	r24, 0x2A	; 42
    33f6:	0e 94 33 10 	call	0x2066	; 0x2066 <LCD_displayCharacter>
    33fa:	80 e0       	ldi	r24, 0x00	; 0
    33fc:	90 e0       	ldi	r25, 0x00	; 0
    33fe:	a6 e9       	ldi	r26, 0x96	; 150
    3400:	b3 e4       	ldi	r27, 0x43	; 67
    3402:	89 8f       	std	Y+25, r24	; 0x19
    3404:	9a 8f       	std	Y+26, r25	; 0x1a
    3406:	ab 8f       	std	Y+27, r26	; 0x1b
    3408:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    340a:	69 8d       	ldd	r22, Y+25	; 0x19
    340c:	7a 8d       	ldd	r23, Y+26	; 0x1a
    340e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3410:	9c 8d       	ldd	r25, Y+28	; 0x1c
    3412:	20 e0       	ldi	r18, 0x00	; 0
    3414:	30 e0       	ldi	r19, 0x00	; 0
    3416:	4a ef       	ldi	r20, 0xFA	; 250
    3418:	54 e4       	ldi	r21, 0x44	; 68
    341a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    341e:	dc 01       	movw	r26, r24
    3420:	cb 01       	movw	r24, r22
    3422:	8d 8b       	std	Y+21, r24	; 0x15
    3424:	9e 8b       	std	Y+22, r25	; 0x16
    3426:	af 8b       	std	Y+23, r26	; 0x17
    3428:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    342a:	6d 89       	ldd	r22, Y+21	; 0x15
    342c:	7e 89       	ldd	r23, Y+22	; 0x16
    342e:	8f 89       	ldd	r24, Y+23	; 0x17
    3430:	98 8d       	ldd	r25, Y+24	; 0x18
    3432:	20 e0       	ldi	r18, 0x00	; 0
    3434:	30 e0       	ldi	r19, 0x00	; 0
    3436:	40 e8       	ldi	r20, 0x80	; 128
    3438:	5f e3       	ldi	r21, 0x3F	; 63
    343a:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    343e:	88 23       	and	r24, r24
    3440:	2c f4       	brge	.+10     	; 0x344c <SYS_Create_Password_HMI+0xa0>
		__ticks = 1;
    3442:	81 e0       	ldi	r24, 0x01	; 1
    3444:	90 e0       	ldi	r25, 0x00	; 0
    3446:	9c 8b       	std	Y+20, r25	; 0x14
    3448:	8b 8b       	std	Y+19, r24	; 0x13
    344a:	3f c0       	rjmp	.+126    	; 0x34ca <SYS_Create_Password_HMI+0x11e>
	else if (__tmp > 65535)
    344c:	6d 89       	ldd	r22, Y+21	; 0x15
    344e:	7e 89       	ldd	r23, Y+22	; 0x16
    3450:	8f 89       	ldd	r24, Y+23	; 0x17
    3452:	98 8d       	ldd	r25, Y+24	; 0x18
    3454:	20 e0       	ldi	r18, 0x00	; 0
    3456:	3f ef       	ldi	r19, 0xFF	; 255
    3458:	4f e7       	ldi	r20, 0x7F	; 127
    345a:	57 e4       	ldi	r21, 0x47	; 71
    345c:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    3460:	18 16       	cp	r1, r24
    3462:	4c f5       	brge	.+82     	; 0x34b6 <SYS_Create_Password_HMI+0x10a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3464:	69 8d       	ldd	r22, Y+25	; 0x19
    3466:	7a 8d       	ldd	r23, Y+26	; 0x1a
    3468:	8b 8d       	ldd	r24, Y+27	; 0x1b
    346a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    346c:	20 e0       	ldi	r18, 0x00	; 0
    346e:	30 e0       	ldi	r19, 0x00	; 0
    3470:	40 e2       	ldi	r20, 0x20	; 32
    3472:	51 e4       	ldi	r21, 0x41	; 65
    3474:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3478:	dc 01       	movw	r26, r24
    347a:	cb 01       	movw	r24, r22
    347c:	bc 01       	movw	r22, r24
    347e:	cd 01       	movw	r24, r26
    3480:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3484:	dc 01       	movw	r26, r24
    3486:	cb 01       	movw	r24, r22
    3488:	9c 8b       	std	Y+20, r25	; 0x14
    348a:	8b 8b       	std	Y+19, r24	; 0x13
    348c:	0f c0       	rjmp	.+30     	; 0x34ac <SYS_Create_Password_HMI+0x100>
    348e:	88 ec       	ldi	r24, 0xC8	; 200
    3490:	90 e0       	ldi	r25, 0x00	; 0
    3492:	9a 8b       	std	Y+18, r25	; 0x12
    3494:	89 8b       	std	Y+17, r24	; 0x11
    3496:	89 89       	ldd	r24, Y+17	; 0x11
    3498:	9a 89       	ldd	r25, Y+18	; 0x12
    349a:	01 97       	sbiw	r24, 0x01	; 1
    349c:	f1 f7       	brne	.-4      	; 0x349a <SYS_Create_Password_HMI+0xee>
    349e:	9a 8b       	std	Y+18, r25	; 0x12
    34a0:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    34a2:	8b 89       	ldd	r24, Y+19	; 0x13
    34a4:	9c 89       	ldd	r25, Y+20	; 0x14
    34a6:	01 97       	sbiw	r24, 0x01	; 1
    34a8:	9c 8b       	std	Y+20, r25	; 0x14
    34aa:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    34ac:	8b 89       	ldd	r24, Y+19	; 0x13
    34ae:	9c 89       	ldd	r25, Y+20	; 0x14
    34b0:	00 97       	sbiw	r24, 0x00	; 0
    34b2:	69 f7       	brne	.-38     	; 0x348e <SYS_Create_Password_HMI+0xe2>
    34b4:	14 c0       	rjmp	.+40     	; 0x34de <SYS_Create_Password_HMI+0x132>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    34b6:	6d 89       	ldd	r22, Y+21	; 0x15
    34b8:	7e 89       	ldd	r23, Y+22	; 0x16
    34ba:	8f 89       	ldd	r24, Y+23	; 0x17
    34bc:	98 8d       	ldd	r25, Y+24	; 0x18
    34be:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    34c2:	dc 01       	movw	r26, r24
    34c4:	cb 01       	movw	r24, r22
    34c6:	9c 8b       	std	Y+20, r25	; 0x14
    34c8:	8b 8b       	std	Y+19, r24	; 0x13
    34ca:	8b 89       	ldd	r24, Y+19	; 0x13
    34cc:	9c 89       	ldd	r25, Y+20	; 0x14
    34ce:	98 8b       	std	Y+16, r25	; 0x10
    34d0:	8f 87       	std	Y+15, r24	; 0x0f
    34d2:	8f 85       	ldd	r24, Y+15	; 0x0f
    34d4:	98 89       	ldd	r25, Y+16	; 0x10
    34d6:	01 97       	sbiw	r24, 0x01	; 1
    34d8:	f1 f7       	brne	.-4      	; 0x34d6 <SYS_Create_Password_HMI+0x12a>
    34da:	98 8b       	std	Y+16, r25	; 0x10
    34dc:	8f 87       	std	Y+15, r24	; 0x0f
void SYS_Create_Password_HMI(void) {
	uint8 i;
	LCD_clearScreen();
	LCD_displayStringRowColumn(0, 0, "Enter Password :");
	LCD_moveCursor(1, 0);
	for (i = 0; i < PasswordSize; i++) {
    34de:	8d 8d       	ldd	r24, Y+29	; 0x1d
    34e0:	8f 5f       	subi	r24, 0xFF	; 255
    34e2:	8d 8f       	std	Y+29, r24	; 0x1d
    34e4:	8d 8d       	ldd	r24, Y+29	; 0x1d
    34e6:	85 30       	cpi	r24, 0x05	; 5
    34e8:	08 f4       	brcc	.+2      	; 0x34ec <SYS_Create_Password_HMI+0x140>
    34ea:	7b cf       	rjmp	.-266    	; 0x33e2 <SYS_Create_Password_HMI+0x36>
		passArray1[i] = KEYPAD_getPressedKey();
		//password1 = password1 * 10 + passArray1[i];
		LCD_displayCharacter('*');
		_delay_ms(300);
	}
	LCD_clearScreen();
    34ec:	0e 94 55 15 	call	0x2aaa	; 0x2aaa <LCD_clearScreen>
    34f0:	07 c0       	rjmp	.+14     	; 0x3500 <SYS_Create_Password_HMI+0x154>
	while (KEYPAD_getPressedKey() != '=') {
		LCD_displayStringRowColumn(0, 1, "Press Enter");
    34f2:	20 ed       	ldi	r18, 0xD0	; 208
    34f4:	30 e0       	ldi	r19, 0x00	; 0
    34f6:	80 e0       	ldi	r24, 0x00	; 0
    34f8:	61 e0       	ldi	r22, 0x01	; 1
    34fa:	a9 01       	movw	r20, r18
    34fc:	0e 94 19 15 	call	0x2a32	; 0x2a32 <LCD_displayStringRowColumn>
		//password1 = password1 * 10 + passArray1[i];
		LCD_displayCharacter('*');
		_delay_ms(300);
	}
	LCD_clearScreen();
	while (KEYPAD_getPressedKey() != '=') {
    3500:	0e 94 5f 15 	call	0x2abe	; 0x2abe <KEYPAD_getPressedKey>
    3504:	8d 33       	cpi	r24, 0x3D	; 61
    3506:	a9 f7       	brne	.-22     	; 0x34f2 <SYS_Create_Password_HMI+0x146>
		LCD_displayStringRowColumn(0, 1, "Press Enter");
	}
	LCD_clearScreen();
    3508:	0e 94 55 15 	call	0x2aaa	; 0x2aaa <LCD_clearScreen>
	LCD_displayStringRowColumn(0, 0, "Re-Enter Pass :");
    350c:	2c ed       	ldi	r18, 0xDC	; 220
    350e:	30 e0       	ldi	r19, 0x00	; 0
    3510:	80 e0       	ldi	r24, 0x00	; 0
    3512:	60 e0       	ldi	r22, 0x00	; 0
    3514:	a9 01       	movw	r20, r18
    3516:	0e 94 19 15 	call	0x2a32	; 0x2a32 <LCD_displayStringRowColumn>
	LCD_moveCursor(1, 0);
    351a:	81 e0       	ldi	r24, 0x01	; 1
    351c:	60 e0       	ldi	r22, 0x00	; 0
    351e:	0e 94 d7 14 	call	0x29ae	; 0x29ae <LCD_moveCursor>
	for (i = 0; i < PasswordSize; i++) {
    3522:	1d 8e       	std	Y+29, r1	; 0x1d
    3524:	81 c0       	rjmp	.+258    	; 0x3628 <SYS_Create_Password_HMI+0x27c>
		passArray2[i] = KEYPAD_getPressedKey();
    3526:	8d 8d       	ldd	r24, Y+29	; 0x1d
    3528:	08 2f       	mov	r16, r24
    352a:	10 e0       	ldi	r17, 0x00	; 0
    352c:	0e 94 5f 15 	call	0x2abe	; 0x2abe <KEYPAD_getPressedKey>
    3530:	f8 01       	movw	r30, r16
    3532:	e6 5a       	subi	r30, 0xA6	; 166
    3534:	fe 4f       	sbci	r31, 0xFE	; 254
    3536:	80 83       	st	Z, r24
		LCD_displayCharacter('*');
    3538:	8a e2       	ldi	r24, 0x2A	; 42
    353a:	0e 94 33 10 	call	0x2066	; 0x2066 <LCD_displayCharacter>
    353e:	80 e0       	ldi	r24, 0x00	; 0
    3540:	90 e0       	ldi	r25, 0x00	; 0
    3542:	a6 e9       	ldi	r26, 0x96	; 150
    3544:	b3 e4       	ldi	r27, 0x43	; 67
    3546:	8b 87       	std	Y+11, r24	; 0x0b
    3548:	9c 87       	std	Y+12, r25	; 0x0c
    354a:	ad 87       	std	Y+13, r26	; 0x0d
    354c:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    354e:	6b 85       	ldd	r22, Y+11	; 0x0b
    3550:	7c 85       	ldd	r23, Y+12	; 0x0c
    3552:	8d 85       	ldd	r24, Y+13	; 0x0d
    3554:	9e 85       	ldd	r25, Y+14	; 0x0e
    3556:	20 e0       	ldi	r18, 0x00	; 0
    3558:	30 e0       	ldi	r19, 0x00	; 0
    355a:	4a ef       	ldi	r20, 0xFA	; 250
    355c:	54 e4       	ldi	r21, 0x44	; 68
    355e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3562:	dc 01       	movw	r26, r24
    3564:	cb 01       	movw	r24, r22
    3566:	8f 83       	std	Y+7, r24	; 0x07
    3568:	98 87       	std	Y+8, r25	; 0x08
    356a:	a9 87       	std	Y+9, r26	; 0x09
    356c:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    356e:	6f 81       	ldd	r22, Y+7	; 0x07
    3570:	78 85       	ldd	r23, Y+8	; 0x08
    3572:	89 85       	ldd	r24, Y+9	; 0x09
    3574:	9a 85       	ldd	r25, Y+10	; 0x0a
    3576:	20 e0       	ldi	r18, 0x00	; 0
    3578:	30 e0       	ldi	r19, 0x00	; 0
    357a:	40 e8       	ldi	r20, 0x80	; 128
    357c:	5f e3       	ldi	r21, 0x3F	; 63
    357e:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    3582:	88 23       	and	r24, r24
    3584:	2c f4       	brge	.+10     	; 0x3590 <SYS_Create_Password_HMI+0x1e4>
		__ticks = 1;
    3586:	81 e0       	ldi	r24, 0x01	; 1
    3588:	90 e0       	ldi	r25, 0x00	; 0
    358a:	9e 83       	std	Y+6, r25	; 0x06
    358c:	8d 83       	std	Y+5, r24	; 0x05
    358e:	3f c0       	rjmp	.+126    	; 0x360e <SYS_Create_Password_HMI+0x262>
	else if (__tmp > 65535)
    3590:	6f 81       	ldd	r22, Y+7	; 0x07
    3592:	78 85       	ldd	r23, Y+8	; 0x08
    3594:	89 85       	ldd	r24, Y+9	; 0x09
    3596:	9a 85       	ldd	r25, Y+10	; 0x0a
    3598:	20 e0       	ldi	r18, 0x00	; 0
    359a:	3f ef       	ldi	r19, 0xFF	; 255
    359c:	4f e7       	ldi	r20, 0x7F	; 127
    359e:	57 e4       	ldi	r21, 0x47	; 71
    35a0:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    35a4:	18 16       	cp	r1, r24
    35a6:	4c f5       	brge	.+82     	; 0x35fa <SYS_Create_Password_HMI+0x24e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    35a8:	6b 85       	ldd	r22, Y+11	; 0x0b
    35aa:	7c 85       	ldd	r23, Y+12	; 0x0c
    35ac:	8d 85       	ldd	r24, Y+13	; 0x0d
    35ae:	9e 85       	ldd	r25, Y+14	; 0x0e
    35b0:	20 e0       	ldi	r18, 0x00	; 0
    35b2:	30 e0       	ldi	r19, 0x00	; 0
    35b4:	40 e2       	ldi	r20, 0x20	; 32
    35b6:	51 e4       	ldi	r21, 0x41	; 65
    35b8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    35bc:	dc 01       	movw	r26, r24
    35be:	cb 01       	movw	r24, r22
    35c0:	bc 01       	movw	r22, r24
    35c2:	cd 01       	movw	r24, r26
    35c4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    35c8:	dc 01       	movw	r26, r24
    35ca:	cb 01       	movw	r24, r22
    35cc:	9e 83       	std	Y+6, r25	; 0x06
    35ce:	8d 83       	std	Y+5, r24	; 0x05
    35d0:	0f c0       	rjmp	.+30     	; 0x35f0 <SYS_Create_Password_HMI+0x244>
    35d2:	88 ec       	ldi	r24, 0xC8	; 200
    35d4:	90 e0       	ldi	r25, 0x00	; 0
    35d6:	9c 83       	std	Y+4, r25	; 0x04
    35d8:	8b 83       	std	Y+3, r24	; 0x03
    35da:	8b 81       	ldd	r24, Y+3	; 0x03
    35dc:	9c 81       	ldd	r25, Y+4	; 0x04
    35de:	01 97       	sbiw	r24, 0x01	; 1
    35e0:	f1 f7       	brne	.-4      	; 0x35de <SYS_Create_Password_HMI+0x232>
    35e2:	9c 83       	std	Y+4, r25	; 0x04
    35e4:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    35e6:	8d 81       	ldd	r24, Y+5	; 0x05
    35e8:	9e 81       	ldd	r25, Y+6	; 0x06
    35ea:	01 97       	sbiw	r24, 0x01	; 1
    35ec:	9e 83       	std	Y+6, r25	; 0x06
    35ee:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    35f0:	8d 81       	ldd	r24, Y+5	; 0x05
    35f2:	9e 81       	ldd	r25, Y+6	; 0x06
    35f4:	00 97       	sbiw	r24, 0x00	; 0
    35f6:	69 f7       	brne	.-38     	; 0x35d2 <SYS_Create_Password_HMI+0x226>
    35f8:	14 c0       	rjmp	.+40     	; 0x3622 <SYS_Create_Password_HMI+0x276>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    35fa:	6f 81       	ldd	r22, Y+7	; 0x07
    35fc:	78 85       	ldd	r23, Y+8	; 0x08
    35fe:	89 85       	ldd	r24, Y+9	; 0x09
    3600:	9a 85       	ldd	r25, Y+10	; 0x0a
    3602:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3606:	dc 01       	movw	r26, r24
    3608:	cb 01       	movw	r24, r22
    360a:	9e 83       	std	Y+6, r25	; 0x06
    360c:	8d 83       	std	Y+5, r24	; 0x05
    360e:	8d 81       	ldd	r24, Y+5	; 0x05
    3610:	9e 81       	ldd	r25, Y+6	; 0x06
    3612:	9a 83       	std	Y+2, r25	; 0x02
    3614:	89 83       	std	Y+1, r24	; 0x01
    3616:	89 81       	ldd	r24, Y+1	; 0x01
    3618:	9a 81       	ldd	r25, Y+2	; 0x02
    361a:	01 97       	sbiw	r24, 0x01	; 1
    361c:	f1 f7       	brne	.-4      	; 0x361a <SYS_Create_Password_HMI+0x26e>
    361e:	9a 83       	std	Y+2, r25	; 0x02
    3620:	89 83       	std	Y+1, r24	; 0x01
		LCD_displayStringRowColumn(0, 1, "Press Enter");
	}
	LCD_clearScreen();
	LCD_displayStringRowColumn(0, 0, "Re-Enter Pass :");
	LCD_moveCursor(1, 0);
	for (i = 0; i < PasswordSize; i++) {
    3622:	8d 8d       	ldd	r24, Y+29	; 0x1d
    3624:	8f 5f       	subi	r24, 0xFF	; 255
    3626:	8d 8f       	std	Y+29, r24	; 0x1d
    3628:	8d 8d       	ldd	r24, Y+29	; 0x1d
    362a:	85 30       	cpi	r24, 0x05	; 5
    362c:	08 f4       	brcc	.+2      	; 0x3630 <SYS_Create_Password_HMI+0x284>
    362e:	7b cf       	rjmp	.-266    	; 0x3526 <SYS_Create_Password_HMI+0x17a>
		passArray2[i] = KEYPAD_getPressedKey();
		LCD_displayCharacter('*');
		_delay_ms(300);
	}
	LCD_clearScreen();
    3630:	0e 94 55 15 	call	0x2aaa	; 0x2aaa <LCD_clearScreen>
    3634:	07 c0       	rjmp	.+14     	; 0x3644 <SYS_Create_Password_HMI+0x298>
	while (KEYPAD_getPressedKey() != '=') {

		LCD_displayStringRowColumn(0, 1, "Press Enter");
    3636:	20 ed       	ldi	r18, 0xD0	; 208
    3638:	30 e0       	ldi	r19, 0x00	; 0
    363a:	80 e0       	ldi	r24, 0x00	; 0
    363c:	61 e0       	ldi	r22, 0x01	; 1
    363e:	a9 01       	movw	r20, r18
    3640:	0e 94 19 15 	call	0x2a32	; 0x2a32 <LCD_displayStringRowColumn>
		passArray2[i] = KEYPAD_getPressedKey();
		LCD_displayCharacter('*');
		_delay_ms(300);
	}
	LCD_clearScreen();
	while (KEYPAD_getPressedKey() != '=') {
    3644:	0e 94 5f 15 	call	0x2abe	; 0x2abe <KEYPAD_getPressedKey>
    3648:	8d 33       	cpi	r24, 0x3D	; 61
    364a:	a9 f7       	brne	.-22     	; 0x3636 <SYS_Create_Password_HMI+0x28a>

		LCD_displayStringRowColumn(0, 1, "Press Enter");
	}

}
    364c:	6d 96       	adiw	r28, 0x1d	; 29
    364e:	0f b6       	in	r0, 0x3f	; 63
    3650:	f8 94       	cli
    3652:	de bf       	out	0x3e, r29	; 62
    3654:	0f be       	out	0x3f, r0	; 63
    3656:	cd bf       	out	0x3d, r28	; 61
    3658:	cf 91       	pop	r28
    365a:	df 91       	pop	r29
    365c:	1f 91       	pop	r17
    365e:	0f 91       	pop	r16
    3660:	08 95       	ret

00003662 <SYS_Send_Password_HMI>:

void SYS_Send_Password_HMI(uint8 *Ptr1ToPass) {
    3662:	df 93       	push	r29
    3664:	cf 93       	push	r28
    3666:	00 d0       	rcall	.+0      	; 0x3668 <SYS_Send_Password_HMI+0x6>
    3668:	0f 92       	push	r0
    366a:	cd b7       	in	r28, 0x3d	; 61
    366c:	de b7       	in	r29, 0x3e	; 62
    366e:	9b 83       	std	Y+3, r25	; 0x03
    3670:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i;
	// Send Password
	for (i = 0; i < PasswordSize; i++) {
    3672:	19 82       	std	Y+1, r1	; 0x01
    3674:	0e c0       	rjmp	.+28     	; 0x3692 <SYS_Send_Password_HMI+0x30>
		UART_sendByte(Ptr1ToPass[i]);
    3676:	89 81       	ldd	r24, Y+1	; 0x01
    3678:	28 2f       	mov	r18, r24
    367a:	30 e0       	ldi	r19, 0x00	; 0
    367c:	8a 81       	ldd	r24, Y+2	; 0x02
    367e:	9b 81       	ldd	r25, Y+3	; 0x03
    3680:	fc 01       	movw	r30, r24
    3682:	e2 0f       	add	r30, r18
    3684:	f3 1f       	adc	r31, r19
    3686:	80 81       	ld	r24, Z
    3688:	0e 94 4a 06 	call	0xc94	; 0xc94 <UART_sendByte>
}

void SYS_Send_Password_HMI(uint8 *Ptr1ToPass) {
	uint8 i;
	// Send Password
	for (i = 0; i < PasswordSize; i++) {
    368c:	89 81       	ldd	r24, Y+1	; 0x01
    368e:	8f 5f       	subi	r24, 0xFF	; 255
    3690:	89 83       	std	Y+1, r24	; 0x01
    3692:	89 81       	ldd	r24, Y+1	; 0x01
    3694:	85 30       	cpi	r24, 0x05	; 5
    3696:	78 f3       	brcs	.-34     	; 0x3676 <SYS_Send_Password_HMI+0x14>
		UART_sendByte(Ptr1ToPass[i]);
	}

}
    3698:	0f 90       	pop	r0
    369a:	0f 90       	pop	r0
    369c:	0f 90       	pop	r0
    369e:	cf 91       	pop	r28
    36a0:	df 91       	pop	r29
    36a2:	08 95       	ret

000036a4 <SYS_Check_Password_HMI>:

void SYS_Check_Password_HMI(void) {
    36a4:	0f 93       	push	r16
    36a6:	1f 93       	push	r17
    36a8:	df 93       	push	r29
    36aa:	cf 93       	push	r28
    36ac:	cd b7       	in	r28, 0x3d	; 61
    36ae:	de b7       	in	r29, 0x3e	; 62
    36b0:	2f 97       	sbiw	r28, 0x0f	; 15
    36b2:	0f b6       	in	r0, 0x3f	; 63
    36b4:	f8 94       	cli
    36b6:	de bf       	out	0x3e, r29	; 62
    36b8:	0f be       	out	0x3f, r0	; 63
    36ba:	cd bf       	out	0x3d, r28	; 61
	uint8 i;
	LCD_clearScreen();
    36bc:	0e 94 55 15 	call	0x2aaa	; 0x2aaa <LCD_clearScreen>
	LCD_displayStringRowColumn(0, 0, "Enter Your Pass");
    36c0:	2c ee       	ldi	r18, 0xEC	; 236
    36c2:	30 e0       	ldi	r19, 0x00	; 0
    36c4:	80 e0       	ldi	r24, 0x00	; 0
    36c6:	60 e0       	ldi	r22, 0x00	; 0
    36c8:	a9 01       	movw	r20, r18
    36ca:	0e 94 19 15 	call	0x2a32	; 0x2a32 <LCD_displayStringRowColumn>
	LCD_moveCursor(1, 0);
    36ce:	81 e0       	ldi	r24, 0x01	; 1
    36d0:	60 e0       	ldi	r22, 0x00	; 0
    36d2:	0e 94 d7 14 	call	0x29ae	; 0x29ae <LCD_moveCursor>
	for (i = 0; i < PasswordSize; i++) {
    36d6:	1f 86       	std	Y+15, r1	; 0x0f
    36d8:	81 c0       	rjmp	.+258    	; 0x37dc <SYS_Check_Password_HMI+0x138>
		passArray3[i] = KEYPAD_getPressedKey();
    36da:	8f 85       	ldd	r24, Y+15	; 0x0f
    36dc:	08 2f       	mov	r16, r24
    36de:	10 e0       	ldi	r17, 0x00	; 0
    36e0:	0e 94 5f 15 	call	0x2abe	; 0x2abe <KEYPAD_getPressedKey>
    36e4:	f8 01       	movw	r30, r16
    36e6:	eb 5a       	subi	r30, 0xAB	; 171
    36e8:	fe 4f       	sbci	r31, 0xFE	; 254
    36ea:	80 83       	st	Z, r24
		LCD_displayCharacter('*');
    36ec:	8a e2       	ldi	r24, 0x2A	; 42
    36ee:	0e 94 33 10 	call	0x2066	; 0x2066 <LCD_displayCharacter>
    36f2:	80 e0       	ldi	r24, 0x00	; 0
    36f4:	90 e0       	ldi	r25, 0x00	; 0
    36f6:	af ea       	ldi	r26, 0xAF	; 175
    36f8:	b3 e4       	ldi	r27, 0x43	; 67
    36fa:	8b 87       	std	Y+11, r24	; 0x0b
    36fc:	9c 87       	std	Y+12, r25	; 0x0c
    36fe:	ad 87       	std	Y+13, r26	; 0x0d
    3700:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3702:	6b 85       	ldd	r22, Y+11	; 0x0b
    3704:	7c 85       	ldd	r23, Y+12	; 0x0c
    3706:	8d 85       	ldd	r24, Y+13	; 0x0d
    3708:	9e 85       	ldd	r25, Y+14	; 0x0e
    370a:	20 e0       	ldi	r18, 0x00	; 0
    370c:	30 e0       	ldi	r19, 0x00	; 0
    370e:	4a ef       	ldi	r20, 0xFA	; 250
    3710:	54 e4       	ldi	r21, 0x44	; 68
    3712:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3716:	dc 01       	movw	r26, r24
    3718:	cb 01       	movw	r24, r22
    371a:	8f 83       	std	Y+7, r24	; 0x07
    371c:	98 87       	std	Y+8, r25	; 0x08
    371e:	a9 87       	std	Y+9, r26	; 0x09
    3720:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    3722:	6f 81       	ldd	r22, Y+7	; 0x07
    3724:	78 85       	ldd	r23, Y+8	; 0x08
    3726:	89 85       	ldd	r24, Y+9	; 0x09
    3728:	9a 85       	ldd	r25, Y+10	; 0x0a
    372a:	20 e0       	ldi	r18, 0x00	; 0
    372c:	30 e0       	ldi	r19, 0x00	; 0
    372e:	40 e8       	ldi	r20, 0x80	; 128
    3730:	5f e3       	ldi	r21, 0x3F	; 63
    3732:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    3736:	88 23       	and	r24, r24
    3738:	2c f4       	brge	.+10     	; 0x3744 <SYS_Check_Password_HMI+0xa0>
		__ticks = 1;
    373a:	81 e0       	ldi	r24, 0x01	; 1
    373c:	90 e0       	ldi	r25, 0x00	; 0
    373e:	9e 83       	std	Y+6, r25	; 0x06
    3740:	8d 83       	std	Y+5, r24	; 0x05
    3742:	3f c0       	rjmp	.+126    	; 0x37c2 <SYS_Check_Password_HMI+0x11e>
	else if (__tmp > 65535)
    3744:	6f 81       	ldd	r22, Y+7	; 0x07
    3746:	78 85       	ldd	r23, Y+8	; 0x08
    3748:	89 85       	ldd	r24, Y+9	; 0x09
    374a:	9a 85       	ldd	r25, Y+10	; 0x0a
    374c:	20 e0       	ldi	r18, 0x00	; 0
    374e:	3f ef       	ldi	r19, 0xFF	; 255
    3750:	4f e7       	ldi	r20, 0x7F	; 127
    3752:	57 e4       	ldi	r21, 0x47	; 71
    3754:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    3758:	18 16       	cp	r1, r24
    375a:	4c f5       	brge	.+82     	; 0x37ae <SYS_Check_Password_HMI+0x10a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    375c:	6b 85       	ldd	r22, Y+11	; 0x0b
    375e:	7c 85       	ldd	r23, Y+12	; 0x0c
    3760:	8d 85       	ldd	r24, Y+13	; 0x0d
    3762:	9e 85       	ldd	r25, Y+14	; 0x0e
    3764:	20 e0       	ldi	r18, 0x00	; 0
    3766:	30 e0       	ldi	r19, 0x00	; 0
    3768:	40 e2       	ldi	r20, 0x20	; 32
    376a:	51 e4       	ldi	r21, 0x41	; 65
    376c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3770:	dc 01       	movw	r26, r24
    3772:	cb 01       	movw	r24, r22
    3774:	bc 01       	movw	r22, r24
    3776:	cd 01       	movw	r24, r26
    3778:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    377c:	dc 01       	movw	r26, r24
    377e:	cb 01       	movw	r24, r22
    3780:	9e 83       	std	Y+6, r25	; 0x06
    3782:	8d 83       	std	Y+5, r24	; 0x05
    3784:	0f c0       	rjmp	.+30     	; 0x37a4 <SYS_Check_Password_HMI+0x100>
    3786:	88 ec       	ldi	r24, 0xC8	; 200
    3788:	90 e0       	ldi	r25, 0x00	; 0
    378a:	9c 83       	std	Y+4, r25	; 0x04
    378c:	8b 83       	std	Y+3, r24	; 0x03
    378e:	8b 81       	ldd	r24, Y+3	; 0x03
    3790:	9c 81       	ldd	r25, Y+4	; 0x04
    3792:	01 97       	sbiw	r24, 0x01	; 1
    3794:	f1 f7       	brne	.-4      	; 0x3792 <SYS_Check_Password_HMI+0xee>
    3796:	9c 83       	std	Y+4, r25	; 0x04
    3798:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    379a:	8d 81       	ldd	r24, Y+5	; 0x05
    379c:	9e 81       	ldd	r25, Y+6	; 0x06
    379e:	01 97       	sbiw	r24, 0x01	; 1
    37a0:	9e 83       	std	Y+6, r25	; 0x06
    37a2:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    37a4:	8d 81       	ldd	r24, Y+5	; 0x05
    37a6:	9e 81       	ldd	r25, Y+6	; 0x06
    37a8:	00 97       	sbiw	r24, 0x00	; 0
    37aa:	69 f7       	brne	.-38     	; 0x3786 <SYS_Check_Password_HMI+0xe2>
    37ac:	14 c0       	rjmp	.+40     	; 0x37d6 <SYS_Check_Password_HMI+0x132>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    37ae:	6f 81       	ldd	r22, Y+7	; 0x07
    37b0:	78 85       	ldd	r23, Y+8	; 0x08
    37b2:	89 85       	ldd	r24, Y+9	; 0x09
    37b4:	9a 85       	ldd	r25, Y+10	; 0x0a
    37b6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    37ba:	dc 01       	movw	r26, r24
    37bc:	cb 01       	movw	r24, r22
    37be:	9e 83       	std	Y+6, r25	; 0x06
    37c0:	8d 83       	std	Y+5, r24	; 0x05
    37c2:	8d 81       	ldd	r24, Y+5	; 0x05
    37c4:	9e 81       	ldd	r25, Y+6	; 0x06
    37c6:	9a 83       	std	Y+2, r25	; 0x02
    37c8:	89 83       	std	Y+1, r24	; 0x01
    37ca:	89 81       	ldd	r24, Y+1	; 0x01
    37cc:	9a 81       	ldd	r25, Y+2	; 0x02
    37ce:	01 97       	sbiw	r24, 0x01	; 1
    37d0:	f1 f7       	brne	.-4      	; 0x37ce <SYS_Check_Password_HMI+0x12a>
    37d2:	9a 83       	std	Y+2, r25	; 0x02
    37d4:	89 83       	std	Y+1, r24	; 0x01
void SYS_Check_Password_HMI(void) {
	uint8 i;
	LCD_clearScreen();
	LCD_displayStringRowColumn(0, 0, "Enter Your Pass");
	LCD_moveCursor(1, 0);
	for (i = 0; i < PasswordSize; i++) {
    37d6:	8f 85       	ldd	r24, Y+15	; 0x0f
    37d8:	8f 5f       	subi	r24, 0xFF	; 255
    37da:	8f 87       	std	Y+15, r24	; 0x0f
    37dc:	8f 85       	ldd	r24, Y+15	; 0x0f
    37de:	85 30       	cpi	r24, 0x05	; 5
    37e0:	08 f4       	brcc	.+2      	; 0x37e4 <SYS_Check_Password_HMI+0x140>
    37e2:	7b cf       	rjmp	.-266    	; 0x36da <SYS_Check_Password_HMI+0x36>
		passArray3[i] = KEYPAD_getPressedKey();
		LCD_displayCharacter('*');
		_delay_ms(350);
	}

}
    37e4:	2f 96       	adiw	r28, 0x0f	; 15
    37e6:	0f b6       	in	r0, 0x3f	; 63
    37e8:	f8 94       	cli
    37ea:	de bf       	out	0x3e, r29	; 62
    37ec:	0f be       	out	0x3f, r0	; 63
    37ee:	cd bf       	out	0x3d, r28	; 61
    37f0:	cf 91       	pop	r28
    37f2:	df 91       	pop	r29
    37f4:	1f 91       	pop	r17
    37f6:	0f 91       	pop	r16
    37f8:	08 95       	ret

000037fa <SYS_MainMenu_HMI>:

void SYS_MainMenu_HMI(void) {
    37fa:	df 93       	push	r29
    37fc:	cf 93       	push	r28
    37fe:	cd b7       	in	r28, 0x3d	; 61
    3800:	de b7       	in	r29, 0x3e	; 62
	LCD_clearScreen();
    3802:	0e 94 55 15 	call	0x2aaa	; 0x2aaa <LCD_clearScreen>
	LCD_displayStringRowColumn(0, 0, "+ :Open Door");
    3806:	2c ef       	ldi	r18, 0xFC	; 252
    3808:	30 e0       	ldi	r19, 0x00	; 0
    380a:	80 e0       	ldi	r24, 0x00	; 0
    380c:	60 e0       	ldi	r22, 0x00	; 0
    380e:	a9 01       	movw	r20, r18
    3810:	0e 94 19 15 	call	0x2a32	; 0x2a32 <LCD_displayStringRowColumn>
	LCD_displayStringRowColumn(1, 0, "- :Change Pass");
    3814:	29 e0       	ldi	r18, 0x09	; 9
    3816:	31 e0       	ldi	r19, 0x01	; 1
    3818:	81 e0       	ldi	r24, 0x01	; 1
    381a:	60 e0       	ldi	r22, 0x00	; 0
    381c:	a9 01       	movw	r20, r18
    381e:	0e 94 19 15 	call	0x2a32	; 0x2a32 <LCD_displayStringRowColumn>
	g_keyPressed = KEYPAD_getPressedKey();
    3822:	0e 94 5f 15 	call	0x2abe	; 0x2abe <KEYPAD_getPressedKey>
    3826:	80 93 5f 01 	sts	0x015F, r24
	if (g_keyPressed == '+' || g_keyPressed == '-') {
    382a:	80 91 5f 01 	lds	r24, 0x015F
    382e:	8b 32       	cpi	r24, 0x2B	; 43
    3830:	21 f0       	breq	.+8      	; 0x383a <SYS_MainMenu_HMI+0x40>
    3832:	80 91 5f 01 	lds	r24, 0x015F
    3836:	8d 32       	cpi	r24, 0x2D	; 45
    3838:	49 f4       	brne	.+18     	; 0x384c <SYS_MainMenu_HMI+0x52>
		SYS_Check_Password_HMI();
    383a:	0e 94 52 1b 	call	0x36a4	; 0x36a4 <SYS_Check_Password_HMI>
		UART_sendByte(SendRequestedPass);
    383e:	80 e5       	ldi	r24, 0x50	; 80
    3840:	0e 94 4a 06 	call	0xc94	; 0xc94 <UART_sendByte>
		SYS_Send_Password_HMI(passArray3);
    3844:	85 e5       	ldi	r24, 0x55	; 85
    3846:	91 e0       	ldi	r25, 0x01	; 1
    3848:	0e 94 31 1b 	call	0x3662	; 0x3662 <SYS_Send_Password_HMI>

	}
}
    384c:	cf 91       	pop	r28
    384e:	df 91       	pop	r29
    3850:	08 95       	ret

00003852 <test>:

void test(void) {
    3852:	df 93       	push	r29
    3854:	cf 93       	push	r28
    3856:	0f 92       	push	r0
    3858:	cd b7       	in	r28, 0x3d	; 61
    385a:	de b7       	in	r29, 0x3e	; 62
	uint8 key = KEYPAD_getPressedKey();
    385c:	0e 94 5f 15 	call	0x2abe	; 0x2abe <KEYPAD_getPressedKey>
    3860:	89 83       	std	Y+1, r24	; 0x01
	UART_sendByte(key);
    3862:	89 81       	ldd	r24, Y+1	; 0x01
    3864:	0e 94 4a 06 	call	0xc94	; 0xc94 <UART_sendByte>
	key = UART_receiveByte();
    3868:	0e 94 3b 06 	call	0xc76	; 0xc76 <UART_receiveByte>
    386c:	89 83       	std	Y+1, r24	; 0x01
	LCD_moveCursor(0, 1);
    386e:	80 e0       	ldi	r24, 0x00	; 0
    3870:	61 e0       	ldi	r22, 0x01	; 1
    3872:	0e 94 d7 14 	call	0x29ae	; 0x29ae <LCD_moveCursor>
	LCD_intgerToString(key);
    3876:	89 81       	ldd	r24, Y+1	; 0x01
    3878:	88 2f       	mov	r24, r24
    387a:	90 e0       	ldi	r25, 0x00	; 0
    387c:	0e 94 32 15 	call	0x2a64	; 0x2a64 <LCD_intgerToString>
	LCD_displayCharacter(' ');
    3880:	80 e2       	ldi	r24, 0x20	; 32
    3882:	0e 94 33 10 	call	0x2066	; 0x2066 <LCD_displayCharacter>

}
    3886:	0f 90       	pop	r0
    3888:	cf 91       	pop	r28
    388a:	df 91       	pop	r29
    388c:	08 95       	ret

0000388e <TimerCounterCallBack>:
void TimerCounterCallBack(void) {
    388e:	df 93       	push	r29
    3890:	cf 93       	push	r28
    3892:	cd b7       	in	r28, 0x3d	; 61
    3894:	de b7       	in	r29, 0x3e	; 62
	// As Configured Timer Ticks Interrupt Every 1 sec
	g_timerCounts++;
    3896:	80 91 4d 01 	lds	r24, 0x014D
    389a:	90 91 4e 01 	lds	r25, 0x014E
    389e:	01 96       	adiw	r24, 0x01	; 1
    38a0:	90 93 4e 01 	sts	0x014E, r25
    38a4:	80 93 4d 01 	sts	0x014D, r24
}
    38a8:	cf 91       	pop	r28
    38aa:	df 91       	pop	r29
    38ac:	08 95       	ret

000038ae <SYS_IncorrectPass>:

void SYS_IncorrectPass(void) {
    38ae:	df 93       	push	r29
    38b0:	cf 93       	push	r28
    38b2:	cd b7       	in	r28, 0x3d	; 61
    38b4:	de b7       	in	r29, 0x3e	; 62
    38b6:	2e 97       	sbiw	r28, 0x0e	; 14
    38b8:	0f b6       	in	r0, 0x3f	; 63
    38ba:	f8 94       	cli
    38bc:	de bf       	out	0x3e, r29	; 62
    38be:	0f be       	out	0x3f, r0	; 63
    38c0:	cd bf       	out	0x3d, r28	; 61
	LCD_clearScreen();
    38c2:	0e 94 55 15 	call	0x2aaa	; 0x2aaa <LCD_clearScreen>
	LCD_displayStringRowColumn(0, 0, "Incorrect Pass");
    38c6:	28 e1       	ldi	r18, 0x18	; 24
    38c8:	31 e0       	ldi	r19, 0x01	; 1
    38ca:	80 e0       	ldi	r24, 0x00	; 0
    38cc:	60 e0       	ldi	r22, 0x00	; 0
    38ce:	a9 01       	movw	r20, r18
    38d0:	0e 94 19 15 	call	0x2a32	; 0x2a32 <LCD_displayStringRowColumn>
	LCD_displayStringRowColumn(1, 0, "  Try Again ");
    38d4:	27 e2       	ldi	r18, 0x27	; 39
    38d6:	31 e0       	ldi	r19, 0x01	; 1
    38d8:	81 e0       	ldi	r24, 0x01	; 1
    38da:	60 e0       	ldi	r22, 0x00	; 0
    38dc:	a9 01       	movw	r20, r18
    38de:	0e 94 19 15 	call	0x2a32	; 0x2a32 <LCD_displayStringRowColumn>
    38e2:	80 e0       	ldi	r24, 0x00	; 0
    38e4:	90 e8       	ldi	r25, 0x80	; 128
    38e6:	ab eb       	ldi	r26, 0xBB	; 187
    38e8:	b4 e4       	ldi	r27, 0x44	; 68
    38ea:	8b 87       	std	Y+11, r24	; 0x0b
    38ec:	9c 87       	std	Y+12, r25	; 0x0c
    38ee:	ad 87       	std	Y+13, r26	; 0x0d
    38f0:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    38f2:	6b 85       	ldd	r22, Y+11	; 0x0b
    38f4:	7c 85       	ldd	r23, Y+12	; 0x0c
    38f6:	8d 85       	ldd	r24, Y+13	; 0x0d
    38f8:	9e 85       	ldd	r25, Y+14	; 0x0e
    38fa:	20 e0       	ldi	r18, 0x00	; 0
    38fc:	30 e0       	ldi	r19, 0x00	; 0
    38fe:	4a ef       	ldi	r20, 0xFA	; 250
    3900:	54 e4       	ldi	r21, 0x44	; 68
    3902:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3906:	dc 01       	movw	r26, r24
    3908:	cb 01       	movw	r24, r22
    390a:	8f 83       	std	Y+7, r24	; 0x07
    390c:	98 87       	std	Y+8, r25	; 0x08
    390e:	a9 87       	std	Y+9, r26	; 0x09
    3910:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    3912:	6f 81       	ldd	r22, Y+7	; 0x07
    3914:	78 85       	ldd	r23, Y+8	; 0x08
    3916:	89 85       	ldd	r24, Y+9	; 0x09
    3918:	9a 85       	ldd	r25, Y+10	; 0x0a
    391a:	20 e0       	ldi	r18, 0x00	; 0
    391c:	30 e0       	ldi	r19, 0x00	; 0
    391e:	40 e8       	ldi	r20, 0x80	; 128
    3920:	5f e3       	ldi	r21, 0x3F	; 63
    3922:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    3926:	88 23       	and	r24, r24
    3928:	2c f4       	brge	.+10     	; 0x3934 <SYS_IncorrectPass+0x86>
		__ticks = 1;
    392a:	81 e0       	ldi	r24, 0x01	; 1
    392c:	90 e0       	ldi	r25, 0x00	; 0
    392e:	9e 83       	std	Y+6, r25	; 0x06
    3930:	8d 83       	std	Y+5, r24	; 0x05
    3932:	3f c0       	rjmp	.+126    	; 0x39b2 <SYS_IncorrectPass+0x104>
	else if (__tmp > 65535)
    3934:	6f 81       	ldd	r22, Y+7	; 0x07
    3936:	78 85       	ldd	r23, Y+8	; 0x08
    3938:	89 85       	ldd	r24, Y+9	; 0x09
    393a:	9a 85       	ldd	r25, Y+10	; 0x0a
    393c:	20 e0       	ldi	r18, 0x00	; 0
    393e:	3f ef       	ldi	r19, 0xFF	; 255
    3940:	4f e7       	ldi	r20, 0x7F	; 127
    3942:	57 e4       	ldi	r21, 0x47	; 71
    3944:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    3948:	18 16       	cp	r1, r24
    394a:	4c f5       	brge	.+82     	; 0x399e <SYS_IncorrectPass+0xf0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    394c:	6b 85       	ldd	r22, Y+11	; 0x0b
    394e:	7c 85       	ldd	r23, Y+12	; 0x0c
    3950:	8d 85       	ldd	r24, Y+13	; 0x0d
    3952:	9e 85       	ldd	r25, Y+14	; 0x0e
    3954:	20 e0       	ldi	r18, 0x00	; 0
    3956:	30 e0       	ldi	r19, 0x00	; 0
    3958:	40 e2       	ldi	r20, 0x20	; 32
    395a:	51 e4       	ldi	r21, 0x41	; 65
    395c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3960:	dc 01       	movw	r26, r24
    3962:	cb 01       	movw	r24, r22
    3964:	bc 01       	movw	r22, r24
    3966:	cd 01       	movw	r24, r26
    3968:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    396c:	dc 01       	movw	r26, r24
    396e:	cb 01       	movw	r24, r22
    3970:	9e 83       	std	Y+6, r25	; 0x06
    3972:	8d 83       	std	Y+5, r24	; 0x05
    3974:	0f c0       	rjmp	.+30     	; 0x3994 <SYS_IncorrectPass+0xe6>
    3976:	88 ec       	ldi	r24, 0xC8	; 200
    3978:	90 e0       	ldi	r25, 0x00	; 0
    397a:	9c 83       	std	Y+4, r25	; 0x04
    397c:	8b 83       	std	Y+3, r24	; 0x03
    397e:	8b 81       	ldd	r24, Y+3	; 0x03
    3980:	9c 81       	ldd	r25, Y+4	; 0x04
    3982:	01 97       	sbiw	r24, 0x01	; 1
    3984:	f1 f7       	brne	.-4      	; 0x3982 <SYS_IncorrectPass+0xd4>
    3986:	9c 83       	std	Y+4, r25	; 0x04
    3988:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    398a:	8d 81       	ldd	r24, Y+5	; 0x05
    398c:	9e 81       	ldd	r25, Y+6	; 0x06
    398e:	01 97       	sbiw	r24, 0x01	; 1
    3990:	9e 83       	std	Y+6, r25	; 0x06
    3992:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3994:	8d 81       	ldd	r24, Y+5	; 0x05
    3996:	9e 81       	ldd	r25, Y+6	; 0x06
    3998:	00 97       	sbiw	r24, 0x00	; 0
    399a:	69 f7       	brne	.-38     	; 0x3976 <SYS_IncorrectPass+0xc8>
    399c:	14 c0       	rjmp	.+40     	; 0x39c6 <SYS_IncorrectPass+0x118>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    399e:	6f 81       	ldd	r22, Y+7	; 0x07
    39a0:	78 85       	ldd	r23, Y+8	; 0x08
    39a2:	89 85       	ldd	r24, Y+9	; 0x09
    39a4:	9a 85       	ldd	r25, Y+10	; 0x0a
    39a6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    39aa:	dc 01       	movw	r26, r24
    39ac:	cb 01       	movw	r24, r22
    39ae:	9e 83       	std	Y+6, r25	; 0x06
    39b0:	8d 83       	std	Y+5, r24	; 0x05
    39b2:	8d 81       	ldd	r24, Y+5	; 0x05
    39b4:	9e 81       	ldd	r25, Y+6	; 0x06
    39b6:	9a 83       	std	Y+2, r25	; 0x02
    39b8:	89 83       	std	Y+1, r24	; 0x01
    39ba:	89 81       	ldd	r24, Y+1	; 0x01
    39bc:	9a 81       	ldd	r25, Y+2	; 0x02
    39be:	01 97       	sbiw	r24, 0x01	; 1
    39c0:	f1 f7       	brne	.-4      	; 0x39be <SYS_IncorrectPass+0x110>
    39c2:	9a 83       	std	Y+2, r25	; 0x02
    39c4:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(1500);
	LCD_clearScreen();
    39c6:	0e 94 55 15 	call	0x2aaa	; 0x2aaa <LCD_clearScreen>
}
    39ca:	2e 96       	adiw	r28, 0x0e	; 14
    39cc:	0f b6       	in	r0, 0x3f	; 63
    39ce:	f8 94       	cli
    39d0:	de bf       	out	0x3e, r29	; 62
    39d2:	0f be       	out	0x3f, r0	; 63
    39d4:	cd bf       	out	0x3d, r28	; 61
    39d6:	cf 91       	pop	r28
    39d8:	df 91       	pop	r29
    39da:	08 95       	ret

000039dc <__udivmodsi4>:
    39dc:	a1 e2       	ldi	r26, 0x21	; 33
    39de:	1a 2e       	mov	r1, r26
    39e0:	aa 1b       	sub	r26, r26
    39e2:	bb 1b       	sub	r27, r27
    39e4:	fd 01       	movw	r30, r26
    39e6:	0d c0       	rjmp	.+26     	; 0x3a02 <__udivmodsi4_ep>

000039e8 <__udivmodsi4_loop>:
    39e8:	aa 1f       	adc	r26, r26
    39ea:	bb 1f       	adc	r27, r27
    39ec:	ee 1f       	adc	r30, r30
    39ee:	ff 1f       	adc	r31, r31
    39f0:	a2 17       	cp	r26, r18
    39f2:	b3 07       	cpc	r27, r19
    39f4:	e4 07       	cpc	r30, r20
    39f6:	f5 07       	cpc	r31, r21
    39f8:	20 f0       	brcs	.+8      	; 0x3a02 <__udivmodsi4_ep>
    39fa:	a2 1b       	sub	r26, r18
    39fc:	b3 0b       	sbc	r27, r19
    39fe:	e4 0b       	sbc	r30, r20
    3a00:	f5 0b       	sbc	r31, r21

00003a02 <__udivmodsi4_ep>:
    3a02:	66 1f       	adc	r22, r22
    3a04:	77 1f       	adc	r23, r23
    3a06:	88 1f       	adc	r24, r24
    3a08:	99 1f       	adc	r25, r25
    3a0a:	1a 94       	dec	r1
    3a0c:	69 f7       	brne	.-38     	; 0x39e8 <__udivmodsi4_loop>
    3a0e:	60 95       	com	r22
    3a10:	70 95       	com	r23
    3a12:	80 95       	com	r24
    3a14:	90 95       	com	r25
    3a16:	9b 01       	movw	r18, r22
    3a18:	ac 01       	movw	r20, r24
    3a1a:	bd 01       	movw	r22, r26
    3a1c:	cf 01       	movw	r24, r30
    3a1e:	08 95       	ret

00003a20 <__prologue_saves__>:
    3a20:	2f 92       	push	r2
    3a22:	3f 92       	push	r3
    3a24:	4f 92       	push	r4
    3a26:	5f 92       	push	r5
    3a28:	6f 92       	push	r6
    3a2a:	7f 92       	push	r7
    3a2c:	8f 92       	push	r8
    3a2e:	9f 92       	push	r9
    3a30:	af 92       	push	r10
    3a32:	bf 92       	push	r11
    3a34:	cf 92       	push	r12
    3a36:	df 92       	push	r13
    3a38:	ef 92       	push	r14
    3a3a:	ff 92       	push	r15
    3a3c:	0f 93       	push	r16
    3a3e:	1f 93       	push	r17
    3a40:	cf 93       	push	r28
    3a42:	df 93       	push	r29
    3a44:	cd b7       	in	r28, 0x3d	; 61
    3a46:	de b7       	in	r29, 0x3e	; 62
    3a48:	ca 1b       	sub	r28, r26
    3a4a:	db 0b       	sbc	r29, r27
    3a4c:	0f b6       	in	r0, 0x3f	; 63
    3a4e:	f8 94       	cli
    3a50:	de bf       	out	0x3e, r29	; 62
    3a52:	0f be       	out	0x3f, r0	; 63
    3a54:	cd bf       	out	0x3d, r28	; 61
    3a56:	09 94       	ijmp

00003a58 <__epilogue_restores__>:
    3a58:	2a 88       	ldd	r2, Y+18	; 0x12
    3a5a:	39 88       	ldd	r3, Y+17	; 0x11
    3a5c:	48 88       	ldd	r4, Y+16	; 0x10
    3a5e:	5f 84       	ldd	r5, Y+15	; 0x0f
    3a60:	6e 84       	ldd	r6, Y+14	; 0x0e
    3a62:	7d 84       	ldd	r7, Y+13	; 0x0d
    3a64:	8c 84       	ldd	r8, Y+12	; 0x0c
    3a66:	9b 84       	ldd	r9, Y+11	; 0x0b
    3a68:	aa 84       	ldd	r10, Y+10	; 0x0a
    3a6a:	b9 84       	ldd	r11, Y+9	; 0x09
    3a6c:	c8 84       	ldd	r12, Y+8	; 0x08
    3a6e:	df 80       	ldd	r13, Y+7	; 0x07
    3a70:	ee 80       	ldd	r14, Y+6	; 0x06
    3a72:	fd 80       	ldd	r15, Y+5	; 0x05
    3a74:	0c 81       	ldd	r16, Y+4	; 0x04
    3a76:	1b 81       	ldd	r17, Y+3	; 0x03
    3a78:	aa 81       	ldd	r26, Y+2	; 0x02
    3a7a:	b9 81       	ldd	r27, Y+1	; 0x01
    3a7c:	ce 0f       	add	r28, r30
    3a7e:	d1 1d       	adc	r29, r1
    3a80:	0f b6       	in	r0, 0x3f	; 63
    3a82:	f8 94       	cli
    3a84:	de bf       	out	0x3e, r29	; 62
    3a86:	0f be       	out	0x3f, r0	; 63
    3a88:	cd bf       	out	0x3d, r28	; 61
    3a8a:	ed 01       	movw	r28, r26
    3a8c:	08 95       	ret

00003a8e <itoa>:
    3a8e:	fb 01       	movw	r30, r22
    3a90:	9f 01       	movw	r18, r30
    3a92:	e8 94       	clt
    3a94:	42 30       	cpi	r20, 0x02	; 2
    3a96:	c4 f0       	brlt	.+48     	; 0x3ac8 <itoa+0x3a>
    3a98:	45 32       	cpi	r20, 0x25	; 37
    3a9a:	b4 f4       	brge	.+44     	; 0x3ac8 <itoa+0x3a>
    3a9c:	4a 30       	cpi	r20, 0x0A	; 10
    3a9e:	29 f4       	brne	.+10     	; 0x3aaa <itoa+0x1c>
    3aa0:	97 fb       	bst	r25, 7
    3aa2:	1e f4       	brtc	.+6      	; 0x3aaa <itoa+0x1c>
    3aa4:	90 95       	com	r25
    3aa6:	81 95       	neg	r24
    3aa8:	9f 4f       	sbci	r25, 0xFF	; 255
    3aaa:	64 2f       	mov	r22, r20
    3aac:	77 27       	eor	r23, r23
    3aae:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <__udivmodhi4>
    3ab2:	80 5d       	subi	r24, 0xD0	; 208
    3ab4:	8a 33       	cpi	r24, 0x3A	; 58
    3ab6:	0c f0       	brlt	.+2      	; 0x3aba <itoa+0x2c>
    3ab8:	89 5d       	subi	r24, 0xD9	; 217
    3aba:	81 93       	st	Z+, r24
    3abc:	cb 01       	movw	r24, r22
    3abe:	00 97       	sbiw	r24, 0x00	; 0
    3ac0:	a1 f7       	brne	.-24     	; 0x3aaa <itoa+0x1c>
    3ac2:	16 f4       	brtc	.+4      	; 0x3ac8 <itoa+0x3a>
    3ac4:	5d e2       	ldi	r21, 0x2D	; 45
    3ac6:	51 93       	st	Z+, r21
    3ac8:	10 82       	st	Z, r1
    3aca:	c9 01       	movw	r24, r18
    3acc:	0c 94 68 1d 	jmp	0x3ad0	; 0x3ad0 <strrev>

00003ad0 <strrev>:
    3ad0:	dc 01       	movw	r26, r24
    3ad2:	fc 01       	movw	r30, r24
    3ad4:	67 2f       	mov	r22, r23
    3ad6:	71 91       	ld	r23, Z+
    3ad8:	77 23       	and	r23, r23
    3ada:	e1 f7       	brne	.-8      	; 0x3ad4 <strrev+0x4>
    3adc:	32 97       	sbiw	r30, 0x02	; 2
    3ade:	04 c0       	rjmp	.+8      	; 0x3ae8 <strrev+0x18>
    3ae0:	7c 91       	ld	r23, X
    3ae2:	6d 93       	st	X+, r22
    3ae4:	70 83       	st	Z, r23
    3ae6:	62 91       	ld	r22, -Z
    3ae8:	ae 17       	cp	r26, r30
    3aea:	bf 07       	cpc	r27, r31
    3aec:	c8 f3       	brcs	.-14     	; 0x3ae0 <strrev+0x10>
    3aee:	08 95       	ret

00003af0 <__udivmodhi4>:
    3af0:	aa 1b       	sub	r26, r26
    3af2:	bb 1b       	sub	r27, r27
    3af4:	51 e1       	ldi	r21, 0x11	; 17
    3af6:	07 c0       	rjmp	.+14     	; 0x3b06 <__udivmodhi4_ep>

00003af8 <__udivmodhi4_loop>:
    3af8:	aa 1f       	adc	r26, r26
    3afa:	bb 1f       	adc	r27, r27
    3afc:	a6 17       	cp	r26, r22
    3afe:	b7 07       	cpc	r27, r23
    3b00:	10 f0       	brcs	.+4      	; 0x3b06 <__udivmodhi4_ep>
    3b02:	a6 1b       	sub	r26, r22
    3b04:	b7 0b       	sbc	r27, r23

00003b06 <__udivmodhi4_ep>:
    3b06:	88 1f       	adc	r24, r24
    3b08:	99 1f       	adc	r25, r25
    3b0a:	5a 95       	dec	r21
    3b0c:	a9 f7       	brne	.-22     	; 0x3af8 <__udivmodhi4_loop>
    3b0e:	80 95       	com	r24
    3b10:	90 95       	com	r25
    3b12:	bc 01       	movw	r22, r24
    3b14:	cd 01       	movw	r24, r26
    3b16:	08 95       	ret

00003b18 <_exit>:
    3b18:	f8 94       	cli

00003b1a <__stop_program>:
    3b1a:	ff cf       	rjmp	.-2      	; 0x3b1a <__stop_program>
