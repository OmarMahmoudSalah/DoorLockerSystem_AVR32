
Control_ECU.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001f0c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000016  00800060  00001f0c  00001fa0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000001b  00800076  00800076  00001fb6  2**0
                  ALLOC
  3 .stab         0000297c  00000000  00000000  00001fb8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000017ad  00000000  00000000  00004934  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  000060e1  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  00006221  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  00006391  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  00007fda  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  00008ec5  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  00009c74  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028d  00000000  00000000  00009dd4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  0000a061  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  0000a82f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 e7 06 	jmp	0xdce	; 0xdce <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 1a 07 	jmp	0xe34	; 0xe34 <__vector_9>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ec e0       	ldi	r30, 0x0C	; 12
      68:	ff e1       	ldi	r31, 0x1F	; 31
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a6 37       	cpi	r26, 0x76	; 118
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	10 e0       	ldi	r17, 0x00	; 0
      78:	a6 e7       	ldi	r26, 0x76	; 118
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a1 39       	cpi	r26, 0x91	; 145
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 df 0c 	call	0x19be	; 0x19be <main>
      8a:	0c 94 84 0f 	jmp	0x1f08	; 0x1f08 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 49 03 	call	0x692	; 0x692 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 4d 0f 	jmp	0x1e9a	; 0x1e9a <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a0 e6       	ldi	r26, 0x60	; 96
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 69 0f 	jmp	0x1ed2	; 0x1ed2 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 59 0f 	jmp	0x1eb2	; 0x1eb2 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 75 0f 	jmp	0x1eea	; 0x1eea <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 59 0f 	jmp	0x1eb2	; 0x1eb2 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 75 0f 	jmp	0x1eea	; 0x1eea <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 4d 0f 	jmp	0x1e9a	; 0x1e9a <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	80 e6       	ldi	r24, 0x60	; 96
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 69 0f 	jmp	0x1ed2	; 0x1ed2 <__epilogue_restores__>

00000632 <__gtsf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 59 0f 	jmp	0x1eb2	; 0x1eb2 <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gtsf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gtsf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gtsf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 75 0f 	jmp	0x1eea	; 0x1eea <__epilogue_restores__+0x18>

00000692 <__gesf2>:
     692:	a8 e1       	ldi	r26, 0x18	; 24
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 59 0f 	jmp	0x1eb2	; 0x1eb2 <__prologue_saves__+0x18>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	2d 83       	std	Y+5, r18	; 0x05
     6a8:	3e 83       	std	Y+6, r19	; 0x06
     6aa:	4f 83       	std	Y+7, r20	; 0x07
     6ac:	58 87       	std	Y+8, r21	; 0x08
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	e8 2e       	mov	r14, r24
     6b2:	f1 2c       	mov	r15, r1
     6b4:	ec 0e       	add	r14, r28
     6b6:	fd 1e       	adc	r15, r29
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	b7 01       	movw	r22, r14
     6be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6c2:	8e 01       	movw	r16, r28
     6c4:	0f 5e       	subi	r16, 0xEF	; 239
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	ce 01       	movw	r24, r28
     6ca:	05 96       	adiw	r24, 0x05	; 5
     6cc:	b8 01       	movw	r22, r16
     6ce:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6d2:	89 85       	ldd	r24, Y+9	; 0x09
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	40 f0       	brcs	.+16     	; 0x6e8 <__gesf2+0x56>
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	28 f0       	brcs	.+10     	; 0x6e8 <__gesf2+0x56>
     6de:	c7 01       	movw	r24, r14
     6e0:	b8 01       	movw	r22, r16
     6e2:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     6e6:	01 c0       	rjmp	.+2      	; 0x6ea <__gesf2+0x58>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	68 96       	adiw	r28, 0x18	; 24
     6ec:	e6 e0       	ldi	r30, 0x06	; 6
     6ee:	0c 94 75 0f 	jmp	0x1eea	; 0x1eea <__epilogue_restores__+0x18>

000006f2 <__ltsf2>:
     6f2:	a8 e1       	ldi	r26, 0x18	; 24
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	ef e7       	ldi	r30, 0x7F	; 127
     6f8:	f3 e0       	ldi	r31, 0x03	; 3
     6fa:	0c 94 59 0f 	jmp	0x1eb2	; 0x1eb2 <__prologue_saves__+0x18>
     6fe:	69 83       	std	Y+1, r22	; 0x01
     700:	7a 83       	std	Y+2, r23	; 0x02
     702:	8b 83       	std	Y+3, r24	; 0x03
     704:	9c 83       	std	Y+4, r25	; 0x04
     706:	2d 83       	std	Y+5, r18	; 0x05
     708:	3e 83       	std	Y+6, r19	; 0x06
     70a:	4f 83       	std	Y+7, r20	; 0x07
     70c:	58 87       	std	Y+8, r21	; 0x08
     70e:	89 e0       	ldi	r24, 0x09	; 9
     710:	e8 2e       	mov	r14, r24
     712:	f1 2c       	mov	r15, r1
     714:	ec 0e       	add	r14, r28
     716:	fd 1e       	adc	r15, r29
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	b7 01       	movw	r22, r14
     71e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     722:	8e 01       	movw	r16, r28
     724:	0f 5e       	subi	r16, 0xEF	; 239
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	ce 01       	movw	r24, r28
     72a:	05 96       	adiw	r24, 0x05	; 5
     72c:	b8 01       	movw	r22, r16
     72e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     732:	89 85       	ldd	r24, Y+9	; 0x09
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	40 f0       	brcs	.+16     	; 0x748 <__ltsf2+0x56>
     738:	89 89       	ldd	r24, Y+17	; 0x11
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	28 f0       	brcs	.+10     	; 0x748 <__ltsf2+0x56>
     73e:	c7 01       	movw	r24, r14
     740:	b8 01       	movw	r22, r16
     742:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     746:	01 c0       	rjmp	.+2      	; 0x74a <__ltsf2+0x58>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	68 96       	adiw	r28, 0x18	; 24
     74c:	e6 e0       	ldi	r30, 0x06	; 6
     74e:	0c 94 75 0f 	jmp	0x1eea	; 0x1eea <__epilogue_restores__+0x18>

00000752 <__fixsfsi>:
     752:	ac e0       	ldi	r26, 0x0C	; 12
     754:	b0 e0       	ldi	r27, 0x00	; 0
     756:	ef ea       	ldi	r30, 0xAF	; 175
     758:	f3 e0       	ldi	r31, 0x03	; 3
     75a:	0c 94 5d 0f 	jmp	0x1eba	; 0x1eba <__prologue_saves__+0x20>
     75e:	69 83       	std	Y+1, r22	; 0x01
     760:	7a 83       	std	Y+2, r23	; 0x02
     762:	8b 83       	std	Y+3, r24	; 0x03
     764:	9c 83       	std	Y+4, r25	; 0x04
     766:	ce 01       	movw	r24, r28
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	be 01       	movw	r22, r28
     76c:	6b 5f       	subi	r22, 0xFB	; 251
     76e:	7f 4f       	sbci	r23, 0xFF	; 255
     770:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     774:	8d 81       	ldd	r24, Y+5	; 0x05
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	61 f1       	breq	.+88     	; 0x7d2 <__fixsfsi+0x80>
     77a:	82 30       	cpi	r24, 0x02	; 2
     77c:	50 f1       	brcs	.+84     	; 0x7d2 <__fixsfsi+0x80>
     77e:	84 30       	cpi	r24, 0x04	; 4
     780:	21 f4       	brne	.+8      	; 0x78a <__fixsfsi+0x38>
     782:	8e 81       	ldd	r24, Y+6	; 0x06
     784:	88 23       	and	r24, r24
     786:	51 f1       	breq	.+84     	; 0x7dc <__fixsfsi+0x8a>
     788:	2e c0       	rjmp	.+92     	; 0x7e6 <__fixsfsi+0x94>
     78a:	2f 81       	ldd	r18, Y+7	; 0x07
     78c:	38 85       	ldd	r19, Y+8	; 0x08
     78e:	37 fd       	sbrc	r19, 7
     790:	20 c0       	rjmp	.+64     	; 0x7d2 <__fixsfsi+0x80>
     792:	6e 81       	ldd	r22, Y+6	; 0x06
     794:	2f 31       	cpi	r18, 0x1F	; 31
     796:	31 05       	cpc	r19, r1
     798:	1c f0       	brlt	.+6      	; 0x7a0 <__fixsfsi+0x4e>
     79a:	66 23       	and	r22, r22
     79c:	f9 f0       	breq	.+62     	; 0x7dc <__fixsfsi+0x8a>
     79e:	23 c0       	rjmp	.+70     	; 0x7e6 <__fixsfsi+0x94>
     7a0:	8e e1       	ldi	r24, 0x1E	; 30
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	82 1b       	sub	r24, r18
     7a6:	93 0b       	sbc	r25, r19
     7a8:	29 85       	ldd	r18, Y+9	; 0x09
     7aa:	3a 85       	ldd	r19, Y+10	; 0x0a
     7ac:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ae:	5c 85       	ldd	r21, Y+12	; 0x0c
     7b0:	04 c0       	rjmp	.+8      	; 0x7ba <__fixsfsi+0x68>
     7b2:	56 95       	lsr	r21
     7b4:	47 95       	ror	r20
     7b6:	37 95       	ror	r19
     7b8:	27 95       	ror	r18
     7ba:	8a 95       	dec	r24
     7bc:	d2 f7       	brpl	.-12     	; 0x7b2 <__fixsfsi+0x60>
     7be:	66 23       	and	r22, r22
     7c0:	b1 f0       	breq	.+44     	; 0x7ee <__fixsfsi+0x9c>
     7c2:	50 95       	com	r21
     7c4:	40 95       	com	r20
     7c6:	30 95       	com	r19
     7c8:	21 95       	neg	r18
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	4f 4f       	sbci	r20, 0xFF	; 255
     7ce:	5f 4f       	sbci	r21, 0xFF	; 255
     7d0:	0e c0       	rjmp	.+28     	; 0x7ee <__fixsfsi+0x9c>
     7d2:	20 e0       	ldi	r18, 0x00	; 0
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	09 c0       	rjmp	.+18     	; 0x7ee <__fixsfsi+0x9c>
     7dc:	2f ef       	ldi	r18, 0xFF	; 255
     7de:	3f ef       	ldi	r19, 0xFF	; 255
     7e0:	4f ef       	ldi	r20, 0xFF	; 255
     7e2:	5f e7       	ldi	r21, 0x7F	; 127
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <__fixsfsi+0x9c>
     7e6:	20 e0       	ldi	r18, 0x00	; 0
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	40 e0       	ldi	r20, 0x00	; 0
     7ec:	50 e8       	ldi	r21, 0x80	; 128
     7ee:	b9 01       	movw	r22, r18
     7f0:	ca 01       	movw	r24, r20
     7f2:	2c 96       	adiw	r28, 0x0c	; 12
     7f4:	e2 e0       	ldi	r30, 0x02	; 2
     7f6:	0c 94 79 0f 	jmp	0x1ef2	; 0x1ef2 <__epilogue_restores__+0x20>

000007fa <__pack_f>:
     7fa:	df 92       	push	r13
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
     802:	1f 93       	push	r17
     804:	fc 01       	movw	r30, r24
     806:	e4 80       	ldd	r14, Z+4	; 0x04
     808:	f5 80       	ldd	r15, Z+5	; 0x05
     80a:	06 81       	ldd	r16, Z+6	; 0x06
     80c:	17 81       	ldd	r17, Z+7	; 0x07
     80e:	d1 80       	ldd	r13, Z+1	; 0x01
     810:	80 81       	ld	r24, Z
     812:	82 30       	cpi	r24, 0x02	; 2
     814:	48 f4       	brcc	.+18     	; 0x828 <__pack_f+0x2e>
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	a0 e1       	ldi	r26, 0x10	; 16
     81c:	b0 e0       	ldi	r27, 0x00	; 0
     81e:	e8 2a       	or	r14, r24
     820:	f9 2a       	or	r15, r25
     822:	0a 2b       	or	r16, r26
     824:	1b 2b       	or	r17, r27
     826:	a5 c0       	rjmp	.+330    	; 0x972 <__stack+0x113>
     828:	84 30       	cpi	r24, 0x04	; 4
     82a:	09 f4       	brne	.+2      	; 0x82e <__pack_f+0x34>
     82c:	9f c0       	rjmp	.+318    	; 0x96c <__stack+0x10d>
     82e:	82 30       	cpi	r24, 0x02	; 2
     830:	21 f4       	brne	.+8      	; 0x83a <__pack_f+0x40>
     832:	ee 24       	eor	r14, r14
     834:	ff 24       	eor	r15, r15
     836:	87 01       	movw	r16, r14
     838:	05 c0       	rjmp	.+10     	; 0x844 <__pack_f+0x4a>
     83a:	e1 14       	cp	r14, r1
     83c:	f1 04       	cpc	r15, r1
     83e:	01 05       	cpc	r16, r1
     840:	11 05       	cpc	r17, r1
     842:	19 f4       	brne	.+6      	; 0x84a <__pack_f+0x50>
     844:	e0 e0       	ldi	r30, 0x00	; 0
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	96 c0       	rjmp	.+300    	; 0x976 <__stack+0x117>
     84a:	62 81       	ldd	r22, Z+2	; 0x02
     84c:	73 81       	ldd	r23, Z+3	; 0x03
     84e:	9f ef       	ldi	r25, 0xFF	; 255
     850:	62 38       	cpi	r22, 0x82	; 130
     852:	79 07       	cpc	r23, r25
     854:	0c f0       	brlt	.+2      	; 0x858 <__pack_f+0x5e>
     856:	5b c0       	rjmp	.+182    	; 0x90e <__stack+0xaf>
     858:	22 e8       	ldi	r18, 0x82	; 130
     85a:	3f ef       	ldi	r19, 0xFF	; 255
     85c:	26 1b       	sub	r18, r22
     85e:	37 0b       	sbc	r19, r23
     860:	2a 31       	cpi	r18, 0x1A	; 26
     862:	31 05       	cpc	r19, r1
     864:	2c f0       	brlt	.+10     	; 0x870 <__stack+0x11>
     866:	20 e0       	ldi	r18, 0x00	; 0
     868:	30 e0       	ldi	r19, 0x00	; 0
     86a:	40 e0       	ldi	r20, 0x00	; 0
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	2a c0       	rjmp	.+84     	; 0x8c4 <__stack+0x65>
     870:	b8 01       	movw	r22, r16
     872:	a7 01       	movw	r20, r14
     874:	02 2e       	mov	r0, r18
     876:	04 c0       	rjmp	.+8      	; 0x880 <__stack+0x21>
     878:	76 95       	lsr	r23
     87a:	67 95       	ror	r22
     87c:	57 95       	ror	r21
     87e:	47 95       	ror	r20
     880:	0a 94       	dec	r0
     882:	d2 f7       	brpl	.-12     	; 0x878 <__stack+0x19>
     884:	81 e0       	ldi	r24, 0x01	; 1
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	a0 e0       	ldi	r26, 0x00	; 0
     88a:	b0 e0       	ldi	r27, 0x00	; 0
     88c:	04 c0       	rjmp	.+8      	; 0x896 <__stack+0x37>
     88e:	88 0f       	add	r24, r24
     890:	99 1f       	adc	r25, r25
     892:	aa 1f       	adc	r26, r26
     894:	bb 1f       	adc	r27, r27
     896:	2a 95       	dec	r18
     898:	d2 f7       	brpl	.-12     	; 0x88e <__stack+0x2f>
     89a:	01 97       	sbiw	r24, 0x01	; 1
     89c:	a1 09       	sbc	r26, r1
     89e:	b1 09       	sbc	r27, r1
     8a0:	8e 21       	and	r24, r14
     8a2:	9f 21       	and	r25, r15
     8a4:	a0 23       	and	r26, r16
     8a6:	b1 23       	and	r27, r17
     8a8:	00 97       	sbiw	r24, 0x00	; 0
     8aa:	a1 05       	cpc	r26, r1
     8ac:	b1 05       	cpc	r27, r1
     8ae:	21 f0       	breq	.+8      	; 0x8b8 <__stack+0x59>
     8b0:	81 e0       	ldi	r24, 0x01	; 1
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	a0 e0       	ldi	r26, 0x00	; 0
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	9a 01       	movw	r18, r20
     8ba:	ab 01       	movw	r20, r22
     8bc:	28 2b       	or	r18, r24
     8be:	39 2b       	or	r19, r25
     8c0:	4a 2b       	or	r20, r26
     8c2:	5b 2b       	or	r21, r27
     8c4:	da 01       	movw	r26, r20
     8c6:	c9 01       	movw	r24, r18
     8c8:	8f 77       	andi	r24, 0x7F	; 127
     8ca:	90 70       	andi	r25, 0x00	; 0
     8cc:	a0 70       	andi	r26, 0x00	; 0
     8ce:	b0 70       	andi	r27, 0x00	; 0
     8d0:	80 34       	cpi	r24, 0x40	; 64
     8d2:	91 05       	cpc	r25, r1
     8d4:	a1 05       	cpc	r26, r1
     8d6:	b1 05       	cpc	r27, r1
     8d8:	39 f4       	brne	.+14     	; 0x8e8 <__stack+0x89>
     8da:	27 ff       	sbrs	r18, 7
     8dc:	09 c0       	rjmp	.+18     	; 0x8f0 <__stack+0x91>
     8de:	20 5c       	subi	r18, 0xC0	; 192
     8e0:	3f 4f       	sbci	r19, 0xFF	; 255
     8e2:	4f 4f       	sbci	r20, 0xFF	; 255
     8e4:	5f 4f       	sbci	r21, 0xFF	; 255
     8e6:	04 c0       	rjmp	.+8      	; 0x8f0 <__stack+0x91>
     8e8:	21 5c       	subi	r18, 0xC1	; 193
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	4f 4f       	sbci	r20, 0xFF	; 255
     8ee:	5f 4f       	sbci	r21, 0xFF	; 255
     8f0:	e0 e0       	ldi	r30, 0x00	; 0
     8f2:	f0 e0       	ldi	r31, 0x00	; 0
     8f4:	20 30       	cpi	r18, 0x00	; 0
     8f6:	a0 e0       	ldi	r26, 0x00	; 0
     8f8:	3a 07       	cpc	r19, r26
     8fa:	a0 e0       	ldi	r26, 0x00	; 0
     8fc:	4a 07       	cpc	r20, r26
     8fe:	a0 e4       	ldi	r26, 0x40	; 64
     900:	5a 07       	cpc	r21, r26
     902:	10 f0       	brcs	.+4      	; 0x908 <__stack+0xa9>
     904:	e1 e0       	ldi	r30, 0x01	; 1
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	79 01       	movw	r14, r18
     90a:	8a 01       	movw	r16, r20
     90c:	27 c0       	rjmp	.+78     	; 0x95c <__stack+0xfd>
     90e:	60 38       	cpi	r22, 0x80	; 128
     910:	71 05       	cpc	r23, r1
     912:	64 f5       	brge	.+88     	; 0x96c <__stack+0x10d>
     914:	fb 01       	movw	r30, r22
     916:	e1 58       	subi	r30, 0x81	; 129
     918:	ff 4f       	sbci	r31, 0xFF	; 255
     91a:	d8 01       	movw	r26, r16
     91c:	c7 01       	movw	r24, r14
     91e:	8f 77       	andi	r24, 0x7F	; 127
     920:	90 70       	andi	r25, 0x00	; 0
     922:	a0 70       	andi	r26, 0x00	; 0
     924:	b0 70       	andi	r27, 0x00	; 0
     926:	80 34       	cpi	r24, 0x40	; 64
     928:	91 05       	cpc	r25, r1
     92a:	a1 05       	cpc	r26, r1
     92c:	b1 05       	cpc	r27, r1
     92e:	39 f4       	brne	.+14     	; 0x93e <__stack+0xdf>
     930:	e7 fe       	sbrs	r14, 7
     932:	0d c0       	rjmp	.+26     	; 0x94e <__stack+0xef>
     934:	80 e4       	ldi	r24, 0x40	; 64
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	a0 e0       	ldi	r26, 0x00	; 0
     93a:	b0 e0       	ldi	r27, 0x00	; 0
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__stack+0xe7>
     93e:	8f e3       	ldi	r24, 0x3F	; 63
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	e8 0e       	add	r14, r24
     948:	f9 1e       	adc	r15, r25
     94a:	0a 1f       	adc	r16, r26
     94c:	1b 1f       	adc	r17, r27
     94e:	17 ff       	sbrs	r17, 7
     950:	05 c0       	rjmp	.+10     	; 0x95c <__stack+0xfd>
     952:	16 95       	lsr	r17
     954:	07 95       	ror	r16
     956:	f7 94       	ror	r15
     958:	e7 94       	ror	r14
     95a:	31 96       	adiw	r30, 0x01	; 1
     95c:	87 e0       	ldi	r24, 0x07	; 7
     95e:	16 95       	lsr	r17
     960:	07 95       	ror	r16
     962:	f7 94       	ror	r15
     964:	e7 94       	ror	r14
     966:	8a 95       	dec	r24
     968:	d1 f7       	brne	.-12     	; 0x95e <__stack+0xff>
     96a:	05 c0       	rjmp	.+10     	; 0x976 <__stack+0x117>
     96c:	ee 24       	eor	r14, r14
     96e:	ff 24       	eor	r15, r15
     970:	87 01       	movw	r16, r14
     972:	ef ef       	ldi	r30, 0xFF	; 255
     974:	f0 e0       	ldi	r31, 0x00	; 0
     976:	6e 2f       	mov	r22, r30
     978:	67 95       	ror	r22
     97a:	66 27       	eor	r22, r22
     97c:	67 95       	ror	r22
     97e:	90 2f       	mov	r25, r16
     980:	9f 77       	andi	r25, 0x7F	; 127
     982:	d7 94       	ror	r13
     984:	dd 24       	eor	r13, r13
     986:	d7 94       	ror	r13
     988:	8e 2f       	mov	r24, r30
     98a:	86 95       	lsr	r24
     98c:	49 2f       	mov	r20, r25
     98e:	46 2b       	or	r20, r22
     990:	58 2f       	mov	r21, r24
     992:	5d 29       	or	r21, r13
     994:	b7 01       	movw	r22, r14
     996:	ca 01       	movw	r24, r20
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	df 90       	pop	r13
     9a2:	08 95       	ret

000009a4 <__unpack_f>:
     9a4:	fc 01       	movw	r30, r24
     9a6:	db 01       	movw	r26, r22
     9a8:	40 81       	ld	r20, Z
     9aa:	51 81       	ldd	r21, Z+1	; 0x01
     9ac:	22 81       	ldd	r18, Z+2	; 0x02
     9ae:	62 2f       	mov	r22, r18
     9b0:	6f 77       	andi	r22, 0x7F	; 127
     9b2:	70 e0       	ldi	r23, 0x00	; 0
     9b4:	22 1f       	adc	r18, r18
     9b6:	22 27       	eor	r18, r18
     9b8:	22 1f       	adc	r18, r18
     9ba:	93 81       	ldd	r25, Z+3	; 0x03
     9bc:	89 2f       	mov	r24, r25
     9be:	88 0f       	add	r24, r24
     9c0:	82 2b       	or	r24, r18
     9c2:	28 2f       	mov	r18, r24
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	99 1f       	adc	r25, r25
     9c8:	99 27       	eor	r25, r25
     9ca:	99 1f       	adc	r25, r25
     9cc:	11 96       	adiw	r26, 0x01	; 1
     9ce:	9c 93       	st	X, r25
     9d0:	11 97       	sbiw	r26, 0x01	; 1
     9d2:	21 15       	cp	r18, r1
     9d4:	31 05       	cpc	r19, r1
     9d6:	a9 f5       	brne	.+106    	; 0xa42 <__unpack_f+0x9e>
     9d8:	41 15       	cp	r20, r1
     9da:	51 05       	cpc	r21, r1
     9dc:	61 05       	cpc	r22, r1
     9de:	71 05       	cpc	r23, r1
     9e0:	11 f4       	brne	.+4      	; 0x9e6 <__unpack_f+0x42>
     9e2:	82 e0       	ldi	r24, 0x02	; 2
     9e4:	37 c0       	rjmp	.+110    	; 0xa54 <__unpack_f+0xb0>
     9e6:	82 e8       	ldi	r24, 0x82	; 130
     9e8:	9f ef       	ldi	r25, 0xFF	; 255
     9ea:	13 96       	adiw	r26, 0x03	; 3
     9ec:	9c 93       	st	X, r25
     9ee:	8e 93       	st	-X, r24
     9f0:	12 97       	sbiw	r26, 0x02	; 2
     9f2:	9a 01       	movw	r18, r20
     9f4:	ab 01       	movw	r20, r22
     9f6:	67 e0       	ldi	r22, 0x07	; 7
     9f8:	22 0f       	add	r18, r18
     9fa:	33 1f       	adc	r19, r19
     9fc:	44 1f       	adc	r20, r20
     9fe:	55 1f       	adc	r21, r21
     a00:	6a 95       	dec	r22
     a02:	d1 f7       	brne	.-12     	; 0x9f8 <__unpack_f+0x54>
     a04:	83 e0       	ldi	r24, 0x03	; 3
     a06:	8c 93       	st	X, r24
     a08:	0d c0       	rjmp	.+26     	; 0xa24 <__unpack_f+0x80>
     a0a:	22 0f       	add	r18, r18
     a0c:	33 1f       	adc	r19, r19
     a0e:	44 1f       	adc	r20, r20
     a10:	55 1f       	adc	r21, r21
     a12:	12 96       	adiw	r26, 0x02	; 2
     a14:	8d 91       	ld	r24, X+
     a16:	9c 91       	ld	r25, X
     a18:	13 97       	sbiw	r26, 0x03	; 3
     a1a:	01 97       	sbiw	r24, 0x01	; 1
     a1c:	13 96       	adiw	r26, 0x03	; 3
     a1e:	9c 93       	st	X, r25
     a20:	8e 93       	st	-X, r24
     a22:	12 97       	sbiw	r26, 0x02	; 2
     a24:	20 30       	cpi	r18, 0x00	; 0
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	38 07       	cpc	r19, r24
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	48 07       	cpc	r20, r24
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	58 07       	cpc	r21, r24
     a32:	58 f3       	brcs	.-42     	; 0xa0a <__unpack_f+0x66>
     a34:	14 96       	adiw	r26, 0x04	; 4
     a36:	2d 93       	st	X+, r18
     a38:	3d 93       	st	X+, r19
     a3a:	4d 93       	st	X+, r20
     a3c:	5c 93       	st	X, r21
     a3e:	17 97       	sbiw	r26, 0x07	; 7
     a40:	08 95       	ret
     a42:	2f 3f       	cpi	r18, 0xFF	; 255
     a44:	31 05       	cpc	r19, r1
     a46:	79 f4       	brne	.+30     	; 0xa66 <__unpack_f+0xc2>
     a48:	41 15       	cp	r20, r1
     a4a:	51 05       	cpc	r21, r1
     a4c:	61 05       	cpc	r22, r1
     a4e:	71 05       	cpc	r23, r1
     a50:	19 f4       	brne	.+6      	; 0xa58 <__unpack_f+0xb4>
     a52:	84 e0       	ldi	r24, 0x04	; 4
     a54:	8c 93       	st	X, r24
     a56:	08 95       	ret
     a58:	64 ff       	sbrs	r22, 4
     a5a:	03 c0       	rjmp	.+6      	; 0xa62 <__unpack_f+0xbe>
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	8c 93       	st	X, r24
     a60:	12 c0       	rjmp	.+36     	; 0xa86 <__unpack_f+0xe2>
     a62:	1c 92       	st	X, r1
     a64:	10 c0       	rjmp	.+32     	; 0xa86 <__unpack_f+0xe2>
     a66:	2f 57       	subi	r18, 0x7F	; 127
     a68:	30 40       	sbci	r19, 0x00	; 0
     a6a:	13 96       	adiw	r26, 0x03	; 3
     a6c:	3c 93       	st	X, r19
     a6e:	2e 93       	st	-X, r18
     a70:	12 97       	sbiw	r26, 0x02	; 2
     a72:	83 e0       	ldi	r24, 0x03	; 3
     a74:	8c 93       	st	X, r24
     a76:	87 e0       	ldi	r24, 0x07	; 7
     a78:	44 0f       	add	r20, r20
     a7a:	55 1f       	adc	r21, r21
     a7c:	66 1f       	adc	r22, r22
     a7e:	77 1f       	adc	r23, r23
     a80:	8a 95       	dec	r24
     a82:	d1 f7       	brne	.-12     	; 0xa78 <__unpack_f+0xd4>
     a84:	70 64       	ori	r23, 0x40	; 64
     a86:	14 96       	adiw	r26, 0x04	; 4
     a88:	4d 93       	st	X+, r20
     a8a:	5d 93       	st	X+, r21
     a8c:	6d 93       	st	X+, r22
     a8e:	7c 93       	st	X, r23
     a90:	17 97       	sbiw	r26, 0x07	; 7
     a92:	08 95       	ret

00000a94 <__fpcmp_parts_f>:
     a94:	1f 93       	push	r17
     a96:	dc 01       	movw	r26, r24
     a98:	fb 01       	movw	r30, r22
     a9a:	9c 91       	ld	r25, X
     a9c:	92 30       	cpi	r25, 0x02	; 2
     a9e:	08 f4       	brcc	.+2      	; 0xaa2 <__fpcmp_parts_f+0xe>
     aa0:	47 c0       	rjmp	.+142    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aa2:	80 81       	ld	r24, Z
     aa4:	82 30       	cpi	r24, 0x02	; 2
     aa6:	08 f4       	brcc	.+2      	; 0xaaa <__fpcmp_parts_f+0x16>
     aa8:	43 c0       	rjmp	.+134    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aaa:	94 30       	cpi	r25, 0x04	; 4
     aac:	51 f4       	brne	.+20     	; 0xac2 <__fpcmp_parts_f+0x2e>
     aae:	11 96       	adiw	r26, 0x01	; 1
     ab0:	1c 91       	ld	r17, X
     ab2:	84 30       	cpi	r24, 0x04	; 4
     ab4:	99 f5       	brne	.+102    	; 0xb1c <__fpcmp_parts_f+0x88>
     ab6:	81 81       	ldd	r24, Z+1	; 0x01
     ab8:	68 2f       	mov	r22, r24
     aba:	70 e0       	ldi	r23, 0x00	; 0
     abc:	61 1b       	sub	r22, r17
     abe:	71 09       	sbc	r23, r1
     ac0:	3f c0       	rjmp	.+126    	; 0xb40 <__fpcmp_parts_f+0xac>
     ac2:	84 30       	cpi	r24, 0x04	; 4
     ac4:	21 f0       	breq	.+8      	; 0xace <__fpcmp_parts_f+0x3a>
     ac6:	92 30       	cpi	r25, 0x02	; 2
     ac8:	31 f4       	brne	.+12     	; 0xad6 <__fpcmp_parts_f+0x42>
     aca:	82 30       	cpi	r24, 0x02	; 2
     acc:	b9 f1       	breq	.+110    	; 0xb3c <__fpcmp_parts_f+0xa8>
     ace:	81 81       	ldd	r24, Z+1	; 0x01
     ad0:	88 23       	and	r24, r24
     ad2:	89 f1       	breq	.+98     	; 0xb36 <__fpcmp_parts_f+0xa2>
     ad4:	2d c0       	rjmp	.+90     	; 0xb30 <__fpcmp_parts_f+0x9c>
     ad6:	11 96       	adiw	r26, 0x01	; 1
     ad8:	1c 91       	ld	r17, X
     ada:	11 97       	sbiw	r26, 0x01	; 1
     adc:	82 30       	cpi	r24, 0x02	; 2
     ade:	f1 f0       	breq	.+60     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae0:	81 81       	ldd	r24, Z+1	; 0x01
     ae2:	18 17       	cp	r17, r24
     ae4:	d9 f4       	brne	.+54     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae6:	12 96       	adiw	r26, 0x02	; 2
     ae8:	2d 91       	ld	r18, X+
     aea:	3c 91       	ld	r19, X
     aec:	13 97       	sbiw	r26, 0x03	; 3
     aee:	82 81       	ldd	r24, Z+2	; 0x02
     af0:	93 81       	ldd	r25, Z+3	; 0x03
     af2:	82 17       	cp	r24, r18
     af4:	93 07       	cpc	r25, r19
     af6:	94 f0       	brlt	.+36     	; 0xb1c <__fpcmp_parts_f+0x88>
     af8:	28 17       	cp	r18, r24
     afa:	39 07       	cpc	r19, r25
     afc:	bc f0       	brlt	.+46     	; 0xb2c <__fpcmp_parts_f+0x98>
     afe:	14 96       	adiw	r26, 0x04	; 4
     b00:	8d 91       	ld	r24, X+
     b02:	9d 91       	ld	r25, X+
     b04:	0d 90       	ld	r0, X+
     b06:	bc 91       	ld	r27, X
     b08:	a0 2d       	mov	r26, r0
     b0a:	24 81       	ldd	r18, Z+4	; 0x04
     b0c:	35 81       	ldd	r19, Z+5	; 0x05
     b0e:	46 81       	ldd	r20, Z+6	; 0x06
     b10:	57 81       	ldd	r21, Z+7	; 0x07
     b12:	28 17       	cp	r18, r24
     b14:	39 07       	cpc	r19, r25
     b16:	4a 07       	cpc	r20, r26
     b18:	5b 07       	cpc	r21, r27
     b1a:	18 f4       	brcc	.+6      	; 0xb22 <__fpcmp_parts_f+0x8e>
     b1c:	11 23       	and	r17, r17
     b1e:	41 f0       	breq	.+16     	; 0xb30 <__fpcmp_parts_f+0x9c>
     b20:	0a c0       	rjmp	.+20     	; 0xb36 <__fpcmp_parts_f+0xa2>
     b22:	82 17       	cp	r24, r18
     b24:	93 07       	cpc	r25, r19
     b26:	a4 07       	cpc	r26, r20
     b28:	b5 07       	cpc	r27, r21
     b2a:	40 f4       	brcc	.+16     	; 0xb3c <__fpcmp_parts_f+0xa8>
     b2c:	11 23       	and	r17, r17
     b2e:	19 f0       	breq	.+6      	; 0xb36 <__fpcmp_parts_f+0xa2>
     b30:	61 e0       	ldi	r22, 0x01	; 1
     b32:	70 e0       	ldi	r23, 0x00	; 0
     b34:	05 c0       	rjmp	.+10     	; 0xb40 <__fpcmp_parts_f+0xac>
     b36:	6f ef       	ldi	r22, 0xFF	; 255
     b38:	7f ef       	ldi	r23, 0xFF	; 255
     b3a:	02 c0       	rjmp	.+4      	; 0xb40 <__fpcmp_parts_f+0xac>
     b3c:	60 e0       	ldi	r22, 0x00	; 0
     b3e:	70 e0       	ldi	r23, 0x00	; 0
     b40:	cb 01       	movw	r24, r22
     b42:	1f 91       	pop	r17
     b44:	08 95       	ret

00000b46 <UART_init>:

#include "uart.h"
#include <avr/io.h>
#include "../../General/common_macros.h"

void UART_init(const UART_ConfigType *Config_Ptr) {
     b46:	df 93       	push	r29
     b48:	cf 93       	push	r28
     b4a:	00 d0       	rcall	.+0      	; 0xb4c <UART_init+0x6>
     b4c:	00 d0       	rcall	.+0      	; 0xb4e <UART_init+0x8>
     b4e:	cd b7       	in	r28, 0x3d	; 61
     b50:	de b7       	in	r29, 0x3e	; 62
     b52:	9c 83       	std	Y+4, r25	; 0x04
     b54:	8b 83       	std	Y+3, r24	; 0x03
	uint16 ubrr_value = 0;
     b56:	1a 82       	std	Y+2, r1	; 0x02
     b58:	19 82       	std	Y+1, r1	; 0x01

	// UCSRA - USART Control and Status Register A
	//U2X: Double the USART Transmission Speed
	UCSRA = (1 << U2X);
     b5a:	eb e2       	ldi	r30, 0x2B	; 43
     b5c:	f0 e0       	ldi	r31, 0x00	; 0
     b5e:	82 e0       	ldi	r24, 0x02	; 2
     b60:	80 83       	st	Z, r24
	/*
	 * Bit 4  RXEN: Receiver Enable
	 * Bit 3  TXEN: Transmitter Enable
	 *
	 * */
	UCSRB = (1 << TXEN) | (1 << RXEN);
     b62:	ea e2       	ldi	r30, 0x2A	; 42
     b64:	f0 e0       	ldi	r31, 0x00	; 0
     b66:	88 e1       	ldi	r24, 0x18	; 24
     b68:	80 83       	st	Z, r24
	 *  Bit 2:1  UCSZ1:0: DATA Size)
	 *
	 * */

	//URSEL: Register Select
	SET_BIT(UCSRC, URSEL);
     b6a:	a0 e4       	ldi	r26, 0x40	; 64
     b6c:	b0 e0       	ldi	r27, 0x00	; 0
     b6e:	e0 e4       	ldi	r30, 0x40	; 64
     b70:	f0 e0       	ldi	r31, 0x00	; 0
     b72:	80 81       	ld	r24, Z
     b74:	80 68       	ori	r24, 0x80	; 128
     b76:	8c 93       	st	X, r24
	//Asynchronous Operation
	CLEAR_BIT(UCSRC, UMSEL);
     b78:	a0 e4       	ldi	r26, 0x40	; 64
     b7a:	b0 e0       	ldi	r27, 0x00	; 0
     b7c:	e0 e4       	ldi	r30, 0x40	; 64
     b7e:	f0 e0       	ldi	r31, 0x00	; 0
     b80:	80 81       	ld	r24, Z
     b82:	8f 7b       	andi	r24, 0xBF	; 191
     b84:	8c 93       	st	X, r24

	//Parity Configuration
	UCSRC = (UCSRC & 0XCF) | ((Config_Ptr->parity) << 4);
     b86:	a0 e4       	ldi	r26, 0x40	; 64
     b88:	b0 e0       	ldi	r27, 0x00	; 0
     b8a:	e0 e4       	ldi	r30, 0x40	; 64
     b8c:	f0 e0       	ldi	r31, 0x00	; 0
     b8e:	80 81       	ld	r24, Z
     b90:	28 2f       	mov	r18, r24
     b92:	2f 7c       	andi	r18, 0xCF	; 207
     b94:	eb 81       	ldd	r30, Y+3	; 0x03
     b96:	fc 81       	ldd	r31, Y+4	; 0x04
     b98:	81 81       	ldd	r24, Z+1	; 0x01
     b9a:	88 2f       	mov	r24, r24
     b9c:	90 e0       	ldi	r25, 0x00	; 0
     b9e:	82 95       	swap	r24
     ba0:	92 95       	swap	r25
     ba2:	90 7f       	andi	r25, 0xF0	; 240
     ba4:	98 27       	eor	r25, r24
     ba6:	80 7f       	andi	r24, 0xF0	; 240
     ba8:	98 27       	eor	r25, r24
     baa:	82 2b       	or	r24, r18
     bac:	8c 93       	st	X, r24
	//Stop bit Configuration
	UCSRC = (UCSRC & 0XF7) | ((Config_Ptr->stop_bit) << 3);
     bae:	a0 e4       	ldi	r26, 0x40	; 64
     bb0:	b0 e0       	ldi	r27, 0x00	; 0
     bb2:	e0 e4       	ldi	r30, 0x40	; 64
     bb4:	f0 e0       	ldi	r31, 0x00	; 0
     bb6:	80 81       	ld	r24, Z
     bb8:	28 2f       	mov	r18, r24
     bba:	27 7f       	andi	r18, 0xF7	; 247
     bbc:	eb 81       	ldd	r30, Y+3	; 0x03
     bbe:	fc 81       	ldd	r31, Y+4	; 0x04
     bc0:	82 81       	ldd	r24, Z+2	; 0x02
     bc2:	88 2f       	mov	r24, r24
     bc4:	90 e0       	ldi	r25, 0x00	; 0
     bc6:	88 0f       	add	r24, r24
     bc8:	99 1f       	adc	r25, r25
     bca:	88 0f       	add	r24, r24
     bcc:	99 1f       	adc	r25, r25
     bce:	88 0f       	add	r24, r24
     bd0:	99 1f       	adc	r25, r25
     bd2:	82 2b       	or	r24, r18
     bd4:	8c 93       	st	X, r24
	//Data Size Configuration
	UCSRC = (UCSRC & 0XF9) | ((Config_Ptr->bit_data) << 1);
     bd6:	a0 e4       	ldi	r26, 0x40	; 64
     bd8:	b0 e0       	ldi	r27, 0x00	; 0
     bda:	e0 e4       	ldi	r30, 0x40	; 64
     bdc:	f0 e0       	ldi	r31, 0x00	; 0
     bde:	80 81       	ld	r24, Z
     be0:	28 2f       	mov	r18, r24
     be2:	29 7f       	andi	r18, 0xF9	; 249
     be4:	eb 81       	ldd	r30, Y+3	; 0x03
     be6:	fc 81       	ldd	r31, Y+4	; 0x04
     be8:	80 81       	ld	r24, Z
     bea:	88 2f       	mov	r24, r24
     bec:	90 e0       	ldi	r25, 0x00	; 0
     bee:	88 0f       	add	r24, r24
     bf0:	99 1f       	adc	r25, r25
     bf2:	82 2b       	or	r24, r18
     bf4:	8c 93       	st	X, r24
	//Get Value of Last bit in a 3 bit Number and UCSZ2
	//Easier Solution - Only the 1 appears in 9bit so can do if cond. with it
	UCSRB = (UCSRB & 0XFB) | ((GET_BIT(Config_Ptr->bit_data, 2)) << 2);
     bf6:	aa e2       	ldi	r26, 0x2A	; 42
     bf8:	b0 e0       	ldi	r27, 0x00	; 0
     bfa:	ea e2       	ldi	r30, 0x2A	; 42
     bfc:	f0 e0       	ldi	r31, 0x00	; 0
     bfe:	80 81       	ld	r24, Z
     c00:	98 2f       	mov	r25, r24
     c02:	9b 7f       	andi	r25, 0xFB	; 251
     c04:	eb 81       	ldd	r30, Y+3	; 0x03
     c06:	fc 81       	ldd	r31, Y+4	; 0x04
     c08:	80 81       	ld	r24, Z
     c0a:	84 70       	andi	r24, 0x04	; 4
     c0c:	89 2b       	or	r24, r25
     c0e:	8c 93       	st	X, r24

	ubrr_value = (uint16) (((F_CPU / ((Config_Ptr->baud_rate) * 8UL))) - 1);
     c10:	eb 81       	ldd	r30, Y+3	; 0x03
     c12:	fc 81       	ldd	r31, Y+4	; 0x04
     c14:	83 81       	ldd	r24, Z+3	; 0x03
     c16:	94 81       	ldd	r25, Z+4	; 0x04
     c18:	a5 81       	ldd	r26, Z+5	; 0x05
     c1a:	b6 81       	ldd	r27, Z+6	; 0x06
     c1c:	88 0f       	add	r24, r24
     c1e:	99 1f       	adc	r25, r25
     c20:	aa 1f       	adc	r26, r26
     c22:	bb 1f       	adc	r27, r27
     c24:	88 0f       	add	r24, r24
     c26:	99 1f       	adc	r25, r25
     c28:	aa 1f       	adc	r26, r26
     c2a:	bb 1f       	adc	r27, r27
     c2c:	88 0f       	add	r24, r24
     c2e:	99 1f       	adc	r25, r25
     c30:	aa 1f       	adc	r26, r26
     c32:	bb 1f       	adc	r27, r27
     c34:	9c 01       	movw	r18, r24
     c36:	ad 01       	movw	r20, r26
     c38:	80 e0       	ldi	r24, 0x00	; 0
     c3a:	92 e1       	ldi	r25, 0x12	; 18
     c3c:	aa e7       	ldi	r26, 0x7A	; 122
     c3e:	b0 e0       	ldi	r27, 0x00	; 0
     c40:	bc 01       	movw	r22, r24
     c42:	cd 01       	movw	r24, r26
     c44:	0e 94 2b 0f 	call	0x1e56	; 0x1e56 <__udivmodsi4>
     c48:	da 01       	movw	r26, r20
     c4a:	c9 01       	movw	r24, r18
     c4c:	01 97       	sbiw	r24, 0x01	; 1
     c4e:	9a 83       	std	Y+2, r25	; 0x02
     c50:	89 83       	std	Y+1, r24	; 0x01
	/* First 8 bits from the BAUD_PRESCALE inside UBRRL and last 4 bits in UBRRH*/
	UBRRH = ubrr_value >> 8;
     c52:	e0 e4       	ldi	r30, 0x40	; 64
     c54:	f0 e0       	ldi	r31, 0x00	; 0
     c56:	89 81       	ldd	r24, Y+1	; 0x01
     c58:	9a 81       	ldd	r25, Y+2	; 0x02
     c5a:	89 2f       	mov	r24, r25
     c5c:	99 27       	eor	r25, r25
     c5e:	80 83       	st	Z, r24
	UBRRL = ubrr_value;
     c60:	e9 e2       	ldi	r30, 0x29	; 41
     c62:	f0 e0       	ldi	r31, 0x00	; 0
     c64:	89 81       	ldd	r24, Y+1	; 0x01
     c66:	80 83       	st	Z, r24
}
     c68:	0f 90       	pop	r0
     c6a:	0f 90       	pop	r0
     c6c:	0f 90       	pop	r0
     c6e:	0f 90       	pop	r0
     c70:	cf 91       	pop	r28
     c72:	df 91       	pop	r29
     c74:	08 95       	ret

00000c76 <UART_receiveByte>:

uint8 UART_receiveByte(void) {
     c76:	df 93       	push	r29
     c78:	cf 93       	push	r28
     c7a:	cd b7       	in	r28, 0x3d	; 61
     c7c:	de b7       	in	r29, 0x3e	; 62
	/*Bit 7  RXC: USART Receive Complete
	 This flag bit is set when there are unread data in the receive buffer
	 and cleared when the receive buffer is empty (i.e., does not contain any unread data).
	 * */
	while ((BIT_IS_CLEAR(UCSRA, RXC)))
     c7e:	eb e2       	ldi	r30, 0x2B	; 43
     c80:	f0 e0       	ldi	r31, 0x00	; 0
     c82:	80 81       	ld	r24, Z
     c84:	88 23       	and	r24, r24
     c86:	dc f7       	brge	.-10     	; 0xc7e <UART_receiveByte+0x8>
		;
	return UDR;
     c88:	ec e2       	ldi	r30, 0x2C	; 44
     c8a:	f0 e0       	ldi	r31, 0x00	; 0
     c8c:	80 81       	ld	r24, Z
}
     c8e:	cf 91       	pop	r28
     c90:	df 91       	pop	r29
     c92:	08 95       	ret

00000c94 <UART_sendByte>:

void UART_sendByte(uint8 data) {
     c94:	df 93       	push	r29
     c96:	cf 93       	push	r28
     c98:	0f 92       	push	r0
     c9a:	cd b7       	in	r28, 0x3d	; 61
     c9c:	de b7       	in	r29, 0x3e	; 62
     c9e:	89 83       	std	Y+1, r24	; 0x01
	/*Bit 5  UDRE: USART Data Register Empty
	 * The UDRE Flag indicates if the transmit buffer (UDR) is ready to receive new data.
	 * If UDRE is one, the buffer is empty, and therefore ready to be written.
	 * */
	while (BIT_IS_CLEAR(UCSRA, UDRE))
     ca0:	eb e2       	ldi	r30, 0x2B	; 43
     ca2:	f0 e0       	ldi	r31, 0x00	; 0
     ca4:	80 81       	ld	r24, Z
     ca6:	88 2f       	mov	r24, r24
     ca8:	90 e0       	ldi	r25, 0x00	; 0
     caa:	80 72       	andi	r24, 0x20	; 32
     cac:	90 70       	andi	r25, 0x00	; 0
     cae:	00 97       	sbiw	r24, 0x00	; 0
     cb0:	b9 f3       	breq	.-18     	; 0xca0 <UART_sendByte+0xc>
		;
	UDR = data;
     cb2:	ec e2       	ldi	r30, 0x2C	; 44
     cb4:	f0 e0       	ldi	r31, 0x00	; 0
     cb6:	89 81       	ldd	r24, Y+1	; 0x01
     cb8:	80 83       	st	Z, r24
}
     cba:	0f 90       	pop	r0
     cbc:	cf 91       	pop	r28
     cbe:	df 91       	pop	r29
     cc0:	08 95       	ret

00000cc2 <UART_sendString>:

void UART_sendString(const uint8 *str) {
     cc2:	df 93       	push	r29
     cc4:	cf 93       	push	r28
     cc6:	00 d0       	rcall	.+0      	; 0xcc8 <UART_sendString+0x6>
     cc8:	0f 92       	push	r0
     cca:	cd b7       	in	r28, 0x3d	; 61
     ccc:	de b7       	in	r29, 0x3e	; 62
     cce:	9b 83       	std	Y+3, r25	; 0x03
     cd0:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
     cd2:	19 82       	std	Y+1, r1	; 0x01
     cd4:	0e c0       	rjmp	.+28     	; 0xcf2 <UART_sendString+0x30>

	while (str[i] != '\0') {
		UART_sendByte(str[i]);
     cd6:	89 81       	ldd	r24, Y+1	; 0x01
     cd8:	28 2f       	mov	r18, r24
     cda:	30 e0       	ldi	r19, 0x00	; 0
     cdc:	8a 81       	ldd	r24, Y+2	; 0x02
     cde:	9b 81       	ldd	r25, Y+3	; 0x03
     ce0:	fc 01       	movw	r30, r24
     ce2:	e2 0f       	add	r30, r18
     ce4:	f3 1f       	adc	r31, r19
     ce6:	80 81       	ld	r24, Z
     ce8:	0e 94 4a 06 	call	0xc94	; 0xc94 <UART_sendByte>
		i++;
     cec:	89 81       	ldd	r24, Y+1	; 0x01
     cee:	8f 5f       	subi	r24, 0xFF	; 255
     cf0:	89 83       	std	Y+1, r24	; 0x01
}

void UART_sendString(const uint8 *str) {
	uint8 i = 0;

	while (str[i] != '\0') {
     cf2:	89 81       	ldd	r24, Y+1	; 0x01
     cf4:	28 2f       	mov	r18, r24
     cf6:	30 e0       	ldi	r19, 0x00	; 0
     cf8:	8a 81       	ldd	r24, Y+2	; 0x02
     cfa:	9b 81       	ldd	r25, Y+3	; 0x03
     cfc:	fc 01       	movw	r30, r24
     cfe:	e2 0f       	add	r30, r18
     d00:	f3 1f       	adc	r31, r19
     d02:	80 81       	ld	r24, Z
     d04:	88 23       	and	r24, r24
     d06:	39 f7       	brne	.-50     	; 0xcd6 <UART_sendString+0x14>
		UART_sendByte(str[i]);
		i++;
	}
}
     d08:	0f 90       	pop	r0
     d0a:	0f 90       	pop	r0
     d0c:	0f 90       	pop	r0
     d0e:	cf 91       	pop	r28
     d10:	df 91       	pop	r29
     d12:	08 95       	ret

00000d14 <UART_receiveString>:

void UART_receiveString(uint8 *Str) {
     d14:	0f 93       	push	r16
     d16:	1f 93       	push	r17
     d18:	df 93       	push	r29
     d1a:	cf 93       	push	r28
     d1c:	00 d0       	rcall	.+0      	; 0xd1e <UART_receiveString+0xa>
     d1e:	0f 92       	push	r0
     d20:	cd b7       	in	r28, 0x3d	; 61
     d22:	de b7       	in	r29, 0x3e	; 62
     d24:	9b 83       	std	Y+3, r25	; 0x03
     d26:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
     d28:	19 82       	std	Y+1, r1	; 0x01

	/* Receive the first byte */
	Str[i] = UART_receiveByte();
     d2a:	89 81       	ldd	r24, Y+1	; 0x01
     d2c:	28 2f       	mov	r18, r24
     d2e:	30 e0       	ldi	r19, 0x00	; 0
     d30:	8a 81       	ldd	r24, Y+2	; 0x02
     d32:	9b 81       	ldd	r25, Y+3	; 0x03
     d34:	8c 01       	movw	r16, r24
     d36:	02 0f       	add	r16, r18
     d38:	13 1f       	adc	r17, r19
     d3a:	0e 94 3b 06 	call	0xc76	; 0xc76 <UART_receiveByte>
     d3e:	f8 01       	movw	r30, r16
     d40:	80 83       	st	Z, r24
     d42:	0f c0       	rjmp	.+30     	; 0xd62 <UART_receiveString+0x4e>

	/* Receive the whole string until the '#' */
	while (Str[i] != '#') {
		i++;
     d44:	89 81       	ldd	r24, Y+1	; 0x01
     d46:	8f 5f       	subi	r24, 0xFF	; 255
     d48:	89 83       	std	Y+1, r24	; 0x01
		Str[i] = UART_receiveByte();
     d4a:	89 81       	ldd	r24, Y+1	; 0x01
     d4c:	28 2f       	mov	r18, r24
     d4e:	30 e0       	ldi	r19, 0x00	; 0
     d50:	8a 81       	ldd	r24, Y+2	; 0x02
     d52:	9b 81       	ldd	r25, Y+3	; 0x03
     d54:	8c 01       	movw	r16, r24
     d56:	02 0f       	add	r16, r18
     d58:	13 1f       	adc	r17, r19
     d5a:	0e 94 3b 06 	call	0xc76	; 0xc76 <UART_receiveByte>
     d5e:	f8 01       	movw	r30, r16
     d60:	80 83       	st	Z, r24

	/* Receive the first byte */
	Str[i] = UART_receiveByte();

	/* Receive the whole string until the '#' */
	while (Str[i] != '#') {
     d62:	89 81       	ldd	r24, Y+1	; 0x01
     d64:	28 2f       	mov	r18, r24
     d66:	30 e0       	ldi	r19, 0x00	; 0
     d68:	8a 81       	ldd	r24, Y+2	; 0x02
     d6a:	9b 81       	ldd	r25, Y+3	; 0x03
     d6c:	fc 01       	movw	r30, r24
     d6e:	e2 0f       	add	r30, r18
     d70:	f3 1f       	adc	r31, r19
     d72:	80 81       	ld	r24, Z
     d74:	83 32       	cpi	r24, 0x23	; 35
     d76:	31 f7       	brne	.-52     	; 0xd44 <UART_receiveString+0x30>
		i++;
		Str[i] = UART_receiveByte();
	}

	/* After receiving the whole string plus the '#', replace the '#' with '\0' */
	Str[i] = '\0';
     d78:	89 81       	ldd	r24, Y+1	; 0x01
     d7a:	28 2f       	mov	r18, r24
     d7c:	30 e0       	ldi	r19, 0x00	; 0
     d7e:	8a 81       	ldd	r24, Y+2	; 0x02
     d80:	9b 81       	ldd	r25, Y+3	; 0x03
     d82:	fc 01       	movw	r30, r24
     d84:	e2 0f       	add	r30, r18
     d86:	f3 1f       	adc	r31, r19
     d88:	10 82       	st	Z, r1
}
     d8a:	0f 90       	pop	r0
     d8c:	0f 90       	pop	r0
     d8e:	0f 90       	pop	r0
     d90:	cf 91       	pop	r28
     d92:	df 91       	pop	r29
     d94:	1f 91       	pop	r17
     d96:	0f 91       	pop	r16
     d98:	08 95       	ret

00000d9a <PWM_Timer0_Start>:
 */

#include "Timer_0PWM.h"


void PWM_Timer0_Start(uint8 duty_cycle) {
     d9a:	df 93       	push	r29
     d9c:	cf 93       	push	r28
     d9e:	0f 92       	push	r0
     da0:	cd b7       	in	r28, 0x3d	; 61
     da2:	de b7       	in	r29, 0x3e	; 62
     da4:	89 83       	std	Y+1, r24	; 0x01
	//COM01 COM00
	//1 	0

	// CS02 CS01 CS00 Description
	//010 clkI/O/8 (From prescaler)
	TCNT0 = 0;
     da6:	e2 e5       	ldi	r30, 0x52	; 82
     da8:	f0 e0       	ldi	r31, 0x00	; 0
     daa:	10 82       	st	Z, r1
	OCR0 = duty_cycle;
     dac:	ec e5       	ldi	r30, 0x5C	; 92
     dae:	f0 e0       	ldi	r31, 0x00	; 0
     db0:	89 81       	ldd	r24, Y+1	; 0x01
     db2:	80 83       	st	Z, r24
	TCCR0 = (1 << WGM00) | (1 << WGM01) | (1 << COM01) | (1 << CS01);
     db4:	e3 e5       	ldi	r30, 0x53	; 83
     db6:	f0 e0       	ldi	r31, 0x00	; 0
     db8:	8a e6       	ldi	r24, 0x6A	; 106
     dba:	80 83       	st	Z, r24
	// Setup the direction for OC0 as output pin through the GPIO driver
	GPIO_setupPinDirection(PORTB_ID,PIN3_ID,PIN_OUTPUT);
     dbc:	81 e0       	ldi	r24, 0x01	; 1
     dbe:	63 e0       	ldi	r22, 0x03	; 3
     dc0:	41 e0       	ldi	r20, 0x01	; 1
     dc2:	0e 94 71 08 	call	0x10e2	; 0x10e2 <GPIO_setupPinDirection>

}
     dc6:	0f 90       	pop	r0
     dc8:	cf 91       	pop	r28
     dca:	df 91       	pop	r29
     dcc:	08 95       	ret

00000dce <__vector_7>:

/*******************************************************************************
 *                       Interrupt Service Routines                            *
 *******************************************************************************/

ISR(TIMER1_COMPA_vect) {
     dce:	1f 92       	push	r1
     dd0:	0f 92       	push	r0
     dd2:	0f b6       	in	r0, 0x3f	; 63
     dd4:	0f 92       	push	r0
     dd6:	11 24       	eor	r1, r1
     dd8:	2f 93       	push	r18
     dda:	3f 93       	push	r19
     ddc:	4f 93       	push	r20
     dde:	5f 93       	push	r21
     de0:	6f 93       	push	r22
     de2:	7f 93       	push	r23
     de4:	8f 93       	push	r24
     de6:	9f 93       	push	r25
     de8:	af 93       	push	r26
     dea:	bf 93       	push	r27
     dec:	ef 93       	push	r30
     dee:	ff 93       	push	r31
     df0:	df 93       	push	r29
     df2:	cf 93       	push	r28
     df4:	cd b7       	in	r28, 0x3d	; 61
     df6:	de b7       	in	r29, 0x3e	; 62
	if (g_callBackPtr != NULL_PTR) {
     df8:	80 91 76 00 	lds	r24, 0x0076
     dfc:	90 91 77 00 	lds	r25, 0x0077
     e00:	00 97       	sbiw	r24, 0x00	; 0
     e02:	29 f0       	breq	.+10     	; 0xe0e <__vector_7+0x40>
		(*g_callBackPtr)(); /* another method to call the function using pointer to function g_callBackPtr(); */
     e04:	e0 91 76 00 	lds	r30, 0x0076
     e08:	f0 91 77 00 	lds	r31, 0x0077
     e0c:	09 95       	icall
	}
}
     e0e:	cf 91       	pop	r28
     e10:	df 91       	pop	r29
     e12:	ff 91       	pop	r31
     e14:	ef 91       	pop	r30
     e16:	bf 91       	pop	r27
     e18:	af 91       	pop	r26
     e1a:	9f 91       	pop	r25
     e1c:	8f 91       	pop	r24
     e1e:	7f 91       	pop	r23
     e20:	6f 91       	pop	r22
     e22:	5f 91       	pop	r21
     e24:	4f 91       	pop	r20
     e26:	3f 91       	pop	r19
     e28:	2f 91       	pop	r18
     e2a:	0f 90       	pop	r0
     e2c:	0f be       	out	0x3f, r0	; 63
     e2e:	0f 90       	pop	r0
     e30:	1f 90       	pop	r1
     e32:	18 95       	reti

00000e34 <__vector_9>:

ISR(TIMER1_OVF_vect) {
     e34:	1f 92       	push	r1
     e36:	0f 92       	push	r0
     e38:	0f b6       	in	r0, 0x3f	; 63
     e3a:	0f 92       	push	r0
     e3c:	11 24       	eor	r1, r1
     e3e:	2f 93       	push	r18
     e40:	3f 93       	push	r19
     e42:	4f 93       	push	r20
     e44:	5f 93       	push	r21
     e46:	6f 93       	push	r22
     e48:	7f 93       	push	r23
     e4a:	8f 93       	push	r24
     e4c:	9f 93       	push	r25
     e4e:	af 93       	push	r26
     e50:	bf 93       	push	r27
     e52:	ef 93       	push	r30
     e54:	ff 93       	push	r31
     e56:	df 93       	push	r29
     e58:	cf 93       	push	r28
     e5a:	cd b7       	in	r28, 0x3d	; 61
     e5c:	de b7       	in	r29, 0x3e	; 62
	if (g_callBackPtr != NULL_PTR) {
     e5e:	80 91 76 00 	lds	r24, 0x0076
     e62:	90 91 77 00 	lds	r25, 0x0077
     e66:	00 97       	sbiw	r24, 0x00	; 0
     e68:	29 f0       	breq	.+10     	; 0xe74 <__vector_9+0x40>
		(*g_callBackPtr)();
     e6a:	e0 91 76 00 	lds	r30, 0x0076
     e6e:	f0 91 77 00 	lds	r31, 0x0077
     e72:	09 95       	icall
	}
}
     e74:	cf 91       	pop	r28
     e76:	df 91       	pop	r29
     e78:	ff 91       	pop	r31
     e7a:	ef 91       	pop	r30
     e7c:	bf 91       	pop	r27
     e7e:	af 91       	pop	r26
     e80:	9f 91       	pop	r25
     e82:	8f 91       	pop	r24
     e84:	7f 91       	pop	r23
     e86:	6f 91       	pop	r22
     e88:	5f 91       	pop	r21
     e8a:	4f 91       	pop	r20
     e8c:	3f 91       	pop	r19
     e8e:	2f 91       	pop	r18
     e90:	0f 90       	pop	r0
     e92:	0f be       	out	0x3f, r0	; 63
     e94:	0f 90       	pop	r0
     e96:	1f 90       	pop	r1
     e98:	18 95       	reti

00000e9a <Timer1_init>:

void Timer1_init(const Timer1_ConfigType *Config_Ptr) {
     e9a:	df 93       	push	r29
     e9c:	cf 93       	push	r28
     e9e:	00 d0       	rcall	.+0      	; 0xea0 <Timer1_init+0x6>
     ea0:	cd b7       	in	r28, 0x3d	; 61
     ea2:	de b7       	in	r29, 0x3e	; 62
     ea4:	9a 83       	std	Y+2, r25	; 0x02
     ea6:	89 83       	std	Y+1, r24	; 0x01

	// Put Initial Value to TCNT1
	TCNT1 = Config_Ptr->initial_value;
     ea8:	ac e4       	ldi	r26, 0x4C	; 76
     eaa:	b0 e0       	ldi	r27, 0x00	; 0
     eac:	e9 81       	ldd	r30, Y+1	; 0x01
     eae:	fa 81       	ldd	r31, Y+2	; 0x02
     eb0:	80 81       	ld	r24, Z
     eb2:	91 81       	ldd	r25, Z+1	; 0x01
     eb4:	11 96       	adiw	r26, 0x01	; 1
     eb6:	9c 93       	st	X, r25
     eb8:	8e 93       	st	-X, r24
	// Using Channel A in Timer1
	//COM1A1 COM1A0 (0-0)
	SET_BIT(TCCR1A, FOC1A);
     eba:	af e4       	ldi	r26, 0x4F	; 79
     ebc:	b0 e0       	ldi	r27, 0x00	; 0
     ebe:	ef e4       	ldi	r30, 0x4F	; 79
     ec0:	f0 e0       	ldi	r31, 0x00	; 0
     ec2:	80 81       	ld	r24, Z
     ec4:	88 60       	ori	r24, 0x08	; 8
     ec6:	8c 93       	st	X, r24
	//0- Normal  OR 1 -Compare IN WGM12
	//Another Solution than masking is to make if condition to value of enum
	// With Set of Clear bit WGM12
	TCCR1B = (TCCR1B & 0XEF) | ((Config_Ptr->mode) << 4);
     ec8:	ae e4       	ldi	r26, 0x4E	; 78
     eca:	b0 e0       	ldi	r27, 0x00	; 0
     ecc:	ee e4       	ldi	r30, 0x4E	; 78
     ece:	f0 e0       	ldi	r31, 0x00	; 0
     ed0:	80 81       	ld	r24, Z
     ed2:	28 2f       	mov	r18, r24
     ed4:	2f 7e       	andi	r18, 0xEF	; 239
     ed6:	e9 81       	ldd	r30, Y+1	; 0x01
     ed8:	fa 81       	ldd	r31, Y+2	; 0x02
     eda:	85 81       	ldd	r24, Z+5	; 0x05
     edc:	88 2f       	mov	r24, r24
     ede:	90 e0       	ldi	r25, 0x00	; 0
     ee0:	82 95       	swap	r24
     ee2:	92 95       	swap	r25
     ee4:	90 7f       	andi	r25, 0xF0	; 240
     ee6:	98 27       	eor	r25, r24
     ee8:	80 7f       	andi	r24, 0xF0	; 240
     eea:	98 27       	eor	r25, r24
     eec:	82 2b       	or	r24, r18
     eee:	8c 93       	st	X, r24
	// Now Mask All Register bits except CS12 CS11 CS10
	TCCR1B = (TCCR1B & 0xEF) | (Config_Ptr->prescaler);
     ef0:	ae e4       	ldi	r26, 0x4E	; 78
     ef2:	b0 e0       	ldi	r27, 0x00	; 0
     ef4:	ee e4       	ldi	r30, 0x4E	; 78
     ef6:	f0 e0       	ldi	r31, 0x00	; 0
     ef8:	80 81       	ld	r24, Z
     efa:	98 2f       	mov	r25, r24
     efc:	9f 7e       	andi	r25, 0xEF	; 239
     efe:	e9 81       	ldd	r30, Y+1	; 0x01
     f00:	fa 81       	ldd	r31, Y+2	; 0x02
     f02:	84 81       	ldd	r24, Z+4	; 0x04
     f04:	89 2b       	or	r24, r25
     f06:	8c 93       	st	X, r24
	OCR1A = (Config_Ptr->compare_value);
     f08:	aa e4       	ldi	r26, 0x4A	; 74
     f0a:	b0 e0       	ldi	r27, 0x00	; 0
     f0c:	e9 81       	ldd	r30, Y+1	; 0x01
     f0e:	fa 81       	ldd	r31, Y+2	; 0x02
     f10:	82 81       	ldd	r24, Z+2	; 0x02
     f12:	93 81       	ldd	r25, Z+3	; 0x03
     f14:	11 96       	adiw	r26, 0x01	; 1
     f16:	9c 93       	st	X, r25
     f18:	8e 93       	st	-X, r24
	if ((Config_Ptr->mode) == 0) {
     f1a:	e9 81       	ldd	r30, Y+1	; 0x01
     f1c:	fa 81       	ldd	r31, Y+2	; 0x02
     f1e:	85 81       	ldd	r24, Z+5	; 0x05
     f20:	88 23       	and	r24, r24
     f22:	79 f4       	brne	.+30     	; 0xf42 <Timer1_init+0xa8>
		// Normal Mode
		//OCIE2 TOIE2 TICIE1 OCIE1A OCIE1B TOIE1 OCIE0 TOIE0
		// 1     1		0		0		0	0		1	 1
		// Clear Any Older Flag
		TIMSK = (TIMSK & 0XC3);
     f24:	a9 e5       	ldi	r26, 0x59	; 89
     f26:	b0 e0       	ldi	r27, 0x00	; 0
     f28:	e9 e5       	ldi	r30, 0x59	; 89
     f2a:	f0 e0       	ldi	r31, 0x00	; 0
     f2c:	80 81       	ld	r24, Z
     f2e:	83 7c       	andi	r24, 0xC3	; 195
     f30:	8c 93       	st	X, r24
		//Bit 2  TOIE1: Timer/Counter1, Overflow Interrupt Enable
		SET_BIT(TIMSK, TOIE1);
     f32:	a9 e5       	ldi	r26, 0x59	; 89
     f34:	b0 e0       	ldi	r27, 0x00	; 0
     f36:	e9 e5       	ldi	r30, 0x59	; 89
     f38:	f0 e0       	ldi	r31, 0x00	; 0
     f3a:	80 81       	ld	r24, Z
     f3c:	84 60       	ori	r24, 0x04	; 4
     f3e:	8c 93       	st	X, r24
     f40:	0e c0       	rjmp	.+28     	; 0xf5e <Timer1_init+0xc4>
	} else {
		// Clear Any Older Flag
		TIMSK = (TIMSK & 0XC3);
     f42:	a9 e5       	ldi	r26, 0x59	; 89
     f44:	b0 e0       	ldi	r27, 0x00	; 0
     f46:	e9 e5       	ldi	r30, 0x59	; 89
     f48:	f0 e0       	ldi	r31, 0x00	; 0
     f4a:	80 81       	ld	r24, Z
     f4c:	83 7c       	andi	r24, 0xC3	; 195
     f4e:	8c 93       	st	X, r24
		//Bit 4  OCIE1A: Timer/Counter1, Output Compare A Match Interrupt Enable
		SET_BIT(TIMSK, OCIE1A);
     f50:	a9 e5       	ldi	r26, 0x59	; 89
     f52:	b0 e0       	ldi	r27, 0x00	; 0
     f54:	e9 e5       	ldi	r30, 0x59	; 89
     f56:	f0 e0       	ldi	r31, 0x00	; 0
     f58:	80 81       	ld	r24, Z
     f5a:	80 61       	ori	r24, 0x10	; 16
     f5c:	8c 93       	st	X, r24
	}
	//Enable INTERRUPTS At End of Init
	SET_BIT(SREG, 7);
     f5e:	af e5       	ldi	r26, 0x5F	; 95
     f60:	b0 e0       	ldi	r27, 0x00	; 0
     f62:	ef e5       	ldi	r30, 0x5F	; 95
     f64:	f0 e0       	ldi	r31, 0x00	; 0
     f66:	80 81       	ld	r24, Z
     f68:	80 68       	ori	r24, 0x80	; 128
     f6a:	8c 93       	st	X, r24

}
     f6c:	0f 90       	pop	r0
     f6e:	0f 90       	pop	r0
     f70:	cf 91       	pop	r28
     f72:	df 91       	pop	r29
     f74:	08 95       	ret

00000f76 <Timer1_setCallBack>:

void Timer1_setCallBack(void (*a_ptr)(void)) {
     f76:	df 93       	push	r29
     f78:	cf 93       	push	r28
     f7a:	00 d0       	rcall	.+0      	; 0xf7c <Timer1_setCallBack+0x6>
     f7c:	cd b7       	in	r28, 0x3d	; 61
     f7e:	de b7       	in	r29, 0x3e	; 62
     f80:	9a 83       	std	Y+2, r25	; 0x02
     f82:	89 83       	std	Y+1, r24	; 0x01
	g_callBackPtr = a_ptr;
     f84:	89 81       	ldd	r24, Y+1	; 0x01
     f86:	9a 81       	ldd	r25, Y+2	; 0x02
     f88:	90 93 77 00 	sts	0x0077, r25
     f8c:	80 93 76 00 	sts	0x0076, r24
}
     f90:	0f 90       	pop	r0
     f92:	0f 90       	pop	r0
     f94:	cf 91       	pop	r28
     f96:	df 91       	pop	r29
     f98:	08 95       	ret

00000f9a <Timer1_deInit>:

void Timer1_deInit(void) {
     f9a:	df 93       	push	r29
     f9c:	cf 93       	push	r28
     f9e:	cd b7       	in	r28, 0x3d	; 61
     fa0:	de b7       	in	r29, 0x3e	; 62
	TCCR1A = 0;
     fa2:	ef e4       	ldi	r30, 0x4F	; 79
     fa4:	f0 e0       	ldi	r31, 0x00	; 0
     fa6:	10 82       	st	Z, r1
	TCCR1B = 0;
     fa8:	ee e4       	ldi	r30, 0x4E	; 78
     faa:	f0 e0       	ldi	r31, 0x00	; 0
     fac:	10 82       	st	Z, r1
	TCNT1 = 0;
     fae:	ec e4       	ldi	r30, 0x4C	; 76
     fb0:	f0 e0       	ldi	r31, 0x00	; 0
     fb2:	11 82       	std	Z+1, r1	; 0x01
     fb4:	10 82       	st	Z, r1
	OCR1A = 0;
     fb6:	ea e4       	ldi	r30, 0x4A	; 74
     fb8:	f0 e0       	ldi	r31, 0x00	; 0
     fba:	11 82       	std	Z+1, r1	; 0x01
     fbc:	10 82       	st	Z, r1

}
     fbe:	cf 91       	pop	r28
     fc0:	df 91       	pop	r29
     fc2:	08 95       	ret

00000fc4 <TWI_init>:

#include "twi.h"
#include <avr/io.h>
#include "../../General/common_macros.h"

void TWI_init(const TWI_ConfigType *Config_Ptr) {
     fc4:	df 93       	push	r29
     fc6:	cf 93       	push	r28
     fc8:	00 d0       	rcall	.+0      	; 0xfca <TWI_init+0x6>
     fca:	0f 92       	push	r0
     fcc:	cd b7       	in	r28, 0x3d	; 61
     fce:	de b7       	in	r29, 0x3e	; 62
     fd0:	9a 83       	std	Y+2, r25	; 0x02
     fd2:	89 83       	std	Y+1, r24	; 0x01
	 * TWBR selects the division factor for the bit rate generator.
	 * The bit rate generator is a frequency
	 * divider which generates the SCL clock frequency in the Master modes
	 * Bit Rate: 400.000 kbps using zero pre-scaler TWPS=00 and F_CPU=8Mhz
	 * */
	TWBR = (Config_Ptr->bit_rate);
     fd4:	a0 e2       	ldi	r26, 0x20	; 32
     fd6:	b0 e0       	ldi	r27, 0x00	; 0
     fd8:	e9 81       	ldd	r30, Y+1	; 0x01
     fda:	fa 81       	ldd	r31, Y+2	; 0x02
     fdc:	81 81       	ldd	r24, Z+1	; 0x01
     fde:	8c 93       	st	X, r24
	 * Bits 7..3  TWS: TWI Status
	 * These five bits reflect the status of the TWI logic and the Two-wire Serial Bus
	 * Bits 1..0  TWPS: TWI Prescaler Bits
	 *
	 * */
	TWSR = 0x00;
     fe0:	e1 e2       	ldi	r30, 0x21	; 33
     fe2:	f0 e0       	ldi	r31, 0x00	; 0
     fe4:	10 82       	st	Z, r1
	 * If set, this bit enables the recognition of a General Call given over the Two-wire Serial Bus.
	 *Reset Register to clear all initial values then push address
	 *starting from bit 1
	 *
	 * */
	TWAR = (TWAR & 0X00) | ((Config_Ptr->address) << 1);
     fe6:	e2 e2       	ldi	r30, 0x22	; 34
     fe8:	f0 e0       	ldi	r31, 0x00	; 0
     fea:	80 81       	ld	r24, Z
     fec:	a2 e2       	ldi	r26, 0x22	; 34
     fee:	b0 e0       	ldi	r27, 0x00	; 0
     ff0:	e9 81       	ldd	r30, Y+1	; 0x01
     ff2:	fa 81       	ldd	r31, Y+2	; 0x02
     ff4:	80 81       	ld	r24, Z
     ff6:	88 2f       	mov	r24, r24
     ff8:	90 e0       	ldi	r25, 0x00	; 0
     ffa:	88 0f       	add	r24, r24
     ffc:	99 1f       	adc	r25, r25
     ffe:	8c 93       	st	X, r24
	 * Bit 0  TWIE: TWI Interrupt Enable
	 * When this bit is written to one, and the I-bit in SREG is set,
	 * the TWI interrupt request will be activated for as long as the TWINT Flag is high.
	 *
	 * */
	TWCR = (1 << TWEN);
    1000:	e6 e5       	ldi	r30, 0x56	; 86
    1002:	f0 e0       	ldi	r31, 0x00	; 0
    1004:	84 e0       	ldi	r24, 0x04	; 4
    1006:	80 83       	st	Z, r24
}
    1008:	0f 90       	pop	r0
    100a:	0f 90       	pop	r0
    100c:	0f 90       	pop	r0
    100e:	cf 91       	pop	r28
    1010:	df 91       	pop	r29
    1012:	08 95       	ret

00001014 <TWI_start>:

void TWI_start(void) {
    1014:	df 93       	push	r29
    1016:	cf 93       	push	r28
    1018:	cd b7       	in	r28, 0x3d	; 61
    101a:	de b7       	in	r29, 0x3e	; 62
	/*
	 * Clear the TWINT flag before sending the start bit TWINT=1
	 * send the start bit by TWSTA=1
	 * Enable TWI Module TWEN=1
	 */
	TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN);
    101c:	e6 e5       	ldi	r30, 0x56	; 86
    101e:	f0 e0       	ldi	r31, 0x00	; 0
    1020:	84 ea       	ldi	r24, 0xA4	; 164
    1022:	80 83       	st	Z, r24

	/* Wait for TWINT flag set in TWCR Register (start bit is send successfully) */
	while (BIT_IS_CLEAR(TWCR, TWINT))
    1024:	e6 e5       	ldi	r30, 0x56	; 86
    1026:	f0 e0       	ldi	r31, 0x00	; 0
    1028:	80 81       	ld	r24, Z
    102a:	88 23       	and	r24, r24
    102c:	dc f7       	brge	.-10     	; 0x1024 <TWI_start+0x10>
		;
}
    102e:	cf 91       	pop	r28
    1030:	df 91       	pop	r29
    1032:	08 95       	ret

00001034 <TWI_stop>:

void TWI_stop(void) {
    1034:	df 93       	push	r29
    1036:	cf 93       	push	r28
    1038:	cd b7       	in	r28, 0x3d	; 61
    103a:	de b7       	in	r29, 0x3e	; 62
	/*
	 * Clear the TWINT flag before sending the stop bit TWINT=1
	 * send the stop bit by TWSTO=1
	 * Enable TWI Module TWEN=1
	 */
	TWCR = (1 << TWINT) | (1 << TWSTO) | (1 << TWEN);
    103c:	e6 e5       	ldi	r30, 0x56	; 86
    103e:	f0 e0       	ldi	r31, 0x00	; 0
    1040:	84 e9       	ldi	r24, 0x94	; 148
    1042:	80 83       	st	Z, r24
}
    1044:	cf 91       	pop	r28
    1046:	df 91       	pop	r29
    1048:	08 95       	ret

0000104a <TWI_writeByte>:

void TWI_writeByte(uint8 data) {
    104a:	df 93       	push	r29
    104c:	cf 93       	push	r28
    104e:	0f 92       	push	r0
    1050:	cd b7       	in	r28, 0x3d	; 61
    1052:	de b7       	in	r29, 0x3e	; 62
    1054:	89 83       	std	Y+1, r24	; 0x01
	/* Put data On TWI data Register */
	TWDR = data;
    1056:	e3 e2       	ldi	r30, 0x23	; 35
    1058:	f0 e0       	ldi	r31, 0x00	; 0
    105a:	89 81       	ldd	r24, Y+1	; 0x01
    105c:	80 83       	st	Z, r24
	/*
	 * Clear the TWINT flag before sending the data TWINT=1
	 * Enable TWI Module TWEN=1
	 */
	TWCR = (1 << TWINT) | (1 << TWEN);
    105e:	e6 e5       	ldi	r30, 0x56	; 86
    1060:	f0 e0       	ldi	r31, 0x00	; 0
    1062:	84 e8       	ldi	r24, 0x84	; 132
    1064:	80 83       	st	Z, r24
	/* Wait for TWINT flag set in TWCR Register(data is send successfully) */
	while (BIT_IS_CLEAR(TWCR, TWINT))
    1066:	e6 e5       	ldi	r30, 0x56	; 86
    1068:	f0 e0       	ldi	r31, 0x00	; 0
    106a:	80 81       	ld	r24, Z
    106c:	88 23       	and	r24, r24
    106e:	dc f7       	brge	.-10     	; 0x1066 <TWI_writeByte+0x1c>
		;
}
    1070:	0f 90       	pop	r0
    1072:	cf 91       	pop	r28
    1074:	df 91       	pop	r29
    1076:	08 95       	ret

00001078 <TWI_readByteWithACK>:

uint8 TWI_readByteWithACK(void) {
    1078:	df 93       	push	r29
    107a:	cf 93       	push	r28
    107c:	cd b7       	in	r28, 0x3d	; 61
    107e:	de b7       	in	r29, 0x3e	; 62
	/*
	 * Clear the TWINT flag before reading the data TWINT=1
	 * Enable sending ACK after reading or receiving data TWEA=1
	 * Enable TWI Module TWEN=1
	 */
	TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWEA);
    1080:	e6 e5       	ldi	r30, 0x56	; 86
    1082:	f0 e0       	ldi	r31, 0x00	; 0
    1084:	84 ec       	ldi	r24, 0xC4	; 196
    1086:	80 83       	st	Z, r24
	/* Wait for TWINT flag set in TWCR Register (data received successfully) */
	while (BIT_IS_CLEAR(TWCR, TWINT))
    1088:	e6 e5       	ldi	r30, 0x56	; 86
    108a:	f0 e0       	ldi	r31, 0x00	; 0
    108c:	80 81       	ld	r24, Z
    108e:	88 23       	and	r24, r24
    1090:	dc f7       	brge	.-10     	; 0x1088 <TWI_readByteWithACK+0x10>
		;
	/* Read Data */
	return TWDR;
    1092:	e3 e2       	ldi	r30, 0x23	; 35
    1094:	f0 e0       	ldi	r31, 0x00	; 0
    1096:	80 81       	ld	r24, Z
}
    1098:	cf 91       	pop	r28
    109a:	df 91       	pop	r29
    109c:	08 95       	ret

0000109e <TWI_readByteWithNACK>:

uint8 TWI_readByteWithNACK(void) {
    109e:	df 93       	push	r29
    10a0:	cf 93       	push	r28
    10a2:	cd b7       	in	r28, 0x3d	; 61
    10a4:	de b7       	in	r29, 0x3e	; 62
	/*
	 * Clear the TWINT flag before reading the data TWINT=1
	 * Enable TWI Module TWEN=1
	 */
	TWCR = (1 << TWINT) | (1 << TWEN);
    10a6:	e6 e5       	ldi	r30, 0x56	; 86
    10a8:	f0 e0       	ldi	r31, 0x00	; 0
    10aa:	84 e8       	ldi	r24, 0x84	; 132
    10ac:	80 83       	st	Z, r24
	/* Wait for TWINT flag set in TWCR Register (data received successfully) */
	while (BIT_IS_CLEAR(TWCR, TWINT))
    10ae:	e6 e5       	ldi	r30, 0x56	; 86
    10b0:	f0 e0       	ldi	r31, 0x00	; 0
    10b2:	80 81       	ld	r24, Z
    10b4:	88 23       	and	r24, r24
    10b6:	dc f7       	brge	.-10     	; 0x10ae <TWI_readByteWithNACK+0x10>
		;
	/* Read Data */
	return TWDR;
    10b8:	e3 e2       	ldi	r30, 0x23	; 35
    10ba:	f0 e0       	ldi	r31, 0x00	; 0
    10bc:	80 81       	ld	r24, Z
}
    10be:	cf 91       	pop	r28
    10c0:	df 91       	pop	r29
    10c2:	08 95       	ret

000010c4 <TWI_getStatus>:

uint8 TWI_getStatus(void) {
    10c4:	df 93       	push	r29
    10c6:	cf 93       	push	r28
    10c8:	0f 92       	push	r0
    10ca:	cd b7       	in	r28, 0x3d	; 61
    10cc:	de b7       	in	r29, 0x3e	; 62
	uint8 status;
	/* masking to eliminate first 3 bits and get the last 5 bits (status bits) */
	status = TWSR & 0xF8;
    10ce:	e1 e2       	ldi	r30, 0x21	; 33
    10d0:	f0 e0       	ldi	r31, 0x00	; 0
    10d2:	80 81       	ld	r24, Z
    10d4:	88 7f       	andi	r24, 0xF8	; 248
    10d6:	89 83       	std	Y+1, r24	; 0x01
	return status;
    10d8:	89 81       	ldd	r24, Y+1	; 0x01
}
    10da:	0f 90       	pop	r0
    10dc:	cf 91       	pop	r28
    10de:	df 91       	pop	r29
    10e0:	08 95       	ret

000010e2 <GPIO_setupPinDirection>:
 * Description :
 * Setup the direction of the required pin input/output.
 * If the input port number or pin number are not correct, The function will not handle the request.
 */
void GPIO_setupPinDirection(uint8 port_num, uint8 pin_num,
		GPIO_PinDirectionType direction) {
    10e2:	df 93       	push	r29
    10e4:	cf 93       	push	r28
    10e6:	00 d0       	rcall	.+0      	; 0x10e8 <GPIO_setupPinDirection+0x6>
    10e8:	00 d0       	rcall	.+0      	; 0x10ea <GPIO_setupPinDirection+0x8>
    10ea:	0f 92       	push	r0
    10ec:	cd b7       	in	r28, 0x3d	; 61
    10ee:	de b7       	in	r29, 0x3e	; 62
    10f0:	89 83       	std	Y+1, r24	; 0x01
    10f2:	6a 83       	std	Y+2, r22	; 0x02
    10f4:	4b 83       	std	Y+3, r20	; 0x03
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if ((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS)) {
    10f6:	8a 81       	ldd	r24, Y+2	; 0x02
    10f8:	88 30       	cpi	r24, 0x08	; 8
    10fa:	08 f0       	brcs	.+2      	; 0x10fe <GPIO_setupPinDirection+0x1c>
    10fc:	d5 c0       	rjmp	.+426    	; 0x12a8 <GPIO_setupPinDirection+0x1c6>
    10fe:	89 81       	ldd	r24, Y+1	; 0x01
    1100:	84 30       	cpi	r24, 0x04	; 4
    1102:	08 f0       	brcs	.+2      	; 0x1106 <GPIO_setupPinDirection+0x24>
    1104:	d1 c0       	rjmp	.+418    	; 0x12a8 <GPIO_setupPinDirection+0x1c6>
		/* Do Nothing */
	} else {
		/* Setup the pin direction as required */
		switch (port_num) {
    1106:	89 81       	ldd	r24, Y+1	; 0x01
    1108:	28 2f       	mov	r18, r24
    110a:	30 e0       	ldi	r19, 0x00	; 0
    110c:	3d 83       	std	Y+5, r19	; 0x05
    110e:	2c 83       	std	Y+4, r18	; 0x04
    1110:	8c 81       	ldd	r24, Y+4	; 0x04
    1112:	9d 81       	ldd	r25, Y+5	; 0x05
    1114:	81 30       	cpi	r24, 0x01	; 1
    1116:	91 05       	cpc	r25, r1
    1118:	09 f4       	brne	.+2      	; 0x111c <GPIO_setupPinDirection+0x3a>
    111a:	43 c0       	rjmp	.+134    	; 0x11a2 <GPIO_setupPinDirection+0xc0>
    111c:	2c 81       	ldd	r18, Y+4	; 0x04
    111e:	3d 81       	ldd	r19, Y+5	; 0x05
    1120:	22 30       	cpi	r18, 0x02	; 2
    1122:	31 05       	cpc	r19, r1
    1124:	2c f4       	brge	.+10     	; 0x1130 <GPIO_setupPinDirection+0x4e>
    1126:	8c 81       	ldd	r24, Y+4	; 0x04
    1128:	9d 81       	ldd	r25, Y+5	; 0x05
    112a:	00 97       	sbiw	r24, 0x00	; 0
    112c:	71 f0       	breq	.+28     	; 0x114a <GPIO_setupPinDirection+0x68>
    112e:	bc c0       	rjmp	.+376    	; 0x12a8 <GPIO_setupPinDirection+0x1c6>
    1130:	2c 81       	ldd	r18, Y+4	; 0x04
    1132:	3d 81       	ldd	r19, Y+5	; 0x05
    1134:	22 30       	cpi	r18, 0x02	; 2
    1136:	31 05       	cpc	r19, r1
    1138:	09 f4       	brne	.+2      	; 0x113c <GPIO_setupPinDirection+0x5a>
    113a:	5f c0       	rjmp	.+190    	; 0x11fa <GPIO_setupPinDirection+0x118>
    113c:	8c 81       	ldd	r24, Y+4	; 0x04
    113e:	9d 81       	ldd	r25, Y+5	; 0x05
    1140:	83 30       	cpi	r24, 0x03	; 3
    1142:	91 05       	cpc	r25, r1
    1144:	09 f4       	brne	.+2      	; 0x1148 <GPIO_setupPinDirection+0x66>
    1146:	85 c0       	rjmp	.+266    	; 0x1252 <GPIO_setupPinDirection+0x170>
    1148:	af c0       	rjmp	.+350    	; 0x12a8 <GPIO_setupPinDirection+0x1c6>
		case PORTA_ID:
			if (direction == PIN_OUTPUT) {
    114a:	8b 81       	ldd	r24, Y+3	; 0x03
    114c:	81 30       	cpi	r24, 0x01	; 1
    114e:	a1 f4       	brne	.+40     	; 0x1178 <GPIO_setupPinDirection+0x96>
				SET_BIT(DDRA, pin_num);
    1150:	aa e3       	ldi	r26, 0x3A	; 58
    1152:	b0 e0       	ldi	r27, 0x00	; 0
    1154:	ea e3       	ldi	r30, 0x3A	; 58
    1156:	f0 e0       	ldi	r31, 0x00	; 0
    1158:	80 81       	ld	r24, Z
    115a:	48 2f       	mov	r20, r24
    115c:	8a 81       	ldd	r24, Y+2	; 0x02
    115e:	28 2f       	mov	r18, r24
    1160:	30 e0       	ldi	r19, 0x00	; 0
    1162:	81 e0       	ldi	r24, 0x01	; 1
    1164:	90 e0       	ldi	r25, 0x00	; 0
    1166:	02 2e       	mov	r0, r18
    1168:	02 c0       	rjmp	.+4      	; 0x116e <GPIO_setupPinDirection+0x8c>
    116a:	88 0f       	add	r24, r24
    116c:	99 1f       	adc	r25, r25
    116e:	0a 94       	dec	r0
    1170:	e2 f7       	brpl	.-8      	; 0x116a <GPIO_setupPinDirection+0x88>
    1172:	84 2b       	or	r24, r20
    1174:	8c 93       	st	X, r24
    1176:	98 c0       	rjmp	.+304    	; 0x12a8 <GPIO_setupPinDirection+0x1c6>
			} else {
				CLEAR_BIT(DDRA, pin_num);
    1178:	aa e3       	ldi	r26, 0x3A	; 58
    117a:	b0 e0       	ldi	r27, 0x00	; 0
    117c:	ea e3       	ldi	r30, 0x3A	; 58
    117e:	f0 e0       	ldi	r31, 0x00	; 0
    1180:	80 81       	ld	r24, Z
    1182:	48 2f       	mov	r20, r24
    1184:	8a 81       	ldd	r24, Y+2	; 0x02
    1186:	28 2f       	mov	r18, r24
    1188:	30 e0       	ldi	r19, 0x00	; 0
    118a:	81 e0       	ldi	r24, 0x01	; 1
    118c:	90 e0       	ldi	r25, 0x00	; 0
    118e:	02 2e       	mov	r0, r18
    1190:	02 c0       	rjmp	.+4      	; 0x1196 <GPIO_setupPinDirection+0xb4>
    1192:	88 0f       	add	r24, r24
    1194:	99 1f       	adc	r25, r25
    1196:	0a 94       	dec	r0
    1198:	e2 f7       	brpl	.-8      	; 0x1192 <GPIO_setupPinDirection+0xb0>
    119a:	80 95       	com	r24
    119c:	84 23       	and	r24, r20
    119e:	8c 93       	st	X, r24
    11a0:	83 c0       	rjmp	.+262    	; 0x12a8 <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTB_ID:
			if (direction == PIN_OUTPUT) {
    11a2:	8b 81       	ldd	r24, Y+3	; 0x03
    11a4:	81 30       	cpi	r24, 0x01	; 1
    11a6:	a1 f4       	brne	.+40     	; 0x11d0 <GPIO_setupPinDirection+0xee>
				SET_BIT(DDRB, pin_num);
    11a8:	a7 e3       	ldi	r26, 0x37	; 55
    11aa:	b0 e0       	ldi	r27, 0x00	; 0
    11ac:	e7 e3       	ldi	r30, 0x37	; 55
    11ae:	f0 e0       	ldi	r31, 0x00	; 0
    11b0:	80 81       	ld	r24, Z
    11b2:	48 2f       	mov	r20, r24
    11b4:	8a 81       	ldd	r24, Y+2	; 0x02
    11b6:	28 2f       	mov	r18, r24
    11b8:	30 e0       	ldi	r19, 0x00	; 0
    11ba:	81 e0       	ldi	r24, 0x01	; 1
    11bc:	90 e0       	ldi	r25, 0x00	; 0
    11be:	02 2e       	mov	r0, r18
    11c0:	02 c0       	rjmp	.+4      	; 0x11c6 <GPIO_setupPinDirection+0xe4>
    11c2:	88 0f       	add	r24, r24
    11c4:	99 1f       	adc	r25, r25
    11c6:	0a 94       	dec	r0
    11c8:	e2 f7       	brpl	.-8      	; 0x11c2 <GPIO_setupPinDirection+0xe0>
    11ca:	84 2b       	or	r24, r20
    11cc:	8c 93       	st	X, r24
    11ce:	6c c0       	rjmp	.+216    	; 0x12a8 <GPIO_setupPinDirection+0x1c6>
			} else {
				CLEAR_BIT(DDRB, pin_num);
    11d0:	a7 e3       	ldi	r26, 0x37	; 55
    11d2:	b0 e0       	ldi	r27, 0x00	; 0
    11d4:	e7 e3       	ldi	r30, 0x37	; 55
    11d6:	f0 e0       	ldi	r31, 0x00	; 0
    11d8:	80 81       	ld	r24, Z
    11da:	48 2f       	mov	r20, r24
    11dc:	8a 81       	ldd	r24, Y+2	; 0x02
    11de:	28 2f       	mov	r18, r24
    11e0:	30 e0       	ldi	r19, 0x00	; 0
    11e2:	81 e0       	ldi	r24, 0x01	; 1
    11e4:	90 e0       	ldi	r25, 0x00	; 0
    11e6:	02 2e       	mov	r0, r18
    11e8:	02 c0       	rjmp	.+4      	; 0x11ee <GPIO_setupPinDirection+0x10c>
    11ea:	88 0f       	add	r24, r24
    11ec:	99 1f       	adc	r25, r25
    11ee:	0a 94       	dec	r0
    11f0:	e2 f7       	brpl	.-8      	; 0x11ea <GPIO_setupPinDirection+0x108>
    11f2:	80 95       	com	r24
    11f4:	84 23       	and	r24, r20
    11f6:	8c 93       	st	X, r24
    11f8:	57 c0       	rjmp	.+174    	; 0x12a8 <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTC_ID:
			if (direction == PIN_OUTPUT) {
    11fa:	8b 81       	ldd	r24, Y+3	; 0x03
    11fc:	81 30       	cpi	r24, 0x01	; 1
    11fe:	a1 f4       	brne	.+40     	; 0x1228 <GPIO_setupPinDirection+0x146>
				SET_BIT(DDRC, pin_num);
    1200:	a4 e3       	ldi	r26, 0x34	; 52
    1202:	b0 e0       	ldi	r27, 0x00	; 0
    1204:	e4 e3       	ldi	r30, 0x34	; 52
    1206:	f0 e0       	ldi	r31, 0x00	; 0
    1208:	80 81       	ld	r24, Z
    120a:	48 2f       	mov	r20, r24
    120c:	8a 81       	ldd	r24, Y+2	; 0x02
    120e:	28 2f       	mov	r18, r24
    1210:	30 e0       	ldi	r19, 0x00	; 0
    1212:	81 e0       	ldi	r24, 0x01	; 1
    1214:	90 e0       	ldi	r25, 0x00	; 0
    1216:	02 2e       	mov	r0, r18
    1218:	02 c0       	rjmp	.+4      	; 0x121e <GPIO_setupPinDirection+0x13c>
    121a:	88 0f       	add	r24, r24
    121c:	99 1f       	adc	r25, r25
    121e:	0a 94       	dec	r0
    1220:	e2 f7       	brpl	.-8      	; 0x121a <GPIO_setupPinDirection+0x138>
    1222:	84 2b       	or	r24, r20
    1224:	8c 93       	st	X, r24
    1226:	40 c0       	rjmp	.+128    	; 0x12a8 <GPIO_setupPinDirection+0x1c6>
			} else {
				CLEAR_BIT(DDRC, pin_num);
    1228:	a4 e3       	ldi	r26, 0x34	; 52
    122a:	b0 e0       	ldi	r27, 0x00	; 0
    122c:	e4 e3       	ldi	r30, 0x34	; 52
    122e:	f0 e0       	ldi	r31, 0x00	; 0
    1230:	80 81       	ld	r24, Z
    1232:	48 2f       	mov	r20, r24
    1234:	8a 81       	ldd	r24, Y+2	; 0x02
    1236:	28 2f       	mov	r18, r24
    1238:	30 e0       	ldi	r19, 0x00	; 0
    123a:	81 e0       	ldi	r24, 0x01	; 1
    123c:	90 e0       	ldi	r25, 0x00	; 0
    123e:	02 2e       	mov	r0, r18
    1240:	02 c0       	rjmp	.+4      	; 0x1246 <GPIO_setupPinDirection+0x164>
    1242:	88 0f       	add	r24, r24
    1244:	99 1f       	adc	r25, r25
    1246:	0a 94       	dec	r0
    1248:	e2 f7       	brpl	.-8      	; 0x1242 <GPIO_setupPinDirection+0x160>
    124a:	80 95       	com	r24
    124c:	84 23       	and	r24, r20
    124e:	8c 93       	st	X, r24
    1250:	2b c0       	rjmp	.+86     	; 0x12a8 <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTD_ID:
			if (direction == PIN_OUTPUT) {
    1252:	8b 81       	ldd	r24, Y+3	; 0x03
    1254:	81 30       	cpi	r24, 0x01	; 1
    1256:	a1 f4       	brne	.+40     	; 0x1280 <GPIO_setupPinDirection+0x19e>
				SET_BIT(DDRD, pin_num);
    1258:	a1 e3       	ldi	r26, 0x31	; 49
    125a:	b0 e0       	ldi	r27, 0x00	; 0
    125c:	e1 e3       	ldi	r30, 0x31	; 49
    125e:	f0 e0       	ldi	r31, 0x00	; 0
    1260:	80 81       	ld	r24, Z
    1262:	48 2f       	mov	r20, r24
    1264:	8a 81       	ldd	r24, Y+2	; 0x02
    1266:	28 2f       	mov	r18, r24
    1268:	30 e0       	ldi	r19, 0x00	; 0
    126a:	81 e0       	ldi	r24, 0x01	; 1
    126c:	90 e0       	ldi	r25, 0x00	; 0
    126e:	02 2e       	mov	r0, r18
    1270:	02 c0       	rjmp	.+4      	; 0x1276 <GPIO_setupPinDirection+0x194>
    1272:	88 0f       	add	r24, r24
    1274:	99 1f       	adc	r25, r25
    1276:	0a 94       	dec	r0
    1278:	e2 f7       	brpl	.-8      	; 0x1272 <GPIO_setupPinDirection+0x190>
    127a:	84 2b       	or	r24, r20
    127c:	8c 93       	st	X, r24
    127e:	14 c0       	rjmp	.+40     	; 0x12a8 <GPIO_setupPinDirection+0x1c6>
			} else {
				CLEAR_BIT(DDRD, pin_num);
    1280:	a1 e3       	ldi	r26, 0x31	; 49
    1282:	b0 e0       	ldi	r27, 0x00	; 0
    1284:	e1 e3       	ldi	r30, 0x31	; 49
    1286:	f0 e0       	ldi	r31, 0x00	; 0
    1288:	80 81       	ld	r24, Z
    128a:	48 2f       	mov	r20, r24
    128c:	8a 81       	ldd	r24, Y+2	; 0x02
    128e:	28 2f       	mov	r18, r24
    1290:	30 e0       	ldi	r19, 0x00	; 0
    1292:	81 e0       	ldi	r24, 0x01	; 1
    1294:	90 e0       	ldi	r25, 0x00	; 0
    1296:	02 2e       	mov	r0, r18
    1298:	02 c0       	rjmp	.+4      	; 0x129e <GPIO_setupPinDirection+0x1bc>
    129a:	88 0f       	add	r24, r24
    129c:	99 1f       	adc	r25, r25
    129e:	0a 94       	dec	r0
    12a0:	e2 f7       	brpl	.-8      	; 0x129a <GPIO_setupPinDirection+0x1b8>
    12a2:	80 95       	com	r24
    12a4:	84 23       	and	r24, r20
    12a6:	8c 93       	st	X, r24
			}
			break;
		}
	}
}
    12a8:	0f 90       	pop	r0
    12aa:	0f 90       	pop	r0
    12ac:	0f 90       	pop	r0
    12ae:	0f 90       	pop	r0
    12b0:	0f 90       	pop	r0
    12b2:	cf 91       	pop	r28
    12b4:	df 91       	pop	r29
    12b6:	08 95       	ret

000012b8 <GPIO_writePin>:
 * Description :
 * Write the value Logic High or Logic Low on the required pin.
 * If the input port number or pin number are not correct, The function will not handle the request.
 * If the pin is input, this function will enable/disable the internal pull-up resistor.
 */
void GPIO_writePin(uint8 port_num, uint8 pin_num, uint8 value) {
    12b8:	df 93       	push	r29
    12ba:	cf 93       	push	r28
    12bc:	00 d0       	rcall	.+0      	; 0x12be <GPIO_writePin+0x6>
    12be:	00 d0       	rcall	.+0      	; 0x12c0 <GPIO_writePin+0x8>
    12c0:	0f 92       	push	r0
    12c2:	cd b7       	in	r28, 0x3d	; 61
    12c4:	de b7       	in	r29, 0x3e	; 62
    12c6:	89 83       	std	Y+1, r24	; 0x01
    12c8:	6a 83       	std	Y+2, r22	; 0x02
    12ca:	4b 83       	std	Y+3, r20	; 0x03
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if ((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS)) {
    12cc:	8a 81       	ldd	r24, Y+2	; 0x02
    12ce:	88 30       	cpi	r24, 0x08	; 8
    12d0:	08 f0       	brcs	.+2      	; 0x12d4 <GPIO_writePin+0x1c>
    12d2:	d5 c0       	rjmp	.+426    	; 0x147e <GPIO_writePin+0x1c6>
    12d4:	89 81       	ldd	r24, Y+1	; 0x01
    12d6:	84 30       	cpi	r24, 0x04	; 4
    12d8:	08 f0       	brcs	.+2      	; 0x12dc <GPIO_writePin+0x24>
    12da:	d1 c0       	rjmp	.+418    	; 0x147e <GPIO_writePin+0x1c6>
		/* Do Nothing */
	} else {
		/* Write the pin value as required */
		switch (port_num) {
    12dc:	89 81       	ldd	r24, Y+1	; 0x01
    12de:	28 2f       	mov	r18, r24
    12e0:	30 e0       	ldi	r19, 0x00	; 0
    12e2:	3d 83       	std	Y+5, r19	; 0x05
    12e4:	2c 83       	std	Y+4, r18	; 0x04
    12e6:	8c 81       	ldd	r24, Y+4	; 0x04
    12e8:	9d 81       	ldd	r25, Y+5	; 0x05
    12ea:	81 30       	cpi	r24, 0x01	; 1
    12ec:	91 05       	cpc	r25, r1
    12ee:	09 f4       	brne	.+2      	; 0x12f2 <GPIO_writePin+0x3a>
    12f0:	43 c0       	rjmp	.+134    	; 0x1378 <GPIO_writePin+0xc0>
    12f2:	2c 81       	ldd	r18, Y+4	; 0x04
    12f4:	3d 81       	ldd	r19, Y+5	; 0x05
    12f6:	22 30       	cpi	r18, 0x02	; 2
    12f8:	31 05       	cpc	r19, r1
    12fa:	2c f4       	brge	.+10     	; 0x1306 <GPIO_writePin+0x4e>
    12fc:	8c 81       	ldd	r24, Y+4	; 0x04
    12fe:	9d 81       	ldd	r25, Y+5	; 0x05
    1300:	00 97       	sbiw	r24, 0x00	; 0
    1302:	71 f0       	breq	.+28     	; 0x1320 <GPIO_writePin+0x68>
    1304:	bc c0       	rjmp	.+376    	; 0x147e <GPIO_writePin+0x1c6>
    1306:	2c 81       	ldd	r18, Y+4	; 0x04
    1308:	3d 81       	ldd	r19, Y+5	; 0x05
    130a:	22 30       	cpi	r18, 0x02	; 2
    130c:	31 05       	cpc	r19, r1
    130e:	09 f4       	brne	.+2      	; 0x1312 <GPIO_writePin+0x5a>
    1310:	5f c0       	rjmp	.+190    	; 0x13d0 <GPIO_writePin+0x118>
    1312:	8c 81       	ldd	r24, Y+4	; 0x04
    1314:	9d 81       	ldd	r25, Y+5	; 0x05
    1316:	83 30       	cpi	r24, 0x03	; 3
    1318:	91 05       	cpc	r25, r1
    131a:	09 f4       	brne	.+2      	; 0x131e <GPIO_writePin+0x66>
    131c:	85 c0       	rjmp	.+266    	; 0x1428 <GPIO_writePin+0x170>
    131e:	af c0       	rjmp	.+350    	; 0x147e <GPIO_writePin+0x1c6>
		case PORTA_ID:
			if (value == LOGIC_HIGH) {
    1320:	8b 81       	ldd	r24, Y+3	; 0x03
    1322:	81 30       	cpi	r24, 0x01	; 1
    1324:	a1 f4       	brne	.+40     	; 0x134e <GPIO_writePin+0x96>
				SET_BIT(PORTA, pin_num);
    1326:	ab e3       	ldi	r26, 0x3B	; 59
    1328:	b0 e0       	ldi	r27, 0x00	; 0
    132a:	eb e3       	ldi	r30, 0x3B	; 59
    132c:	f0 e0       	ldi	r31, 0x00	; 0
    132e:	80 81       	ld	r24, Z
    1330:	48 2f       	mov	r20, r24
    1332:	8a 81       	ldd	r24, Y+2	; 0x02
    1334:	28 2f       	mov	r18, r24
    1336:	30 e0       	ldi	r19, 0x00	; 0
    1338:	81 e0       	ldi	r24, 0x01	; 1
    133a:	90 e0       	ldi	r25, 0x00	; 0
    133c:	02 2e       	mov	r0, r18
    133e:	02 c0       	rjmp	.+4      	; 0x1344 <GPIO_writePin+0x8c>
    1340:	88 0f       	add	r24, r24
    1342:	99 1f       	adc	r25, r25
    1344:	0a 94       	dec	r0
    1346:	e2 f7       	brpl	.-8      	; 0x1340 <GPIO_writePin+0x88>
    1348:	84 2b       	or	r24, r20
    134a:	8c 93       	st	X, r24
    134c:	98 c0       	rjmp	.+304    	; 0x147e <GPIO_writePin+0x1c6>
			} else {
				CLEAR_BIT(PORTA, pin_num);
    134e:	ab e3       	ldi	r26, 0x3B	; 59
    1350:	b0 e0       	ldi	r27, 0x00	; 0
    1352:	eb e3       	ldi	r30, 0x3B	; 59
    1354:	f0 e0       	ldi	r31, 0x00	; 0
    1356:	80 81       	ld	r24, Z
    1358:	48 2f       	mov	r20, r24
    135a:	8a 81       	ldd	r24, Y+2	; 0x02
    135c:	28 2f       	mov	r18, r24
    135e:	30 e0       	ldi	r19, 0x00	; 0
    1360:	81 e0       	ldi	r24, 0x01	; 1
    1362:	90 e0       	ldi	r25, 0x00	; 0
    1364:	02 2e       	mov	r0, r18
    1366:	02 c0       	rjmp	.+4      	; 0x136c <GPIO_writePin+0xb4>
    1368:	88 0f       	add	r24, r24
    136a:	99 1f       	adc	r25, r25
    136c:	0a 94       	dec	r0
    136e:	e2 f7       	brpl	.-8      	; 0x1368 <GPIO_writePin+0xb0>
    1370:	80 95       	com	r24
    1372:	84 23       	and	r24, r20
    1374:	8c 93       	st	X, r24
    1376:	83 c0       	rjmp	.+262    	; 0x147e <GPIO_writePin+0x1c6>
			}
			break;
		case PORTB_ID:
			if (value == LOGIC_HIGH) {
    1378:	8b 81       	ldd	r24, Y+3	; 0x03
    137a:	81 30       	cpi	r24, 0x01	; 1
    137c:	a1 f4       	brne	.+40     	; 0x13a6 <GPIO_writePin+0xee>
				SET_BIT(PORTB, pin_num);
    137e:	a8 e3       	ldi	r26, 0x38	; 56
    1380:	b0 e0       	ldi	r27, 0x00	; 0
    1382:	e8 e3       	ldi	r30, 0x38	; 56
    1384:	f0 e0       	ldi	r31, 0x00	; 0
    1386:	80 81       	ld	r24, Z
    1388:	48 2f       	mov	r20, r24
    138a:	8a 81       	ldd	r24, Y+2	; 0x02
    138c:	28 2f       	mov	r18, r24
    138e:	30 e0       	ldi	r19, 0x00	; 0
    1390:	81 e0       	ldi	r24, 0x01	; 1
    1392:	90 e0       	ldi	r25, 0x00	; 0
    1394:	02 2e       	mov	r0, r18
    1396:	02 c0       	rjmp	.+4      	; 0x139c <GPIO_writePin+0xe4>
    1398:	88 0f       	add	r24, r24
    139a:	99 1f       	adc	r25, r25
    139c:	0a 94       	dec	r0
    139e:	e2 f7       	brpl	.-8      	; 0x1398 <GPIO_writePin+0xe0>
    13a0:	84 2b       	or	r24, r20
    13a2:	8c 93       	st	X, r24
    13a4:	6c c0       	rjmp	.+216    	; 0x147e <GPIO_writePin+0x1c6>
			} else {
				CLEAR_BIT(PORTB, pin_num);
    13a6:	a8 e3       	ldi	r26, 0x38	; 56
    13a8:	b0 e0       	ldi	r27, 0x00	; 0
    13aa:	e8 e3       	ldi	r30, 0x38	; 56
    13ac:	f0 e0       	ldi	r31, 0x00	; 0
    13ae:	80 81       	ld	r24, Z
    13b0:	48 2f       	mov	r20, r24
    13b2:	8a 81       	ldd	r24, Y+2	; 0x02
    13b4:	28 2f       	mov	r18, r24
    13b6:	30 e0       	ldi	r19, 0x00	; 0
    13b8:	81 e0       	ldi	r24, 0x01	; 1
    13ba:	90 e0       	ldi	r25, 0x00	; 0
    13bc:	02 2e       	mov	r0, r18
    13be:	02 c0       	rjmp	.+4      	; 0x13c4 <GPIO_writePin+0x10c>
    13c0:	88 0f       	add	r24, r24
    13c2:	99 1f       	adc	r25, r25
    13c4:	0a 94       	dec	r0
    13c6:	e2 f7       	brpl	.-8      	; 0x13c0 <GPIO_writePin+0x108>
    13c8:	80 95       	com	r24
    13ca:	84 23       	and	r24, r20
    13cc:	8c 93       	st	X, r24
    13ce:	57 c0       	rjmp	.+174    	; 0x147e <GPIO_writePin+0x1c6>
			}
			break;
		case PORTC_ID:
			if (value == LOGIC_HIGH) {
    13d0:	8b 81       	ldd	r24, Y+3	; 0x03
    13d2:	81 30       	cpi	r24, 0x01	; 1
    13d4:	a1 f4       	brne	.+40     	; 0x13fe <GPIO_writePin+0x146>
				SET_BIT(PORTC, pin_num);
    13d6:	a5 e3       	ldi	r26, 0x35	; 53
    13d8:	b0 e0       	ldi	r27, 0x00	; 0
    13da:	e5 e3       	ldi	r30, 0x35	; 53
    13dc:	f0 e0       	ldi	r31, 0x00	; 0
    13de:	80 81       	ld	r24, Z
    13e0:	48 2f       	mov	r20, r24
    13e2:	8a 81       	ldd	r24, Y+2	; 0x02
    13e4:	28 2f       	mov	r18, r24
    13e6:	30 e0       	ldi	r19, 0x00	; 0
    13e8:	81 e0       	ldi	r24, 0x01	; 1
    13ea:	90 e0       	ldi	r25, 0x00	; 0
    13ec:	02 2e       	mov	r0, r18
    13ee:	02 c0       	rjmp	.+4      	; 0x13f4 <GPIO_writePin+0x13c>
    13f0:	88 0f       	add	r24, r24
    13f2:	99 1f       	adc	r25, r25
    13f4:	0a 94       	dec	r0
    13f6:	e2 f7       	brpl	.-8      	; 0x13f0 <GPIO_writePin+0x138>
    13f8:	84 2b       	or	r24, r20
    13fa:	8c 93       	st	X, r24
    13fc:	40 c0       	rjmp	.+128    	; 0x147e <GPIO_writePin+0x1c6>
			} else {
				CLEAR_BIT(PORTC, pin_num);
    13fe:	a5 e3       	ldi	r26, 0x35	; 53
    1400:	b0 e0       	ldi	r27, 0x00	; 0
    1402:	e5 e3       	ldi	r30, 0x35	; 53
    1404:	f0 e0       	ldi	r31, 0x00	; 0
    1406:	80 81       	ld	r24, Z
    1408:	48 2f       	mov	r20, r24
    140a:	8a 81       	ldd	r24, Y+2	; 0x02
    140c:	28 2f       	mov	r18, r24
    140e:	30 e0       	ldi	r19, 0x00	; 0
    1410:	81 e0       	ldi	r24, 0x01	; 1
    1412:	90 e0       	ldi	r25, 0x00	; 0
    1414:	02 2e       	mov	r0, r18
    1416:	02 c0       	rjmp	.+4      	; 0x141c <GPIO_writePin+0x164>
    1418:	88 0f       	add	r24, r24
    141a:	99 1f       	adc	r25, r25
    141c:	0a 94       	dec	r0
    141e:	e2 f7       	brpl	.-8      	; 0x1418 <GPIO_writePin+0x160>
    1420:	80 95       	com	r24
    1422:	84 23       	and	r24, r20
    1424:	8c 93       	st	X, r24
    1426:	2b c0       	rjmp	.+86     	; 0x147e <GPIO_writePin+0x1c6>
			}
			break;
		case PORTD_ID:
			if (value == LOGIC_HIGH) {
    1428:	8b 81       	ldd	r24, Y+3	; 0x03
    142a:	81 30       	cpi	r24, 0x01	; 1
    142c:	a1 f4       	brne	.+40     	; 0x1456 <GPIO_writePin+0x19e>
				SET_BIT(PORTD, pin_num);
    142e:	a2 e3       	ldi	r26, 0x32	; 50
    1430:	b0 e0       	ldi	r27, 0x00	; 0
    1432:	e2 e3       	ldi	r30, 0x32	; 50
    1434:	f0 e0       	ldi	r31, 0x00	; 0
    1436:	80 81       	ld	r24, Z
    1438:	48 2f       	mov	r20, r24
    143a:	8a 81       	ldd	r24, Y+2	; 0x02
    143c:	28 2f       	mov	r18, r24
    143e:	30 e0       	ldi	r19, 0x00	; 0
    1440:	81 e0       	ldi	r24, 0x01	; 1
    1442:	90 e0       	ldi	r25, 0x00	; 0
    1444:	02 2e       	mov	r0, r18
    1446:	02 c0       	rjmp	.+4      	; 0x144c <GPIO_writePin+0x194>
    1448:	88 0f       	add	r24, r24
    144a:	99 1f       	adc	r25, r25
    144c:	0a 94       	dec	r0
    144e:	e2 f7       	brpl	.-8      	; 0x1448 <GPIO_writePin+0x190>
    1450:	84 2b       	or	r24, r20
    1452:	8c 93       	st	X, r24
    1454:	14 c0       	rjmp	.+40     	; 0x147e <GPIO_writePin+0x1c6>
			} else {
				CLEAR_BIT(PORTD, pin_num);
    1456:	a2 e3       	ldi	r26, 0x32	; 50
    1458:	b0 e0       	ldi	r27, 0x00	; 0
    145a:	e2 e3       	ldi	r30, 0x32	; 50
    145c:	f0 e0       	ldi	r31, 0x00	; 0
    145e:	80 81       	ld	r24, Z
    1460:	48 2f       	mov	r20, r24
    1462:	8a 81       	ldd	r24, Y+2	; 0x02
    1464:	28 2f       	mov	r18, r24
    1466:	30 e0       	ldi	r19, 0x00	; 0
    1468:	81 e0       	ldi	r24, 0x01	; 1
    146a:	90 e0       	ldi	r25, 0x00	; 0
    146c:	02 2e       	mov	r0, r18
    146e:	02 c0       	rjmp	.+4      	; 0x1474 <GPIO_writePin+0x1bc>
    1470:	88 0f       	add	r24, r24
    1472:	99 1f       	adc	r25, r25
    1474:	0a 94       	dec	r0
    1476:	e2 f7       	brpl	.-8      	; 0x1470 <GPIO_writePin+0x1b8>
    1478:	80 95       	com	r24
    147a:	84 23       	and	r24, r20
    147c:	8c 93       	st	X, r24
			}
			break;
		}
	}
}
    147e:	0f 90       	pop	r0
    1480:	0f 90       	pop	r0
    1482:	0f 90       	pop	r0
    1484:	0f 90       	pop	r0
    1486:	0f 90       	pop	r0
    1488:	cf 91       	pop	r28
    148a:	df 91       	pop	r29
    148c:	08 95       	ret

0000148e <GPIO_readPin>:
/*
 * Description :
 * Read and return the value for the required pin, it should be Logic High or Logic Low.
 * If the input port number or pin number are not correct, The function will return Logic Low.
 */
uint8 GPIO_readPin(uint8 port_num, uint8 pin_num) {
    148e:	df 93       	push	r29
    1490:	cf 93       	push	r28
    1492:	00 d0       	rcall	.+0      	; 0x1494 <GPIO_readPin+0x6>
    1494:	00 d0       	rcall	.+0      	; 0x1496 <GPIO_readPin+0x8>
    1496:	0f 92       	push	r0
    1498:	cd b7       	in	r28, 0x3d	; 61
    149a:	de b7       	in	r29, 0x3e	; 62
    149c:	8a 83       	std	Y+2, r24	; 0x02
    149e:	6b 83       	std	Y+3, r22	; 0x03
	uint8 pin_value = LOGIC_LOW;
    14a0:	19 82       	std	Y+1, r1	; 0x01
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if ((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS)) {
    14a2:	8b 81       	ldd	r24, Y+3	; 0x03
    14a4:	88 30       	cpi	r24, 0x08	; 8
    14a6:	08 f0       	brcs	.+2      	; 0x14aa <GPIO_readPin+0x1c>
    14a8:	84 c0       	rjmp	.+264    	; 0x15b2 <GPIO_readPin+0x124>
    14aa:	8a 81       	ldd	r24, Y+2	; 0x02
    14ac:	84 30       	cpi	r24, 0x04	; 4
    14ae:	08 f0       	brcs	.+2      	; 0x14b2 <GPIO_readPin+0x24>
    14b0:	80 c0       	rjmp	.+256    	; 0x15b2 <GPIO_readPin+0x124>
		/* Do Nothing */
	} else {
		/* Read the pin value as required */
		switch (port_num) {
    14b2:	8a 81       	ldd	r24, Y+2	; 0x02
    14b4:	28 2f       	mov	r18, r24
    14b6:	30 e0       	ldi	r19, 0x00	; 0
    14b8:	3d 83       	std	Y+5, r19	; 0x05
    14ba:	2c 83       	std	Y+4, r18	; 0x04
    14bc:	4c 81       	ldd	r20, Y+4	; 0x04
    14be:	5d 81       	ldd	r21, Y+5	; 0x05
    14c0:	41 30       	cpi	r20, 0x01	; 1
    14c2:	51 05       	cpc	r21, r1
    14c4:	79 f1       	breq	.+94     	; 0x1524 <GPIO_readPin+0x96>
    14c6:	8c 81       	ldd	r24, Y+4	; 0x04
    14c8:	9d 81       	ldd	r25, Y+5	; 0x05
    14ca:	82 30       	cpi	r24, 0x02	; 2
    14cc:	91 05       	cpc	r25, r1
    14ce:	34 f4       	brge	.+12     	; 0x14dc <GPIO_readPin+0x4e>
    14d0:	2c 81       	ldd	r18, Y+4	; 0x04
    14d2:	3d 81       	ldd	r19, Y+5	; 0x05
    14d4:	21 15       	cp	r18, r1
    14d6:	31 05       	cpc	r19, r1
    14d8:	69 f0       	breq	.+26     	; 0x14f4 <GPIO_readPin+0x66>
    14da:	6b c0       	rjmp	.+214    	; 0x15b2 <GPIO_readPin+0x124>
    14dc:	4c 81       	ldd	r20, Y+4	; 0x04
    14de:	5d 81       	ldd	r21, Y+5	; 0x05
    14e0:	42 30       	cpi	r20, 0x02	; 2
    14e2:	51 05       	cpc	r21, r1
    14e4:	b9 f1       	breq	.+110    	; 0x1554 <GPIO_readPin+0xc6>
    14e6:	8c 81       	ldd	r24, Y+4	; 0x04
    14e8:	9d 81       	ldd	r25, Y+5	; 0x05
    14ea:	83 30       	cpi	r24, 0x03	; 3
    14ec:	91 05       	cpc	r25, r1
    14ee:	09 f4       	brne	.+2      	; 0x14f2 <GPIO_readPin+0x64>
    14f0:	49 c0       	rjmp	.+146    	; 0x1584 <GPIO_readPin+0xf6>
    14f2:	5f c0       	rjmp	.+190    	; 0x15b2 <GPIO_readPin+0x124>
		case PORTA_ID:
			if (BIT_IS_SET(PINA, pin_num)) {
    14f4:	e9 e3       	ldi	r30, 0x39	; 57
    14f6:	f0 e0       	ldi	r31, 0x00	; 0
    14f8:	80 81       	ld	r24, Z
    14fa:	28 2f       	mov	r18, r24
    14fc:	30 e0       	ldi	r19, 0x00	; 0
    14fe:	8b 81       	ldd	r24, Y+3	; 0x03
    1500:	88 2f       	mov	r24, r24
    1502:	90 e0       	ldi	r25, 0x00	; 0
    1504:	a9 01       	movw	r20, r18
    1506:	02 c0       	rjmp	.+4      	; 0x150c <GPIO_readPin+0x7e>
    1508:	55 95       	asr	r21
    150a:	47 95       	ror	r20
    150c:	8a 95       	dec	r24
    150e:	e2 f7       	brpl	.-8      	; 0x1508 <GPIO_readPin+0x7a>
    1510:	ca 01       	movw	r24, r20
    1512:	81 70       	andi	r24, 0x01	; 1
    1514:	90 70       	andi	r25, 0x00	; 0
    1516:	88 23       	and	r24, r24
    1518:	19 f0       	breq	.+6      	; 0x1520 <GPIO_readPin+0x92>
				pin_value = LOGIC_HIGH;
    151a:	81 e0       	ldi	r24, 0x01	; 1
    151c:	89 83       	std	Y+1, r24	; 0x01
    151e:	49 c0       	rjmp	.+146    	; 0x15b2 <GPIO_readPin+0x124>
			} else {
				pin_value = LOGIC_LOW;
    1520:	19 82       	std	Y+1, r1	; 0x01
    1522:	47 c0       	rjmp	.+142    	; 0x15b2 <GPIO_readPin+0x124>
			}
			break;
		case PORTB_ID:
			if (BIT_IS_SET(PINB, pin_num)) {
    1524:	e6 e3       	ldi	r30, 0x36	; 54
    1526:	f0 e0       	ldi	r31, 0x00	; 0
    1528:	80 81       	ld	r24, Z
    152a:	28 2f       	mov	r18, r24
    152c:	30 e0       	ldi	r19, 0x00	; 0
    152e:	8b 81       	ldd	r24, Y+3	; 0x03
    1530:	88 2f       	mov	r24, r24
    1532:	90 e0       	ldi	r25, 0x00	; 0
    1534:	a9 01       	movw	r20, r18
    1536:	02 c0       	rjmp	.+4      	; 0x153c <GPIO_readPin+0xae>
    1538:	55 95       	asr	r21
    153a:	47 95       	ror	r20
    153c:	8a 95       	dec	r24
    153e:	e2 f7       	brpl	.-8      	; 0x1538 <GPIO_readPin+0xaa>
    1540:	ca 01       	movw	r24, r20
    1542:	81 70       	andi	r24, 0x01	; 1
    1544:	90 70       	andi	r25, 0x00	; 0
    1546:	88 23       	and	r24, r24
    1548:	19 f0       	breq	.+6      	; 0x1550 <GPIO_readPin+0xc2>
				pin_value = LOGIC_HIGH;
    154a:	81 e0       	ldi	r24, 0x01	; 1
    154c:	89 83       	std	Y+1, r24	; 0x01
    154e:	31 c0       	rjmp	.+98     	; 0x15b2 <GPIO_readPin+0x124>
			} else {
				pin_value = LOGIC_LOW;
    1550:	19 82       	std	Y+1, r1	; 0x01
    1552:	2f c0       	rjmp	.+94     	; 0x15b2 <GPIO_readPin+0x124>
			}
			break;
		case PORTC_ID:
			if (BIT_IS_SET(PINC, pin_num)) {
    1554:	e3 e3       	ldi	r30, 0x33	; 51
    1556:	f0 e0       	ldi	r31, 0x00	; 0
    1558:	80 81       	ld	r24, Z
    155a:	28 2f       	mov	r18, r24
    155c:	30 e0       	ldi	r19, 0x00	; 0
    155e:	8b 81       	ldd	r24, Y+3	; 0x03
    1560:	88 2f       	mov	r24, r24
    1562:	90 e0       	ldi	r25, 0x00	; 0
    1564:	a9 01       	movw	r20, r18
    1566:	02 c0       	rjmp	.+4      	; 0x156c <GPIO_readPin+0xde>
    1568:	55 95       	asr	r21
    156a:	47 95       	ror	r20
    156c:	8a 95       	dec	r24
    156e:	e2 f7       	brpl	.-8      	; 0x1568 <GPIO_readPin+0xda>
    1570:	ca 01       	movw	r24, r20
    1572:	81 70       	andi	r24, 0x01	; 1
    1574:	90 70       	andi	r25, 0x00	; 0
    1576:	88 23       	and	r24, r24
    1578:	19 f0       	breq	.+6      	; 0x1580 <GPIO_readPin+0xf2>
				pin_value = LOGIC_HIGH;
    157a:	81 e0       	ldi	r24, 0x01	; 1
    157c:	89 83       	std	Y+1, r24	; 0x01
    157e:	19 c0       	rjmp	.+50     	; 0x15b2 <GPIO_readPin+0x124>
			} else {
				pin_value = LOGIC_LOW;
    1580:	19 82       	std	Y+1, r1	; 0x01
    1582:	17 c0       	rjmp	.+46     	; 0x15b2 <GPIO_readPin+0x124>
			}
			break;
		case PORTD_ID:
			if (BIT_IS_SET(PIND, pin_num)) {
    1584:	e0 e3       	ldi	r30, 0x30	; 48
    1586:	f0 e0       	ldi	r31, 0x00	; 0
    1588:	80 81       	ld	r24, Z
    158a:	28 2f       	mov	r18, r24
    158c:	30 e0       	ldi	r19, 0x00	; 0
    158e:	8b 81       	ldd	r24, Y+3	; 0x03
    1590:	88 2f       	mov	r24, r24
    1592:	90 e0       	ldi	r25, 0x00	; 0
    1594:	a9 01       	movw	r20, r18
    1596:	02 c0       	rjmp	.+4      	; 0x159c <GPIO_readPin+0x10e>
    1598:	55 95       	asr	r21
    159a:	47 95       	ror	r20
    159c:	8a 95       	dec	r24
    159e:	e2 f7       	brpl	.-8      	; 0x1598 <GPIO_readPin+0x10a>
    15a0:	ca 01       	movw	r24, r20
    15a2:	81 70       	andi	r24, 0x01	; 1
    15a4:	90 70       	andi	r25, 0x00	; 0
    15a6:	88 23       	and	r24, r24
    15a8:	19 f0       	breq	.+6      	; 0x15b0 <GPIO_readPin+0x122>
				pin_value = LOGIC_HIGH;
    15aa:	81 e0       	ldi	r24, 0x01	; 1
    15ac:	89 83       	std	Y+1, r24	; 0x01
    15ae:	01 c0       	rjmp	.+2      	; 0x15b2 <GPIO_readPin+0x124>
			} else {
				pin_value = LOGIC_LOW;
    15b0:	19 82       	std	Y+1, r1	; 0x01
			}
			break;
		}
	}

	return pin_value;
    15b2:	89 81       	ldd	r24, Y+1	; 0x01
}
    15b4:	0f 90       	pop	r0
    15b6:	0f 90       	pop	r0
    15b8:	0f 90       	pop	r0
    15ba:	0f 90       	pop	r0
    15bc:	0f 90       	pop	r0
    15be:	cf 91       	pop	r28
    15c0:	df 91       	pop	r29
    15c2:	08 95       	ret

000015c4 <GPIO_setupPortDirection>:
 * Setup the direction of the required port all pins input/output.
 * If the direction value is PORT_INPUT all pins in this port should be input pins.
 * If the direction value is PORT_OUTPUT all pins in this port should be output pins.
 * If the input port number is not correct, The function will not handle the request.
 */
void GPIO_setupPortDirection(uint8 port_num, GPIO_PortDirectionType direction) {
    15c4:	df 93       	push	r29
    15c6:	cf 93       	push	r28
    15c8:	00 d0       	rcall	.+0      	; 0x15ca <GPIO_setupPortDirection+0x6>
    15ca:	00 d0       	rcall	.+0      	; 0x15cc <GPIO_setupPortDirection+0x8>
    15cc:	cd b7       	in	r28, 0x3d	; 61
    15ce:	de b7       	in	r29, 0x3e	; 62
    15d0:	89 83       	std	Y+1, r24	; 0x01
    15d2:	6a 83       	std	Y+2, r22	; 0x02
	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if (port_num >= NUM_OF_PORTS) {
    15d4:	89 81       	ldd	r24, Y+1	; 0x01
    15d6:	84 30       	cpi	r24, 0x04	; 4
    15d8:	90 f5       	brcc	.+100    	; 0x163e <GPIO_setupPortDirection+0x7a>
		/* Do Nothing */
	} else {
		/* Setup the port direction as required */
		switch (port_num) {
    15da:	89 81       	ldd	r24, Y+1	; 0x01
    15dc:	28 2f       	mov	r18, r24
    15de:	30 e0       	ldi	r19, 0x00	; 0
    15e0:	3c 83       	std	Y+4, r19	; 0x04
    15e2:	2b 83       	std	Y+3, r18	; 0x03
    15e4:	8b 81       	ldd	r24, Y+3	; 0x03
    15e6:	9c 81       	ldd	r25, Y+4	; 0x04
    15e8:	81 30       	cpi	r24, 0x01	; 1
    15ea:	91 05       	cpc	r25, r1
    15ec:	d1 f0       	breq	.+52     	; 0x1622 <GPIO_setupPortDirection+0x5e>
    15ee:	2b 81       	ldd	r18, Y+3	; 0x03
    15f0:	3c 81       	ldd	r19, Y+4	; 0x04
    15f2:	22 30       	cpi	r18, 0x02	; 2
    15f4:	31 05       	cpc	r19, r1
    15f6:	2c f4       	brge	.+10     	; 0x1602 <GPIO_setupPortDirection+0x3e>
    15f8:	8b 81       	ldd	r24, Y+3	; 0x03
    15fa:	9c 81       	ldd	r25, Y+4	; 0x04
    15fc:	00 97       	sbiw	r24, 0x00	; 0
    15fe:	61 f0       	breq	.+24     	; 0x1618 <GPIO_setupPortDirection+0x54>
    1600:	1e c0       	rjmp	.+60     	; 0x163e <GPIO_setupPortDirection+0x7a>
    1602:	2b 81       	ldd	r18, Y+3	; 0x03
    1604:	3c 81       	ldd	r19, Y+4	; 0x04
    1606:	22 30       	cpi	r18, 0x02	; 2
    1608:	31 05       	cpc	r19, r1
    160a:	81 f0       	breq	.+32     	; 0x162c <GPIO_setupPortDirection+0x68>
    160c:	8b 81       	ldd	r24, Y+3	; 0x03
    160e:	9c 81       	ldd	r25, Y+4	; 0x04
    1610:	83 30       	cpi	r24, 0x03	; 3
    1612:	91 05       	cpc	r25, r1
    1614:	81 f0       	breq	.+32     	; 0x1636 <GPIO_setupPortDirection+0x72>
    1616:	13 c0       	rjmp	.+38     	; 0x163e <GPIO_setupPortDirection+0x7a>
		case PORTA_ID:
			DDRA = direction;
    1618:	ea e3       	ldi	r30, 0x3A	; 58
    161a:	f0 e0       	ldi	r31, 0x00	; 0
    161c:	8a 81       	ldd	r24, Y+2	; 0x02
    161e:	80 83       	st	Z, r24
    1620:	0e c0       	rjmp	.+28     	; 0x163e <GPIO_setupPortDirection+0x7a>
			break;
		case PORTB_ID:
			DDRB = direction;
    1622:	e7 e3       	ldi	r30, 0x37	; 55
    1624:	f0 e0       	ldi	r31, 0x00	; 0
    1626:	8a 81       	ldd	r24, Y+2	; 0x02
    1628:	80 83       	st	Z, r24
    162a:	09 c0       	rjmp	.+18     	; 0x163e <GPIO_setupPortDirection+0x7a>
			break;
		case PORTC_ID:
			DDRC = direction;
    162c:	e4 e3       	ldi	r30, 0x34	; 52
    162e:	f0 e0       	ldi	r31, 0x00	; 0
    1630:	8a 81       	ldd	r24, Y+2	; 0x02
    1632:	80 83       	st	Z, r24
    1634:	04 c0       	rjmp	.+8      	; 0x163e <GPIO_setupPortDirection+0x7a>
			break;
		case PORTD_ID:
			DDRD = direction;
    1636:	e1 e3       	ldi	r30, 0x31	; 49
    1638:	f0 e0       	ldi	r31, 0x00	; 0
    163a:	8a 81       	ldd	r24, Y+2	; 0x02
    163c:	80 83       	st	Z, r24
			break;
		}
	}
}
    163e:	0f 90       	pop	r0
    1640:	0f 90       	pop	r0
    1642:	0f 90       	pop	r0
    1644:	0f 90       	pop	r0
    1646:	cf 91       	pop	r28
    1648:	df 91       	pop	r29
    164a:	08 95       	ret

0000164c <GPIO_writePort>:
 * Write the value on the required port.
 * If any pin in the port is output pin the value will be written.
 * If any pin in the port is input pin this will activate/deactivate the internal pull-up resistor.
 * If the input port number is not correct, The function will not handle the request.
 */
void GPIO_writePort(uint8 port_num, uint8 value) {
    164c:	df 93       	push	r29
    164e:	cf 93       	push	r28
    1650:	00 d0       	rcall	.+0      	; 0x1652 <GPIO_writePort+0x6>
    1652:	00 d0       	rcall	.+0      	; 0x1654 <GPIO_writePort+0x8>
    1654:	cd b7       	in	r28, 0x3d	; 61
    1656:	de b7       	in	r29, 0x3e	; 62
    1658:	89 83       	std	Y+1, r24	; 0x01
    165a:	6a 83       	std	Y+2, r22	; 0x02
	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if (port_num >= NUM_OF_PORTS) {
    165c:	89 81       	ldd	r24, Y+1	; 0x01
    165e:	84 30       	cpi	r24, 0x04	; 4
    1660:	90 f5       	brcc	.+100    	; 0x16c6 <GPIO_writePort+0x7a>
		/* Do Nothing */
	} else {
		/* Write the port value as required */
		switch (port_num) {
    1662:	89 81       	ldd	r24, Y+1	; 0x01
    1664:	28 2f       	mov	r18, r24
    1666:	30 e0       	ldi	r19, 0x00	; 0
    1668:	3c 83       	std	Y+4, r19	; 0x04
    166a:	2b 83       	std	Y+3, r18	; 0x03
    166c:	8b 81       	ldd	r24, Y+3	; 0x03
    166e:	9c 81       	ldd	r25, Y+4	; 0x04
    1670:	81 30       	cpi	r24, 0x01	; 1
    1672:	91 05       	cpc	r25, r1
    1674:	d1 f0       	breq	.+52     	; 0x16aa <GPIO_writePort+0x5e>
    1676:	2b 81       	ldd	r18, Y+3	; 0x03
    1678:	3c 81       	ldd	r19, Y+4	; 0x04
    167a:	22 30       	cpi	r18, 0x02	; 2
    167c:	31 05       	cpc	r19, r1
    167e:	2c f4       	brge	.+10     	; 0x168a <GPIO_writePort+0x3e>
    1680:	8b 81       	ldd	r24, Y+3	; 0x03
    1682:	9c 81       	ldd	r25, Y+4	; 0x04
    1684:	00 97       	sbiw	r24, 0x00	; 0
    1686:	61 f0       	breq	.+24     	; 0x16a0 <GPIO_writePort+0x54>
    1688:	1e c0       	rjmp	.+60     	; 0x16c6 <GPIO_writePort+0x7a>
    168a:	2b 81       	ldd	r18, Y+3	; 0x03
    168c:	3c 81       	ldd	r19, Y+4	; 0x04
    168e:	22 30       	cpi	r18, 0x02	; 2
    1690:	31 05       	cpc	r19, r1
    1692:	81 f0       	breq	.+32     	; 0x16b4 <GPIO_writePort+0x68>
    1694:	8b 81       	ldd	r24, Y+3	; 0x03
    1696:	9c 81       	ldd	r25, Y+4	; 0x04
    1698:	83 30       	cpi	r24, 0x03	; 3
    169a:	91 05       	cpc	r25, r1
    169c:	81 f0       	breq	.+32     	; 0x16be <GPIO_writePort+0x72>
    169e:	13 c0       	rjmp	.+38     	; 0x16c6 <GPIO_writePort+0x7a>
		case PORTA_ID:
			PORTA = value;
    16a0:	eb e3       	ldi	r30, 0x3B	; 59
    16a2:	f0 e0       	ldi	r31, 0x00	; 0
    16a4:	8a 81       	ldd	r24, Y+2	; 0x02
    16a6:	80 83       	st	Z, r24
    16a8:	0e c0       	rjmp	.+28     	; 0x16c6 <GPIO_writePort+0x7a>
			break;
		case PORTB_ID:
			PORTB = value;
    16aa:	e8 e3       	ldi	r30, 0x38	; 56
    16ac:	f0 e0       	ldi	r31, 0x00	; 0
    16ae:	8a 81       	ldd	r24, Y+2	; 0x02
    16b0:	80 83       	st	Z, r24
    16b2:	09 c0       	rjmp	.+18     	; 0x16c6 <GPIO_writePort+0x7a>
			break;
		case PORTC_ID:
			PORTC = value;
    16b4:	e5 e3       	ldi	r30, 0x35	; 53
    16b6:	f0 e0       	ldi	r31, 0x00	; 0
    16b8:	8a 81       	ldd	r24, Y+2	; 0x02
    16ba:	80 83       	st	Z, r24
    16bc:	04 c0       	rjmp	.+8      	; 0x16c6 <GPIO_writePort+0x7a>
			break;
		case PORTD_ID:
			PORTD = value;
    16be:	e2 e3       	ldi	r30, 0x32	; 50
    16c0:	f0 e0       	ldi	r31, 0x00	; 0
    16c2:	8a 81       	ldd	r24, Y+2	; 0x02
    16c4:	80 83       	st	Z, r24
			break;
		}
	}
}
    16c6:	0f 90       	pop	r0
    16c8:	0f 90       	pop	r0
    16ca:	0f 90       	pop	r0
    16cc:	0f 90       	pop	r0
    16ce:	cf 91       	pop	r28
    16d0:	df 91       	pop	r29
    16d2:	08 95       	ret

000016d4 <GPIO_readPort>:
/*
 * Description :
 * Read and return the value of the required port.
 * If the input port number is not correct, The function will return ZERO value.
 */
uint8 GPIO_readPort(uint8 port_num) {
    16d4:	df 93       	push	r29
    16d6:	cf 93       	push	r28
    16d8:	00 d0       	rcall	.+0      	; 0x16da <GPIO_readPort+0x6>
    16da:	00 d0       	rcall	.+0      	; 0x16dc <GPIO_readPort+0x8>
    16dc:	cd b7       	in	r28, 0x3d	; 61
    16de:	de b7       	in	r29, 0x3e	; 62
    16e0:	8a 83       	std	Y+2, r24	; 0x02
	uint8 value = LOGIC_LOW;
    16e2:	19 82       	std	Y+1, r1	; 0x01

	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if (port_num >= NUM_OF_PORTS) {
    16e4:	8a 81       	ldd	r24, Y+2	; 0x02
    16e6:	84 30       	cpi	r24, 0x04	; 4
    16e8:	90 f5       	brcc	.+100    	; 0x174e <GPIO_readPort+0x7a>
		/* Do Nothing */
	} else {
		/* Read the port value as required */
		switch (port_num) {
    16ea:	8a 81       	ldd	r24, Y+2	; 0x02
    16ec:	28 2f       	mov	r18, r24
    16ee:	30 e0       	ldi	r19, 0x00	; 0
    16f0:	3c 83       	std	Y+4, r19	; 0x04
    16f2:	2b 83       	std	Y+3, r18	; 0x03
    16f4:	8b 81       	ldd	r24, Y+3	; 0x03
    16f6:	9c 81       	ldd	r25, Y+4	; 0x04
    16f8:	81 30       	cpi	r24, 0x01	; 1
    16fa:	91 05       	cpc	r25, r1
    16fc:	d1 f0       	breq	.+52     	; 0x1732 <GPIO_readPort+0x5e>
    16fe:	2b 81       	ldd	r18, Y+3	; 0x03
    1700:	3c 81       	ldd	r19, Y+4	; 0x04
    1702:	22 30       	cpi	r18, 0x02	; 2
    1704:	31 05       	cpc	r19, r1
    1706:	2c f4       	brge	.+10     	; 0x1712 <GPIO_readPort+0x3e>
    1708:	8b 81       	ldd	r24, Y+3	; 0x03
    170a:	9c 81       	ldd	r25, Y+4	; 0x04
    170c:	00 97       	sbiw	r24, 0x00	; 0
    170e:	61 f0       	breq	.+24     	; 0x1728 <GPIO_readPort+0x54>
    1710:	1e c0       	rjmp	.+60     	; 0x174e <GPIO_readPort+0x7a>
    1712:	2b 81       	ldd	r18, Y+3	; 0x03
    1714:	3c 81       	ldd	r19, Y+4	; 0x04
    1716:	22 30       	cpi	r18, 0x02	; 2
    1718:	31 05       	cpc	r19, r1
    171a:	81 f0       	breq	.+32     	; 0x173c <GPIO_readPort+0x68>
    171c:	8b 81       	ldd	r24, Y+3	; 0x03
    171e:	9c 81       	ldd	r25, Y+4	; 0x04
    1720:	83 30       	cpi	r24, 0x03	; 3
    1722:	91 05       	cpc	r25, r1
    1724:	81 f0       	breq	.+32     	; 0x1746 <GPIO_readPort+0x72>
    1726:	13 c0       	rjmp	.+38     	; 0x174e <GPIO_readPort+0x7a>
		case PORTA_ID:
			value = PINA;
    1728:	e9 e3       	ldi	r30, 0x39	; 57
    172a:	f0 e0       	ldi	r31, 0x00	; 0
    172c:	80 81       	ld	r24, Z
    172e:	89 83       	std	Y+1, r24	; 0x01
    1730:	0e c0       	rjmp	.+28     	; 0x174e <GPIO_readPort+0x7a>
			break;
		case PORTB_ID:
			value = PINB;
    1732:	e6 e3       	ldi	r30, 0x36	; 54
    1734:	f0 e0       	ldi	r31, 0x00	; 0
    1736:	80 81       	ld	r24, Z
    1738:	89 83       	std	Y+1, r24	; 0x01
    173a:	09 c0       	rjmp	.+18     	; 0x174e <GPIO_readPort+0x7a>
			break;
		case PORTC_ID:
			value = PINC;
    173c:	e3 e3       	ldi	r30, 0x33	; 51
    173e:	f0 e0       	ldi	r31, 0x00	; 0
    1740:	80 81       	ld	r24, Z
    1742:	89 83       	std	Y+1, r24	; 0x01
    1744:	04 c0       	rjmp	.+8      	; 0x174e <GPIO_readPort+0x7a>
			break;
		case PORTD_ID:
			value = PIND;
    1746:	e0 e3       	ldi	r30, 0x30	; 48
    1748:	f0 e0       	ldi	r31, 0x00	; 0
    174a:	80 81       	ld	r24, Z
    174c:	89 83       	std	Y+1, r24	; 0x01
			break;
		}
	}

	return value;
    174e:	89 81       	ldd	r24, Y+1	; 0x01
}
    1750:	0f 90       	pop	r0
    1752:	0f 90       	pop	r0
    1754:	0f 90       	pop	r0
    1756:	0f 90       	pop	r0
    1758:	cf 91       	pop	r28
    175a:	df 91       	pop	r29
    175c:	08 95       	ret

0000175e <EEPROM_writeByte>:
 *******************************************************************************/
#include "external_eeprom.h"



uint8 EEPROM_writeByte(uint16 u16addr, uint8 u8data) {
    175e:	df 93       	push	r29
    1760:	cf 93       	push	r28
    1762:	00 d0       	rcall	.+0      	; 0x1764 <EEPROM_writeByte+0x6>
    1764:	00 d0       	rcall	.+0      	; 0x1766 <EEPROM_writeByte+0x8>
    1766:	cd b7       	in	r28, 0x3d	; 61
    1768:	de b7       	in	r29, 0x3e	; 62
    176a:	9a 83       	std	Y+2, r25	; 0x02
    176c:	89 83       	std	Y+1, r24	; 0x01
    176e:	6b 83       	std	Y+3, r22	; 0x03
	/* Send the Start Bit */
	TWI_start();
    1770:	0e 94 0a 08 	call	0x1014	; 0x1014 <TWI_start>
	if (TWI_getStatus() != TWI_START)
    1774:	0e 94 62 08 	call	0x10c4	; 0x10c4 <TWI_getStatus>
    1778:	88 30       	cpi	r24, 0x08	; 8
    177a:	11 f0       	breq	.+4      	; 0x1780 <EEPROM_writeByte+0x22>
		return ERROR;
    177c:	1c 82       	std	Y+4, r1	; 0x04
    177e:	28 c0       	rjmp	.+80     	; 0x17d0 <EEPROM_writeByte+0x72>

	/* Send the device address, we need to get A8 A9 A10 address bits from the
	 * memory location address and R/W=0 (write) */
	TWI_writeByte((uint8) (0xA0 | ((u16addr & 0x0700) >> 7)));
    1780:	89 81       	ldd	r24, Y+1	; 0x01
    1782:	9a 81       	ldd	r25, Y+2	; 0x02
    1784:	80 70       	andi	r24, 0x00	; 0
    1786:	97 70       	andi	r25, 0x07	; 7
    1788:	88 0f       	add	r24, r24
    178a:	89 2f       	mov	r24, r25
    178c:	88 1f       	adc	r24, r24
    178e:	99 0b       	sbc	r25, r25
    1790:	91 95       	neg	r25
    1792:	80 6a       	ori	r24, 0xA0	; 160
    1794:	0e 94 25 08 	call	0x104a	; 0x104a <TWI_writeByte>
	if (TWI_getStatus() != TWI_MT_SLA_W_ACK)
    1798:	0e 94 62 08 	call	0x10c4	; 0x10c4 <TWI_getStatus>
    179c:	88 31       	cpi	r24, 0x18	; 24
    179e:	11 f0       	breq	.+4      	; 0x17a4 <EEPROM_writeByte+0x46>
		return ERROR;
    17a0:	1c 82       	std	Y+4, r1	; 0x04
    17a2:	16 c0       	rjmp	.+44     	; 0x17d0 <EEPROM_writeByte+0x72>

	/* Send the required memory location address */
	TWI_writeByte((uint8) (u16addr));
    17a4:	89 81       	ldd	r24, Y+1	; 0x01
    17a6:	0e 94 25 08 	call	0x104a	; 0x104a <TWI_writeByte>
	if (TWI_getStatus() != TWI_MT_DATA_ACK)
    17aa:	0e 94 62 08 	call	0x10c4	; 0x10c4 <TWI_getStatus>
    17ae:	88 32       	cpi	r24, 0x28	; 40
    17b0:	11 f0       	breq	.+4      	; 0x17b6 <EEPROM_writeByte+0x58>
		return ERROR;
    17b2:	1c 82       	std	Y+4, r1	; 0x04
    17b4:	0d c0       	rjmp	.+26     	; 0x17d0 <EEPROM_writeByte+0x72>

	/* write byte to eeprom */
	TWI_writeByte(u8data);
    17b6:	8b 81       	ldd	r24, Y+3	; 0x03
    17b8:	0e 94 25 08 	call	0x104a	; 0x104a <TWI_writeByte>
	if (TWI_getStatus() != TWI_MT_DATA_ACK)
    17bc:	0e 94 62 08 	call	0x10c4	; 0x10c4 <TWI_getStatus>
    17c0:	88 32       	cpi	r24, 0x28	; 40
    17c2:	11 f0       	breq	.+4      	; 0x17c8 <EEPROM_writeByte+0x6a>
		return ERROR;
    17c4:	1c 82       	std	Y+4, r1	; 0x04
    17c6:	04 c0       	rjmp	.+8      	; 0x17d0 <EEPROM_writeByte+0x72>

	/* Send the Stop Bit */
	TWI_stop();
    17c8:	0e 94 1a 08 	call	0x1034	; 0x1034 <TWI_stop>

	return SUCCESS;
    17cc:	81 e0       	ldi	r24, 0x01	; 1
    17ce:	8c 83       	std	Y+4, r24	; 0x04
    17d0:	8c 81       	ldd	r24, Y+4	; 0x04
}
    17d2:	0f 90       	pop	r0
    17d4:	0f 90       	pop	r0
    17d6:	0f 90       	pop	r0
    17d8:	0f 90       	pop	r0
    17da:	cf 91       	pop	r28
    17dc:	df 91       	pop	r29
    17de:	08 95       	ret

000017e0 <EEPROM_readByte>:

uint8 EEPROM_readByte(uint16 u16addr, uint8 *u8data) {
    17e0:	df 93       	push	r29
    17e2:	cf 93       	push	r28
    17e4:	00 d0       	rcall	.+0      	; 0x17e6 <EEPROM_readByte+0x6>
    17e6:	00 d0       	rcall	.+0      	; 0x17e8 <EEPROM_readByte+0x8>
    17e8:	0f 92       	push	r0
    17ea:	cd b7       	in	r28, 0x3d	; 61
    17ec:	de b7       	in	r29, 0x3e	; 62
    17ee:	9a 83       	std	Y+2, r25	; 0x02
    17f0:	89 83       	std	Y+1, r24	; 0x01
    17f2:	7c 83       	std	Y+4, r23	; 0x04
    17f4:	6b 83       	std	Y+3, r22	; 0x03
	/* Send the Start Bit */
	TWI_start();
    17f6:	0e 94 0a 08 	call	0x1014	; 0x1014 <TWI_start>
	if (TWI_getStatus() != TWI_START)
    17fa:	0e 94 62 08 	call	0x10c4	; 0x10c4 <TWI_getStatus>
    17fe:	88 30       	cpi	r24, 0x08	; 8
    1800:	11 f0       	breq	.+4      	; 0x1806 <EEPROM_readByte+0x26>
		return ERROR;
    1802:	1d 82       	std	Y+5, r1	; 0x05
    1804:	44 c0       	rjmp	.+136    	; 0x188e <EEPROM_readByte+0xae>

	/* Send the device address, we need to get A8 A9 A10 address bits from the
	 * memory location address and R/W=0 (write) */
	TWI_writeByte((uint8) ((0xA0) | ((u16addr & 0x0700) >> 7)));
    1806:	89 81       	ldd	r24, Y+1	; 0x01
    1808:	9a 81       	ldd	r25, Y+2	; 0x02
    180a:	80 70       	andi	r24, 0x00	; 0
    180c:	97 70       	andi	r25, 0x07	; 7
    180e:	88 0f       	add	r24, r24
    1810:	89 2f       	mov	r24, r25
    1812:	88 1f       	adc	r24, r24
    1814:	99 0b       	sbc	r25, r25
    1816:	91 95       	neg	r25
    1818:	80 6a       	ori	r24, 0xA0	; 160
    181a:	0e 94 25 08 	call	0x104a	; 0x104a <TWI_writeByte>
	if (TWI_getStatus() != TWI_MT_SLA_W_ACK)
    181e:	0e 94 62 08 	call	0x10c4	; 0x10c4 <TWI_getStatus>
    1822:	88 31       	cpi	r24, 0x18	; 24
    1824:	11 f0       	breq	.+4      	; 0x182a <EEPROM_readByte+0x4a>
		return ERROR;
    1826:	1d 82       	std	Y+5, r1	; 0x05
    1828:	32 c0       	rjmp	.+100    	; 0x188e <EEPROM_readByte+0xae>

	/* Send the required memory location address */
	TWI_writeByte((uint8) (u16addr));
    182a:	89 81       	ldd	r24, Y+1	; 0x01
    182c:	0e 94 25 08 	call	0x104a	; 0x104a <TWI_writeByte>
	if (TWI_getStatus() != TWI_MT_DATA_ACK)
    1830:	0e 94 62 08 	call	0x10c4	; 0x10c4 <TWI_getStatus>
    1834:	88 32       	cpi	r24, 0x28	; 40
    1836:	11 f0       	breq	.+4      	; 0x183c <EEPROM_readByte+0x5c>
		return ERROR;
    1838:	1d 82       	std	Y+5, r1	; 0x05
    183a:	29 c0       	rjmp	.+82     	; 0x188e <EEPROM_readByte+0xae>

	/* Send the Repeated Start Bit */
	TWI_start();
    183c:	0e 94 0a 08 	call	0x1014	; 0x1014 <TWI_start>
	if (TWI_getStatus() != TWI_REP_START)
    1840:	0e 94 62 08 	call	0x10c4	; 0x10c4 <TWI_getStatus>
    1844:	80 31       	cpi	r24, 0x10	; 16
    1846:	11 f0       	breq	.+4      	; 0x184c <EEPROM_readByte+0x6c>
		return ERROR;
    1848:	1d 82       	std	Y+5, r1	; 0x05
    184a:	21 c0       	rjmp	.+66     	; 0x188e <EEPROM_readByte+0xae>

	/* Send the device address, we need to get A8 A9 A10 address bits from the
	 * memory location address and R/W=1 (Read) */
	TWI_writeByte((uint8) ((0xA0) | ((u16addr & 0x0700) >> 7) | 1));
    184c:	89 81       	ldd	r24, Y+1	; 0x01
    184e:	9a 81       	ldd	r25, Y+2	; 0x02
    1850:	80 70       	andi	r24, 0x00	; 0
    1852:	97 70       	andi	r25, 0x07	; 7
    1854:	88 0f       	add	r24, r24
    1856:	89 2f       	mov	r24, r25
    1858:	88 1f       	adc	r24, r24
    185a:	99 0b       	sbc	r25, r25
    185c:	91 95       	neg	r25
    185e:	81 6a       	ori	r24, 0xA1	; 161
    1860:	0e 94 25 08 	call	0x104a	; 0x104a <TWI_writeByte>
	if (TWI_getStatus() != TWI_MT_SLA_R_ACK)
    1864:	0e 94 62 08 	call	0x10c4	; 0x10c4 <TWI_getStatus>
    1868:	80 34       	cpi	r24, 0x40	; 64
    186a:	11 f0       	breq	.+4      	; 0x1870 <EEPROM_readByte+0x90>
		return ERROR;
    186c:	1d 82       	std	Y+5, r1	; 0x05
    186e:	0f c0       	rjmp	.+30     	; 0x188e <EEPROM_readByte+0xae>

	/* Read Byte from Memory without send ACK */
	*u8data = TWI_readByteWithNACK();
    1870:	0e 94 4f 08 	call	0x109e	; 0x109e <TWI_readByteWithNACK>
    1874:	eb 81       	ldd	r30, Y+3	; 0x03
    1876:	fc 81       	ldd	r31, Y+4	; 0x04
    1878:	80 83       	st	Z, r24
	if (TWI_getStatus() != TWI_MR_DATA_NACK)
    187a:	0e 94 62 08 	call	0x10c4	; 0x10c4 <TWI_getStatus>
    187e:	88 35       	cpi	r24, 0x58	; 88
    1880:	11 f0       	breq	.+4      	; 0x1886 <EEPROM_readByte+0xa6>
		return ERROR;
    1882:	1d 82       	std	Y+5, r1	; 0x05
    1884:	04 c0       	rjmp	.+8      	; 0x188e <EEPROM_readByte+0xae>

	/* Send the Stop Bit */
	TWI_stop();
    1886:	0e 94 1a 08 	call	0x1034	; 0x1034 <TWI_stop>

	return SUCCESS;
    188a:	81 e0       	ldi	r24, 0x01	; 1
    188c:	8d 83       	std	Y+5, r24	; 0x05
    188e:	8d 81       	ldd	r24, Y+5	; 0x05
}
    1890:	0f 90       	pop	r0
    1892:	0f 90       	pop	r0
    1894:	0f 90       	pop	r0
    1896:	0f 90       	pop	r0
    1898:	0f 90       	pop	r0
    189a:	cf 91       	pop	r28
    189c:	df 91       	pop	r29
    189e:	08 95       	ret

000018a0 <DcMotor_Init>:
 */

#include "dcmotor.h"
#include "../../General/std_types.h"

void DcMotor_Init(void) {
    18a0:	df 93       	push	r29
    18a2:	cf 93       	push	r28
    18a4:	cd b7       	in	r28, 0x3d	; 61
    18a6:	de b7       	in	r29, 0x3e	; 62
	GPIO_setupPinDirection(MOTOR_PORT, IN1, PIN_OUTPUT);
    18a8:	81 e0       	ldi	r24, 0x01	; 1
    18aa:	65 e0       	ldi	r22, 0x05	; 5
    18ac:	41 e0       	ldi	r20, 0x01	; 1
    18ae:	0e 94 71 08 	call	0x10e2	; 0x10e2 <GPIO_setupPinDirection>
	GPIO_setupPinDirection(MOTOR_PORT, IN2, PIN_OUTPUT);
    18b2:	81 e0       	ldi	r24, 0x01	; 1
    18b4:	64 e0       	ldi	r22, 0x04	; 4
    18b6:	41 e0       	ldi	r20, 0x01	; 1
    18b8:	0e 94 71 08 	call	0x10e2	; 0x10e2 <GPIO_setupPinDirection>
	GPIO_writePin(MOTOR_PORT, IN1, LOGIC_LOW);
    18bc:	81 e0       	ldi	r24, 0x01	; 1
    18be:	65 e0       	ldi	r22, 0x05	; 5
    18c0:	40 e0       	ldi	r20, 0x00	; 0
    18c2:	0e 94 5c 09 	call	0x12b8	; 0x12b8 <GPIO_writePin>
	GPIO_writePin(MOTOR_PORT, IN2, LOGIC_LOW);
    18c6:	81 e0       	ldi	r24, 0x01	; 1
    18c8:	64 e0       	ldi	r22, 0x04	; 4
    18ca:	40 e0       	ldi	r20, 0x00	; 0
    18cc:	0e 94 5c 09 	call	0x12b8	; 0x12b8 <GPIO_writePin>

}
    18d0:	cf 91       	pop	r28
    18d2:	df 91       	pop	r29
    18d4:	08 95       	ret

000018d6 <DcMotor_Rotate>:

void DcMotor_Rotate(DcMotor_State state, uint8 speed) {
    18d6:	df 93       	push	r29
    18d8:	cf 93       	push	r28
    18da:	00 d0       	rcall	.+0      	; 0x18dc <DcMotor_Rotate+0x6>
    18dc:	00 d0       	rcall	.+0      	; 0x18de <DcMotor_Rotate+0x8>
    18de:	cd b7       	in	r28, 0x3d	; 61
    18e0:	de b7       	in	r29, 0x3e	; 62
    18e2:	89 83       	std	Y+1, r24	; 0x01
    18e4:	6a 83       	std	Y+2, r22	; 0x02
	///SPEED  0 -> 100
	//Duty Cycle 0-> 255

	PWM_Timer0_Start((uint8)(((uint16) MAX_PWM * speed) / (100)));
    18e6:	8a 81       	ldd	r24, Y+2	; 0x02
    18e8:	88 2f       	mov	r24, r24
    18ea:	90 e0       	ldi	r25, 0x00	; 0
    18ec:	98 2f       	mov	r25, r24
    18ee:	88 27       	eor	r24, r24
    18f0:	24 e6       	ldi	r18, 0x64	; 100
    18f2:	30 e0       	ldi	r19, 0x00	; 0
    18f4:	b9 01       	movw	r22, r18
    18f6:	0e 94 17 0f 	call	0x1e2e	; 0x1e2e <__udivmodhi4>
    18fa:	cb 01       	movw	r24, r22
    18fc:	0e 94 cd 06 	call	0xd9a	; 0xd9a <PWM_Timer0_Start>

	switch (state) {
    1900:	89 81       	ldd	r24, Y+1	; 0x01
    1902:	28 2f       	mov	r18, r24
    1904:	30 e0       	ldi	r19, 0x00	; 0
    1906:	3c 83       	std	Y+4, r19	; 0x04
    1908:	2b 83       	std	Y+3, r18	; 0x03
    190a:	8b 81       	ldd	r24, Y+3	; 0x03
    190c:	9c 81       	ldd	r25, Y+4	; 0x04
    190e:	81 30       	cpi	r24, 0x01	; 1
    1910:	91 05       	cpc	r25, r1
    1912:	81 f0       	breq	.+32     	; 0x1934 <DcMotor_Rotate+0x5e>
    1914:	2b 81       	ldd	r18, Y+3	; 0x03
    1916:	3c 81       	ldd	r19, Y+4	; 0x04
    1918:	22 30       	cpi	r18, 0x02	; 2
    191a:	31 05       	cpc	r19, r1
    191c:	b1 f0       	breq	.+44     	; 0x194a <DcMotor_Rotate+0x74>
	default:
	case 0:
		GPIO_writePin(MOTOR_PORT, IN1, LOGIC_LOW);
    191e:	81 e0       	ldi	r24, 0x01	; 1
    1920:	65 e0       	ldi	r22, 0x05	; 5
    1922:	40 e0       	ldi	r20, 0x00	; 0
    1924:	0e 94 5c 09 	call	0x12b8	; 0x12b8 <GPIO_writePin>
		GPIO_writePin(MOTOR_PORT, IN2, LOGIC_LOW);
    1928:	81 e0       	ldi	r24, 0x01	; 1
    192a:	64 e0       	ldi	r22, 0x04	; 4
    192c:	40 e0       	ldi	r20, 0x00	; 0
    192e:	0e 94 5c 09 	call	0x12b8	; 0x12b8 <GPIO_writePin>
    1932:	15 c0       	rjmp	.+42     	; 0x195e <DcMotor_Rotate+0x88>
		break;
	case 1:
		GPIO_writePin(MOTOR_PORT, IN1, LOGIC_HIGH);
    1934:	81 e0       	ldi	r24, 0x01	; 1
    1936:	65 e0       	ldi	r22, 0x05	; 5
    1938:	41 e0       	ldi	r20, 0x01	; 1
    193a:	0e 94 5c 09 	call	0x12b8	; 0x12b8 <GPIO_writePin>
		GPIO_writePin(MOTOR_PORT, IN2, LOGIC_LOW);
    193e:	81 e0       	ldi	r24, 0x01	; 1
    1940:	64 e0       	ldi	r22, 0x04	; 4
    1942:	40 e0       	ldi	r20, 0x00	; 0
    1944:	0e 94 5c 09 	call	0x12b8	; 0x12b8 <GPIO_writePin>
    1948:	0a c0       	rjmp	.+20     	; 0x195e <DcMotor_Rotate+0x88>
		break;

	case 2:
		GPIO_writePin(MOTOR_PORT, IN1, LOGIC_LOW);
    194a:	81 e0       	ldi	r24, 0x01	; 1
    194c:	65 e0       	ldi	r22, 0x05	; 5
    194e:	40 e0       	ldi	r20, 0x00	; 0
    1950:	0e 94 5c 09 	call	0x12b8	; 0x12b8 <GPIO_writePin>
		GPIO_writePin(MOTOR_PORT, IN2, LOGIC_HIGH);
    1954:	81 e0       	ldi	r24, 0x01	; 1
    1956:	64 e0       	ldi	r22, 0x04	; 4
    1958:	41 e0       	ldi	r20, 0x01	; 1
    195a:	0e 94 5c 09 	call	0x12b8	; 0x12b8 <GPIO_writePin>
		break;
	}

}
    195e:	0f 90       	pop	r0
    1960:	0f 90       	pop	r0
    1962:	0f 90       	pop	r0
    1964:	0f 90       	pop	r0
    1966:	cf 91       	pop	r28
    1968:	df 91       	pop	r29
    196a:	08 95       	ret

0000196c <Buzzer_init>:
 *      Author: Omar
 */

#include "buzzer.h"

void Buzzer_init(void) {
    196c:	df 93       	push	r29
    196e:	cf 93       	push	r28
    1970:	cd b7       	in	r28, 0x3d	; 61
    1972:	de b7       	in	r29, 0x3e	; 62

	GPIO_setupPinDirection(BUZZER_PORT, BUZZER_PIN, PIN_OUTPUT);
    1974:	81 e0       	ldi	r24, 0x01	; 1
    1976:	66 e0       	ldi	r22, 0x06	; 6
    1978:	41 e0       	ldi	r20, 0x01	; 1
    197a:	0e 94 71 08 	call	0x10e2	; 0x10e2 <GPIO_setupPinDirection>
	GPIO_writePin(BUZZER_PORT, BUZZER_PIN, LOGIC_LOW);
    197e:	81 e0       	ldi	r24, 0x01	; 1
    1980:	66 e0       	ldi	r22, 0x06	; 6
    1982:	40 e0       	ldi	r20, 0x00	; 0
    1984:	0e 94 5c 09 	call	0x12b8	; 0x12b8 <GPIO_writePin>
}
    1988:	cf 91       	pop	r28
    198a:	df 91       	pop	r29
    198c:	08 95       	ret

0000198e <Buzzer_on>:

void Buzzer_on(void) {
    198e:	df 93       	push	r29
    1990:	cf 93       	push	r28
    1992:	cd b7       	in	r28, 0x3d	; 61
    1994:	de b7       	in	r29, 0x3e	; 62

	GPIO_writePin(BUZZER_PORT, BUZZER_PIN, LOGIC_HIGH);
    1996:	81 e0       	ldi	r24, 0x01	; 1
    1998:	66 e0       	ldi	r22, 0x06	; 6
    199a:	41 e0       	ldi	r20, 0x01	; 1
    199c:	0e 94 5c 09 	call	0x12b8	; 0x12b8 <GPIO_writePin>
}
    19a0:	cf 91       	pop	r28
    19a2:	df 91       	pop	r29
    19a4:	08 95       	ret

000019a6 <Buzzer_off>:

void Buzzer_off(void) {
    19a6:	df 93       	push	r29
    19a8:	cf 93       	push	r28
    19aa:	cd b7       	in	r28, 0x3d	; 61
    19ac:	de b7       	in	r29, 0x3e	; 62

	GPIO_writePin(BUZZER_PORT, BUZZER_PIN, LOGIC_LOW);
    19ae:	81 e0       	ldi	r24, 0x01	; 1
    19b0:	66 e0       	ldi	r22, 0x06	; 6
    19b2:	40 e0       	ldi	r20, 0x00	; 0
    19b4:	0e 94 5c 09 	call	0x12b8	; 0x12b8 <GPIO_writePin>
}
    19b8:	cf 91       	pop	r28
    19ba:	df 91       	pop	r29
    19bc:	08 95       	ret

000019be <main>:
UART_ConfigType UARTConfiguration = { BIT_8, Disabled, BIT_1, 9600 };
Timer1_ConfigType TimerConfiguration = { 0, 31250, CLK_256, COMPARE };

/////////////////////////////////////////////////////////////////////////////

int main() {
    19be:	df 93       	push	r29
    19c0:	cf 93       	push	r28
    19c2:	00 d0       	rcall	.+0      	; 0x19c4 <main+0x6>
    19c4:	00 d0       	rcall	.+0      	; 0x19c6 <main+0x8>
    19c6:	cd b7       	in	r28, 0x3d	; 61
    19c8:	de b7       	in	r29, 0x3e	; 62

	UART_init(&UARTConfiguration);
    19ca:	88 e6       	ldi	r24, 0x68	; 104
    19cc:	90 e0       	ldi	r25, 0x00	; 0
    19ce:	0e 94 a3 05 	call	0xb46	; 0xb46 <UART_init>
	Buzzer_init();
    19d2:	0e 94 b6 0c 	call	0x196c	; 0x196c <Buzzer_init>
	DcMotor_Init();
    19d6:	0e 94 50 0c 	call	0x18a0	; 0x18a0 <DcMotor_Init>
	Timer1_setCallBack(TimerCounterCallBack);
    19da:	89 ef       	ldi	r24, 0xF9	; 249
    19dc:	9d e0       	ldi	r25, 0x0D	; 13
    19de:	0e 94 bb 07 	call	0xf76	; 0xf76 <Timer1_setCallBack>
	TWI_ConfigType I2C_Configuration = { 1, 2 };
    19e2:	81 e0       	ldi	r24, 0x01	; 1
    19e4:	89 83       	std	Y+1, r24	; 0x01
    19e6:	82 e0       	ldi	r24, 0x02	; 2
    19e8:	8a 83       	std	Y+2, r24	; 0x02
	TWI_init(&I2C_Configuration);
    19ea:	ce 01       	movw	r24, r28
    19ec:	01 96       	adiw	r24, 0x01	; 1
    19ee:	0e 94 e2 07 	call	0xfc4	; 0xfc4 <TWI_init>
	while (UART_receiveByte() != HMI_ECU_READY) {
    19f2:	0e 94 3b 06 	call	0xc76	; 0xc76 <UART_receiveByte>
    19f6:	80 31       	cpi	r24, 0x10	; 16
    19f8:	e1 f7       	brne	.-8      	; 0x19f2 <main+0x34>
	}
	UART_sendByte(CONTROL_ECU_READY);
    19fa:	80 e2       	ldi	r24, 0x20	; 32
    19fc:	0e 94 4a 06 	call	0xc94	; 0xc94 <UART_sendByte>
	UART_sendByte(SetNewPassword);
    1a00:	85 e4       	ldi	r24, 0x45	; 69
    1a02:	0e 94 4a 06 	call	0xc94	; 0xc94 <UART_sendByte>

	while (1) {

		g_uart_order = UART_receiveByte();
    1a06:	0e 94 3b 06 	call	0xc76	; 0xc76 <UART_receiveByte>
    1a0a:	80 93 78 00 	sts	0x0078, r24
		switch (g_uart_order) {
    1a0e:	80 91 78 00 	lds	r24, 0x0078
    1a12:	28 2f       	mov	r18, r24
    1a14:	30 e0       	ldi	r19, 0x00	; 0
    1a16:	3c 83       	std	Y+4, r19	; 0x04
    1a18:	2b 83       	std	Y+3, r18	; 0x03
    1a1a:	8b 81       	ldd	r24, Y+3	; 0x03
    1a1c:	9c 81       	ldd	r25, Y+4	; 0x04
    1a1e:	8f 34       	cpi	r24, 0x4F	; 79
    1a20:	91 05       	cpc	r25, r1
    1a22:	09 f4       	brne	.+2      	; 0x1a26 <main+0x68>
    1a24:	75 c0       	rjmp	.+234    	; 0x1b10 <main+0x152>
    1a26:	2b 81       	ldd	r18, Y+3	; 0x03
    1a28:	3c 81       	ldd	r19, Y+4	; 0x04
    1a2a:	20 35       	cpi	r18, 0x50	; 80
    1a2c:	31 05       	cpc	r19, r1
    1a2e:	5c f4       	brge	.+22     	; 0x1a46 <main+0x88>
    1a30:	8b 81       	ldd	r24, Y+3	; 0x03
    1a32:	9c 81       	ldd	r25, Y+4	; 0x04
    1a34:	84 34       	cpi	r24, 0x44	; 68
    1a36:	91 05       	cpc	r25, r1
    1a38:	d9 f0       	breq	.+54     	; 0x1a70 <main+0xb2>
    1a3a:	2b 81       	ldd	r18, Y+3	; 0x03
    1a3c:	3c 81       	ldd	r19, Y+4	; 0x04
    1a3e:	25 34       	cpi	r18, 0x45	; 69
    1a40:	31 05       	cpc	r19, r1
    1a42:	91 f0       	breq	.+36     	; 0x1a68 <main+0xaa>
    1a44:	e0 cf       	rjmp	.-64     	; 0x1a06 <main+0x48>
    1a46:	8b 81       	ldd	r24, Y+3	; 0x03
    1a48:	9c 81       	ldd	r25, Y+4	; 0x04
    1a4a:	85 36       	cpi	r24, 0x65	; 101
    1a4c:	91 05       	cpc	r25, r1
    1a4e:	d1 f0       	breq	.+52     	; 0x1a84 <main+0xc6>
    1a50:	2b 81       	ldd	r18, Y+3	; 0x03
    1a52:	3c 81       	ldd	r19, Y+4	; 0x04
    1a54:	24 37       	cpi	r18, 0x74	; 116
    1a56:	31 05       	cpc	r19, r1
    1a58:	09 f4       	brne	.+2      	; 0x1a5c <main+0x9e>
    1a5a:	6d c0       	rjmp	.+218    	; 0x1b36 <main+0x178>
    1a5c:	8b 81       	ldd	r24, Y+3	; 0x03
    1a5e:	9c 81       	ldd	r25, Y+4	; 0x04
    1a60:	80 35       	cpi	r24, 0x50	; 80
    1a62:	91 05       	cpc	r25, r1
    1a64:	81 f1       	breq	.+96     	; 0x1ac6 <main+0x108>
    1a66:	cf cf       	rjmp	.-98     	; 0x1a06 <main+0x48>

		case SetNewPassword:
			UART_sendByte(SetNewPassword);
    1a68:	85 e4       	ldi	r24, 0x45	; 69
    1a6a:	0e 94 4a 06 	call	0xc94	; 0xc94 <UART_sendByte>
    1a6e:	cb cf       	rjmp	.-106    	; 0x1a06 <main+0x48>
			break;


		case Password1Ready:
			g_uart_order = 0;
    1a70:	10 92 78 00 	sts	0x0078, r1
			SYS_Create_Password_CTRL(passArray1);
    1a74:	8d e7       	ldi	r24, 0x7D	; 125
    1a76:	90 e0       	ldi	r25, 0x00	; 0
    1a78:	0e 94 d3 0d 	call	0x1ba6	; 0x1ba6 <SYS_Create_Password_CTRL>
			UART_sendByte(Password1Saved);
    1a7c:	87 e4       	ldi	r24, 0x47	; 71
    1a7e:	0e 94 4a 06 	call	0xc94	; 0xc94 <UART_sendByte>
    1a82:	c1 cf       	rjmp	.-126    	; 0x1a06 <main+0x48>
			break;

		case Password2Ready:
			g_uart_order = 0;
    1a84:	10 92 78 00 	sts	0x0078, r1
			SYS_Create_Password_CTRL(passArray2);
    1a88:	8c e8       	ldi	r24, 0x8C	; 140
    1a8a:	90 e0       	ldi	r25, 0x00	; 0
    1a8c:	0e 94 d3 0d 	call	0x1ba6	; 0x1ba6 <SYS_Create_Password_CTRL>
			UART_sendByte(Password2Saved);
    1a90:	83 e5       	ldi	r24, 0x53	; 83
    1a92:	0e 94 4a 06 	call	0xc94	; 0xc94 <UART_sendByte>
			SYS_ComparePasswords(passArray1, passArray2);
    1a96:	8d e7       	ldi	r24, 0x7D	; 125
    1a98:	90 e0       	ldi	r25, 0x00	; 0
    1a9a:	2c e8       	ldi	r18, 0x8C	; 140
    1a9c:	30 e0       	ldi	r19, 0x00	; 0
    1a9e:	b9 01       	movw	r22, r18
    1aa0:	0e 94 05 0e 	call	0x1c0a	; 0x1c0a <SYS_ComparePasswords>
			if (g_errorCount == 1) {
    1aa4:	80 91 7a 00 	lds	r24, 0x007A
    1aa8:	81 30       	cpi	r24, 0x01	; 1
    1aaa:	39 f4       	brne	.+14     	; 0x1aba <main+0xfc>
				UART_sendByte(PasswordUnmatched);
    1aac:	84 e4       	ldi	r24, 0x44	; 68
    1aae:	0e 94 4a 06 	call	0xc94	; 0xc94 <UART_sendByte>
				UART_sendByte(SetNewPassword);
    1ab2:	85 e4       	ldi	r24, 0x45	; 69
    1ab4:	0e 94 4a 06 	call	0xc94	; 0xc94 <UART_sendByte>
    1ab8:	a6 cf       	rjmp	.-180    	; 0x1a06 <main+0x48>
			} else {
				UART_sendByte(PasswordMatched);
    1aba:	89 e4       	ldi	r24, 0x49	; 73
    1abc:	0e 94 4a 06 	call	0xc94	; 0xc94 <UART_sendByte>
				SYS_EEPROM_Write();
    1ac0:	0e 94 39 0e 	call	0x1c72	; 0x1c72 <SYS_EEPROM_Write>
    1ac4:	a0 cf       	rjmp	.-192    	; 0x1a06 <main+0x48>
			}
			break;

		case SendRequestedPass:
			g_uart_order = 0;
    1ac6:	10 92 78 00 	sts	0x0078, r1
			SYS_Create_Password_CTRL(passArray3);
    1aca:	82 e8       	ldi	r24, 0x82	; 130
    1acc:	90 e0       	ldi	r25, 0x00	; 0
    1ace:	0e 94 d3 0d 	call	0x1ba6	; 0x1ba6 <SYS_Create_Password_CTRL>
			SYS_EEPROM_Compare();
    1ad2:	0e 94 d8 0e 	call	0x1db0	; 0x1db0 <SYS_EEPROM_Compare>
			if (g_WrongPassRead == 0) {
    1ad6:	80 91 7b 00 	lds	r24, 0x007B
    1ada:	88 23       	and	r24, r24
    1adc:	31 f4       	brne	.+12     	; 0x1aea <main+0x12c>
				UART_sendByte(PasswordCorrect);
    1ade:	8d e4       	ldi	r24, 0x4D	; 77
    1ae0:	0e 94 4a 06 	call	0xc94	; 0xc94 <UART_sendByte>
				g_Tries=0;
    1ae4:	10 92 7c 00 	sts	0x007C, r1
    1ae8:	08 c0       	rjmp	.+16     	; 0x1afa <main+0x13c>
			} else {
				UART_sendByte(PasswordInCorrect);
    1aea:	81 e4       	ldi	r24, 0x41	; 65
    1aec:	0e 94 4a 06 	call	0xc94	; 0xc94 <UART_sendByte>
				++g_Tries;
    1af0:	80 91 7c 00 	lds	r24, 0x007C
    1af4:	8f 5f       	subi	r24, 0xFF	; 255
    1af6:	80 93 7c 00 	sts	0x007C, r24
			}
			if (g_Tries == 2) {
    1afa:	80 91 7c 00 	lds	r24, 0x007C
    1afe:	82 30       	cpi	r24, 0x02	; 2
    1b00:	09 f0       	breq	.+2      	; 0x1b04 <main+0x146>
    1b02:	81 cf       	rjmp	.-254    	; 0x1a06 <main+0x48>
				UART_sendByte(THEIF);
    1b04:	8f e4       	ldi	r24, 0x4F	; 79
    1b06:	0e 94 4a 06 	call	0xc94	; 0xc94 <UART_sendByte>
				g_Tries = 0;
    1b0a:	10 92 7c 00 	sts	0x007C, r1
    1b0e:	7b cf       	rjmp	.-266    	; 0x1a06 <main+0x48>
			}
			break;

		case THEIF:
			g_uart_order = 0;
    1b10:	10 92 78 00 	sts	0x0078, r1
			Buzzer_on();
    1b14:	0e 94 c7 0c 	call	0x198e	; 0x198e <Buzzer_on>
			Timer1_init(&TimerConfiguration);
    1b18:	8f e6       	ldi	r24, 0x6F	; 111
    1b1a:	90 e0       	ldi	r25, 0x00	; 0
    1b1c:	0e 94 4d 07 	call	0xe9a	; 0xe9a <Timer1_init>
			while (g_timerCounts != 2) {
    1b20:	80 91 79 00 	lds	r24, 0x0079
    1b24:	82 30       	cpi	r24, 0x02	; 2
    1b26:	e1 f7       	brne	.-8      	; 0x1b20 <main+0x162>
			}
			g_timerCounts=0;
    1b28:	10 92 79 00 	sts	0x0079, r1
			Timer1_deInit();
    1b2c:	0e 94 cd 07 	call	0xf9a	; 0xf9a <Timer1_deInit>
			Buzzer_off();
    1b30:	0e 94 d3 0c 	call	0x19a6	; 0x19a6 <Buzzer_off>
    1b34:	68 cf       	rjmp	.-304    	; 0x1a06 <main+0x48>
			break;

		case OpenDoor:
			Timer1_init(&TimerConfiguration);
    1b36:	8f e6       	ldi	r24, 0x6F	; 111
    1b38:	90 e0       	ldi	r25, 0x00	; 0
    1b3a:	0e 94 4d 07 	call	0xe9a	; 0xe9a <Timer1_init>
			DcMotor_Rotate(CW, 100);
    1b3e:	81 e0       	ldi	r24, 0x01	; 1
    1b40:	64 e6       	ldi	r22, 0x64	; 100
    1b42:	0e 94 6b 0c 	call	0x18d6	; 0x18d6 <DcMotor_Rotate>
			while (g_timerCounts != 2) {
    1b46:	80 91 79 00 	lds	r24, 0x0079
    1b4a:	82 30       	cpi	r24, 0x02	; 2
    1b4c:	e1 f7       	brne	.-8      	; 0x1b46 <main+0x188>
			}
			g_timerCounts=0;
    1b4e:	10 92 79 00 	sts	0x0079, r1
			Timer1_deInit();
    1b52:	0e 94 cd 07 	call	0xf9a	; 0xf9a <Timer1_deInit>

			Timer1_init(&TimerConfiguration);
    1b56:	8f e6       	ldi	r24, 0x6F	; 111
    1b58:	90 e0       	ldi	r25, 0x00	; 0
    1b5a:	0e 94 4d 07 	call	0xe9a	; 0xe9a <Timer1_init>
			DcMotor_Rotate(STOP, 100);
    1b5e:	80 e0       	ldi	r24, 0x00	; 0
    1b60:	64 e6       	ldi	r22, 0x64	; 100
    1b62:	0e 94 6b 0c 	call	0x18d6	; 0x18d6 <DcMotor_Rotate>
			while (g_timerCounts != 2) {
    1b66:	80 91 79 00 	lds	r24, 0x0079
    1b6a:	82 30       	cpi	r24, 0x02	; 2
    1b6c:	e1 f7       	brne	.-8      	; 0x1b66 <main+0x1a8>
			}
			g_timerCounts=0;
    1b6e:	10 92 79 00 	sts	0x0079, r1
			Timer1_deInit();
    1b72:	0e 94 cd 07 	call	0xf9a	; 0xf9a <Timer1_deInit>

			Timer1_init(&TimerConfiguration);
    1b76:	8f e6       	ldi	r24, 0x6F	; 111
    1b78:	90 e0       	ldi	r25, 0x00	; 0
    1b7a:	0e 94 4d 07 	call	0xe9a	; 0xe9a <Timer1_init>
			DcMotor_Rotate(ACW, 100);
    1b7e:	82 e0       	ldi	r24, 0x02	; 2
    1b80:	64 e6       	ldi	r22, 0x64	; 100
    1b82:	0e 94 6b 0c 	call	0x18d6	; 0x18d6 <DcMotor_Rotate>
			while (g_timerCounts != 2) {
    1b86:	80 91 79 00 	lds	r24, 0x0079
    1b8a:	82 30       	cpi	r24, 0x02	; 2
    1b8c:	e1 f7       	brne	.-8      	; 0x1b86 <main+0x1c8>
			}
			g_timerCounts=0;
    1b8e:	10 92 79 00 	sts	0x0079, r1
			Timer1_deInit();
    1b92:	0e 94 cd 07 	call	0xf9a	; 0xf9a <Timer1_deInit>
			DcMotor_Rotate(STOP, 100);
    1b96:	80 e0       	ldi	r24, 0x00	; 0
    1b98:	64 e6       	ldi	r22, 0x64	; 100
    1b9a:	0e 94 6b 0c 	call	0x18d6	; 0x18d6 <DcMotor_Rotate>
			UART_sendByte(MainMenu);
    1b9e:	87 e6       	ldi	r24, 0x67	; 103
    1ba0:	0e 94 4a 06 	call	0xc94	; 0xc94 <UART_sendByte>
    1ba4:	30 cf       	rjmp	.-416    	; 0x1a06 <main+0x48>

00001ba6 <SYS_Create_Password_CTRL>:

	}

}

void SYS_Create_Password_CTRL(uint8 *Ptr1ToPass) {
    1ba6:	0f 93       	push	r16
    1ba8:	1f 93       	push	r17
    1baa:	df 93       	push	r29
    1bac:	cf 93       	push	r28
    1bae:	00 d0       	rcall	.+0      	; 0x1bb0 <SYS_Create_Password_CTRL+0xa>
    1bb0:	0f 92       	push	r0
    1bb2:	cd b7       	in	r28, 0x3d	; 61
    1bb4:	de b7       	in	r29, 0x3e	; 62
    1bb6:	9b 83       	std	Y+3, r25	; 0x03
    1bb8:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i;
	for (i = 0; i < PasswordSize; i++) {
    1bba:	19 82       	std	Y+1, r1	; 0x01
    1bbc:	0f c0       	rjmp	.+30     	; 0x1bdc <SYS_Create_Password_CTRL+0x36>
		Ptr1ToPass[i] = UART_receiveByte();
    1bbe:	89 81       	ldd	r24, Y+1	; 0x01
    1bc0:	28 2f       	mov	r18, r24
    1bc2:	30 e0       	ldi	r19, 0x00	; 0
    1bc4:	8a 81       	ldd	r24, Y+2	; 0x02
    1bc6:	9b 81       	ldd	r25, Y+3	; 0x03
    1bc8:	8c 01       	movw	r16, r24
    1bca:	02 0f       	add	r16, r18
    1bcc:	13 1f       	adc	r17, r19
    1bce:	0e 94 3b 06 	call	0xc76	; 0xc76 <UART_receiveByte>
    1bd2:	f8 01       	movw	r30, r16
    1bd4:	80 83       	st	Z, r24

}

void SYS_Create_Password_CTRL(uint8 *Ptr1ToPass) {
	uint8 i;
	for (i = 0; i < PasswordSize; i++) {
    1bd6:	89 81       	ldd	r24, Y+1	; 0x01
    1bd8:	8f 5f       	subi	r24, 0xFF	; 255
    1bda:	89 83       	std	Y+1, r24	; 0x01
    1bdc:	89 81       	ldd	r24, Y+1	; 0x01
    1bde:	85 30       	cpi	r24, 0x05	; 5
    1be0:	70 f3       	brcs	.-36     	; 0x1bbe <SYS_Create_Password_CTRL+0x18>
		Ptr1ToPass[i] = UART_receiveByte();
	}

}
    1be2:	0f 90       	pop	r0
    1be4:	0f 90       	pop	r0
    1be6:	0f 90       	pop	r0
    1be8:	cf 91       	pop	r28
    1bea:	df 91       	pop	r29
    1bec:	1f 91       	pop	r17
    1bee:	0f 91       	pop	r16
    1bf0:	08 95       	ret

00001bf2 <TimerCounterCallBack>:

void TimerCounterCallBack(void) {
    1bf2:	df 93       	push	r29
    1bf4:	cf 93       	push	r28
    1bf6:	cd b7       	in	r28, 0x3d	; 61
    1bf8:	de b7       	in	r29, 0x3e	; 62
// As Configured Timer Ticks Interrupt Every 1 sec
	g_timerCounts++;
    1bfa:	80 91 79 00 	lds	r24, 0x0079
    1bfe:	8f 5f       	subi	r24, 0xFF	; 255
    1c00:	80 93 79 00 	sts	0x0079, r24
}
    1c04:	cf 91       	pop	r28
    1c06:	df 91       	pop	r29
    1c08:	08 95       	ret

00001c0a <SYS_ComparePasswords>:

void SYS_ComparePasswords(const uint8 *Ptr1ToPass, const uint8 *Ptr2ToPass) {
    1c0a:	df 93       	push	r29
    1c0c:	cf 93       	push	r28
    1c0e:	00 d0       	rcall	.+0      	; 0x1c10 <SYS_ComparePasswords+0x6>
    1c10:	00 d0       	rcall	.+0      	; 0x1c12 <SYS_ComparePasswords+0x8>
    1c12:	0f 92       	push	r0
    1c14:	cd b7       	in	r28, 0x3d	; 61
    1c16:	de b7       	in	r29, 0x3e	; 62
    1c18:	9b 83       	std	Y+3, r25	; 0x03
    1c1a:	8a 83       	std	Y+2, r24	; 0x02
    1c1c:	7d 83       	std	Y+5, r23	; 0x05
    1c1e:	6c 83       	std	Y+4, r22	; 0x04
	g_errorCount = 0;
    1c20:	10 92 7a 00 	sts	0x007A, r1
	uint8 i;
	for (i = 0; i < PasswordSize; i++) {
    1c24:	19 82       	std	Y+1, r1	; 0x01
    1c26:	1a c0       	rjmp	.+52     	; 0x1c5c <SYS_ComparePasswords+0x52>
		if (Ptr1ToPass[i] != Ptr2ToPass[i]) {
    1c28:	89 81       	ldd	r24, Y+1	; 0x01
    1c2a:	28 2f       	mov	r18, r24
    1c2c:	30 e0       	ldi	r19, 0x00	; 0
    1c2e:	8a 81       	ldd	r24, Y+2	; 0x02
    1c30:	9b 81       	ldd	r25, Y+3	; 0x03
    1c32:	fc 01       	movw	r30, r24
    1c34:	e2 0f       	add	r30, r18
    1c36:	f3 1f       	adc	r31, r19
    1c38:	40 81       	ld	r20, Z
    1c3a:	89 81       	ldd	r24, Y+1	; 0x01
    1c3c:	28 2f       	mov	r18, r24
    1c3e:	30 e0       	ldi	r19, 0x00	; 0
    1c40:	8c 81       	ldd	r24, Y+4	; 0x04
    1c42:	9d 81       	ldd	r25, Y+5	; 0x05
    1c44:	fc 01       	movw	r30, r24
    1c46:	e2 0f       	add	r30, r18
    1c48:	f3 1f       	adc	r31, r19
    1c4a:	80 81       	ld	r24, Z
    1c4c:	48 17       	cp	r20, r24
    1c4e:	19 f0       	breq	.+6      	; 0x1c56 <SYS_ComparePasswords+0x4c>
			g_errorCount = 1;
    1c50:	81 e0       	ldi	r24, 0x01	; 1
    1c52:	80 93 7a 00 	sts	0x007A, r24
}

void SYS_ComparePasswords(const uint8 *Ptr1ToPass, const uint8 *Ptr2ToPass) {
	g_errorCount = 0;
	uint8 i;
	for (i = 0; i < PasswordSize; i++) {
    1c56:	89 81       	ldd	r24, Y+1	; 0x01
    1c58:	8f 5f       	subi	r24, 0xFF	; 255
    1c5a:	89 83       	std	Y+1, r24	; 0x01
    1c5c:	89 81       	ldd	r24, Y+1	; 0x01
    1c5e:	85 30       	cpi	r24, 0x05	; 5
    1c60:	18 f3       	brcs	.-58     	; 0x1c28 <SYS_ComparePasswords+0x1e>
		if (Ptr1ToPass[i] != Ptr2ToPass[i]) {
			g_errorCount = 1;
		}
	}

}
    1c62:	0f 90       	pop	r0
    1c64:	0f 90       	pop	r0
    1c66:	0f 90       	pop	r0
    1c68:	0f 90       	pop	r0
    1c6a:	0f 90       	pop	r0
    1c6c:	cf 91       	pop	r28
    1c6e:	df 91       	pop	r29
    1c70:	08 95       	ret

00001c72 <SYS_EEPROM_Write>:

void SYS_EEPROM_Write(void) {
    1c72:	df 93       	push	r29
    1c74:	cf 93       	push	r28
    1c76:	cd b7       	in	r28, 0x3d	; 61
    1c78:	de b7       	in	r29, 0x3e	; 62
    1c7a:	2f 97       	sbiw	r28, 0x0f	; 15
    1c7c:	0f b6       	in	r0, 0x3f	; 63
    1c7e:	f8 94       	cli
    1c80:	de bf       	out	0x3e, r29	; 62
    1c82:	0f be       	out	0x3f, r0	; 63
    1c84:	cd bf       	out	0x3d, r28	; 61
	uint8 i;
	for (i = 0; i < PasswordSize; i++) {
    1c86:	1f 86       	std	Y+15, r1	; 0x0f
    1c88:	86 c0       	rjmp	.+268    	; 0x1d96 <SYS_EEPROM_Write+0x124>
		EEPROM_writeByte(0X50 + i, passArray2[i]);
    1c8a:	8f 85       	ldd	r24, Y+15	; 0x0f
    1c8c:	88 2f       	mov	r24, r24
    1c8e:	90 e0       	ldi	r25, 0x00	; 0
    1c90:	80 5b       	subi	r24, 0xB0	; 176
    1c92:	9f 4f       	sbci	r25, 0xFF	; 255
    1c94:	ac 01       	movw	r20, r24
    1c96:	8f 85       	ldd	r24, Y+15	; 0x0f
    1c98:	88 2f       	mov	r24, r24
    1c9a:	90 e0       	ldi	r25, 0x00	; 0
    1c9c:	fc 01       	movw	r30, r24
    1c9e:	e4 57       	subi	r30, 0x74	; 116
    1ca0:	ff 4f       	sbci	r31, 0xFF	; 255
    1ca2:	20 81       	ld	r18, Z
    1ca4:	ca 01       	movw	r24, r20
    1ca6:	62 2f       	mov	r22, r18
    1ca8:	0e 94 af 0b 	call	0x175e	; 0x175e <EEPROM_writeByte>
    1cac:	80 e0       	ldi	r24, 0x00	; 0
    1cae:	90 e0       	ldi	r25, 0x00	; 0
    1cb0:	aa ef       	ldi	r26, 0xFA	; 250
    1cb2:	b3 e4       	ldi	r27, 0x43	; 67
    1cb4:	8b 87       	std	Y+11, r24	; 0x0b
    1cb6:	9c 87       	std	Y+12, r25	; 0x0c
    1cb8:	ad 87       	std	Y+13, r26	; 0x0d
    1cba:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1cbc:	6b 85       	ldd	r22, Y+11	; 0x0b
    1cbe:	7c 85       	ldd	r23, Y+12	; 0x0c
    1cc0:	8d 85       	ldd	r24, Y+13	; 0x0d
    1cc2:	9e 85       	ldd	r25, Y+14	; 0x0e
    1cc4:	20 e0       	ldi	r18, 0x00	; 0
    1cc6:	30 e0       	ldi	r19, 0x00	; 0
    1cc8:	4a ef       	ldi	r20, 0xFA	; 250
    1cca:	54 e4       	ldi	r21, 0x44	; 68
    1ccc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1cd0:	dc 01       	movw	r26, r24
    1cd2:	cb 01       	movw	r24, r22
    1cd4:	8f 83       	std	Y+7, r24	; 0x07
    1cd6:	98 87       	std	Y+8, r25	; 0x08
    1cd8:	a9 87       	std	Y+9, r26	; 0x09
    1cda:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1cdc:	6f 81       	ldd	r22, Y+7	; 0x07
    1cde:	78 85       	ldd	r23, Y+8	; 0x08
    1ce0:	89 85       	ldd	r24, Y+9	; 0x09
    1ce2:	9a 85       	ldd	r25, Y+10	; 0x0a
    1ce4:	20 e0       	ldi	r18, 0x00	; 0
    1ce6:	30 e0       	ldi	r19, 0x00	; 0
    1ce8:	40 e8       	ldi	r20, 0x80	; 128
    1cea:	5f e3       	ldi	r21, 0x3F	; 63
    1cec:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1cf0:	88 23       	and	r24, r24
    1cf2:	2c f4       	brge	.+10     	; 0x1cfe <SYS_EEPROM_Write+0x8c>
		__ticks = 1;
    1cf4:	81 e0       	ldi	r24, 0x01	; 1
    1cf6:	90 e0       	ldi	r25, 0x00	; 0
    1cf8:	9e 83       	std	Y+6, r25	; 0x06
    1cfa:	8d 83       	std	Y+5, r24	; 0x05
    1cfc:	3f c0       	rjmp	.+126    	; 0x1d7c <SYS_EEPROM_Write+0x10a>
	else if (__tmp > 65535)
    1cfe:	6f 81       	ldd	r22, Y+7	; 0x07
    1d00:	78 85       	ldd	r23, Y+8	; 0x08
    1d02:	89 85       	ldd	r24, Y+9	; 0x09
    1d04:	9a 85       	ldd	r25, Y+10	; 0x0a
    1d06:	20 e0       	ldi	r18, 0x00	; 0
    1d08:	3f ef       	ldi	r19, 0xFF	; 255
    1d0a:	4f e7       	ldi	r20, 0x7F	; 127
    1d0c:	57 e4       	ldi	r21, 0x47	; 71
    1d0e:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1d12:	18 16       	cp	r1, r24
    1d14:	4c f5       	brge	.+82     	; 0x1d68 <SYS_EEPROM_Write+0xf6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1d16:	6b 85       	ldd	r22, Y+11	; 0x0b
    1d18:	7c 85       	ldd	r23, Y+12	; 0x0c
    1d1a:	8d 85       	ldd	r24, Y+13	; 0x0d
    1d1c:	9e 85       	ldd	r25, Y+14	; 0x0e
    1d1e:	20 e0       	ldi	r18, 0x00	; 0
    1d20:	30 e0       	ldi	r19, 0x00	; 0
    1d22:	40 e2       	ldi	r20, 0x20	; 32
    1d24:	51 e4       	ldi	r21, 0x41	; 65
    1d26:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1d2a:	dc 01       	movw	r26, r24
    1d2c:	cb 01       	movw	r24, r22
    1d2e:	bc 01       	movw	r22, r24
    1d30:	cd 01       	movw	r24, r26
    1d32:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1d36:	dc 01       	movw	r26, r24
    1d38:	cb 01       	movw	r24, r22
    1d3a:	9e 83       	std	Y+6, r25	; 0x06
    1d3c:	8d 83       	std	Y+5, r24	; 0x05
    1d3e:	0f c0       	rjmp	.+30     	; 0x1d5e <SYS_EEPROM_Write+0xec>
    1d40:	88 ec       	ldi	r24, 0xC8	; 200
    1d42:	90 e0       	ldi	r25, 0x00	; 0
    1d44:	9c 83       	std	Y+4, r25	; 0x04
    1d46:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1d48:	8b 81       	ldd	r24, Y+3	; 0x03
    1d4a:	9c 81       	ldd	r25, Y+4	; 0x04
    1d4c:	01 97       	sbiw	r24, 0x01	; 1
    1d4e:	f1 f7       	brne	.-4      	; 0x1d4c <SYS_EEPROM_Write+0xda>
    1d50:	9c 83       	std	Y+4, r25	; 0x04
    1d52:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1d54:	8d 81       	ldd	r24, Y+5	; 0x05
    1d56:	9e 81       	ldd	r25, Y+6	; 0x06
    1d58:	01 97       	sbiw	r24, 0x01	; 1
    1d5a:	9e 83       	std	Y+6, r25	; 0x06
    1d5c:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1d5e:	8d 81       	ldd	r24, Y+5	; 0x05
    1d60:	9e 81       	ldd	r25, Y+6	; 0x06
    1d62:	00 97       	sbiw	r24, 0x00	; 0
    1d64:	69 f7       	brne	.-38     	; 0x1d40 <SYS_EEPROM_Write+0xce>
    1d66:	14 c0       	rjmp	.+40     	; 0x1d90 <SYS_EEPROM_Write+0x11e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1d68:	6f 81       	ldd	r22, Y+7	; 0x07
    1d6a:	78 85       	ldd	r23, Y+8	; 0x08
    1d6c:	89 85       	ldd	r24, Y+9	; 0x09
    1d6e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1d70:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1d74:	dc 01       	movw	r26, r24
    1d76:	cb 01       	movw	r24, r22
    1d78:	9e 83       	std	Y+6, r25	; 0x06
    1d7a:	8d 83       	std	Y+5, r24	; 0x05
    1d7c:	8d 81       	ldd	r24, Y+5	; 0x05
    1d7e:	9e 81       	ldd	r25, Y+6	; 0x06
    1d80:	9a 83       	std	Y+2, r25	; 0x02
    1d82:	89 83       	std	Y+1, r24	; 0x01
    1d84:	89 81       	ldd	r24, Y+1	; 0x01
    1d86:	9a 81       	ldd	r25, Y+2	; 0x02
    1d88:	01 97       	sbiw	r24, 0x01	; 1
    1d8a:	f1 f7       	brne	.-4      	; 0x1d88 <SYS_EEPROM_Write+0x116>
    1d8c:	9a 83       	std	Y+2, r25	; 0x02
    1d8e:	89 83       	std	Y+1, r24	; 0x01

}

void SYS_EEPROM_Write(void) {
	uint8 i;
	for (i = 0; i < PasswordSize; i++) {
    1d90:	8f 85       	ldd	r24, Y+15	; 0x0f
    1d92:	8f 5f       	subi	r24, 0xFF	; 255
    1d94:	8f 87       	std	Y+15, r24	; 0x0f
    1d96:	8f 85       	ldd	r24, Y+15	; 0x0f
    1d98:	85 30       	cpi	r24, 0x05	; 5
    1d9a:	08 f4       	brcc	.+2      	; 0x1d9e <SYS_EEPROM_Write+0x12c>
    1d9c:	76 cf       	rjmp	.-276    	; 0x1c8a <SYS_EEPROM_Write+0x18>
		EEPROM_writeByte(0X50 + i, passArray2[i]);
		_delay_ms(500);
	}

}
    1d9e:	2f 96       	adiw	r28, 0x0f	; 15
    1da0:	0f b6       	in	r0, 0x3f	; 63
    1da2:	f8 94       	cli
    1da4:	de bf       	out	0x3e, r29	; 62
    1da6:	0f be       	out	0x3f, r0	; 63
    1da8:	cd bf       	out	0x3d, r28	; 61
    1daa:	cf 91       	pop	r28
    1dac:	df 91       	pop	r29
    1dae:	08 95       	ret

00001db0 <SYS_EEPROM_Compare>:

void SYS_EEPROM_Compare(void) {
    1db0:	df 93       	push	r29
    1db2:	cf 93       	push	r28
    1db4:	00 d0       	rcall	.+0      	; 0x1db6 <SYS_EEPROM_Compare+0x6>
    1db6:	cd b7       	in	r28, 0x3d	; 61
    1db8:	de b7       	in	r29, 0x3e	; 62
	uint8 i;
	g_WrongPassRead = 0;
    1dba:	10 92 7b 00 	sts	0x007B, r1
	for (i = 0; i < PasswordSize; i++) {
    1dbe:	1a 82       	std	Y+2, r1	; 0x02
    1dc0:	13 c0       	rjmp	.+38     	; 0x1de8 <SYS_EEPROM_Compare+0x38>
		EEPROM_readByte(0X50 + i, &passtest[i]);
    1dc2:	8a 81       	ldd	r24, Y+2	; 0x02
    1dc4:	88 2f       	mov	r24, r24
    1dc6:	90 e0       	ldi	r25, 0x00	; 0
    1dc8:	80 5b       	subi	r24, 0xB0	; 176
    1dca:	9f 4f       	sbci	r25, 0xFF	; 255
    1dcc:	ac 01       	movw	r20, r24
    1dce:	8a 81       	ldd	r24, Y+2	; 0x02
    1dd0:	88 2f       	mov	r24, r24
    1dd2:	90 e0       	ldi	r25, 0x00	; 0
    1dd4:	9c 01       	movw	r18, r24
    1dd6:	29 57       	subi	r18, 0x79	; 121
    1dd8:	3f 4f       	sbci	r19, 0xFF	; 255
    1dda:	ca 01       	movw	r24, r20
    1ddc:	b9 01       	movw	r22, r18
    1dde:	0e 94 f0 0b 	call	0x17e0	; 0x17e0 <EEPROM_readByte>
}

void SYS_EEPROM_Compare(void) {
	uint8 i;
	g_WrongPassRead = 0;
	for (i = 0; i < PasswordSize; i++) {
    1de2:	8a 81       	ldd	r24, Y+2	; 0x02
    1de4:	8f 5f       	subi	r24, 0xFF	; 255
    1de6:	8a 83       	std	Y+2, r24	; 0x02
    1de8:	8a 81       	ldd	r24, Y+2	; 0x02
    1dea:	85 30       	cpi	r24, 0x05	; 5
    1dec:	50 f3       	brcs	.-44     	; 0x1dc2 <SYS_EEPROM_Compare+0x12>
		EEPROM_readByte(0X50 + i, &passtest[i]);
	}
	uint8 k;
	for (k = 0; k < PasswordSize; k++) {
    1dee:	19 82       	std	Y+1, r1	; 0x01
    1df0:	16 c0       	rjmp	.+44     	; 0x1e1e <SYS_EEPROM_Compare+0x6e>
		if (passtest[k] != passArray3[k]) {
    1df2:	89 81       	ldd	r24, Y+1	; 0x01
    1df4:	88 2f       	mov	r24, r24
    1df6:	90 e0       	ldi	r25, 0x00	; 0
    1df8:	fc 01       	movw	r30, r24
    1dfa:	e9 57       	subi	r30, 0x79	; 121
    1dfc:	ff 4f       	sbci	r31, 0xFF	; 255
    1dfe:	20 81       	ld	r18, Z
    1e00:	89 81       	ldd	r24, Y+1	; 0x01
    1e02:	88 2f       	mov	r24, r24
    1e04:	90 e0       	ldi	r25, 0x00	; 0
    1e06:	fc 01       	movw	r30, r24
    1e08:	ee 57       	subi	r30, 0x7E	; 126
    1e0a:	ff 4f       	sbci	r31, 0xFF	; 255
    1e0c:	80 81       	ld	r24, Z
    1e0e:	28 17       	cp	r18, r24
    1e10:	19 f0       	breq	.+6      	; 0x1e18 <SYS_EEPROM_Compare+0x68>
			g_WrongPassRead = 1;
    1e12:	81 e0       	ldi	r24, 0x01	; 1
    1e14:	80 93 7b 00 	sts	0x007B, r24
	g_WrongPassRead = 0;
	for (i = 0; i < PasswordSize; i++) {
		EEPROM_readByte(0X50 + i, &passtest[i]);
	}
	uint8 k;
	for (k = 0; k < PasswordSize; k++) {
    1e18:	89 81       	ldd	r24, Y+1	; 0x01
    1e1a:	8f 5f       	subi	r24, 0xFF	; 255
    1e1c:	89 83       	std	Y+1, r24	; 0x01
    1e1e:	89 81       	ldd	r24, Y+1	; 0x01
    1e20:	85 30       	cpi	r24, 0x05	; 5
    1e22:	38 f3       	brcs	.-50     	; 0x1df2 <SYS_EEPROM_Compare+0x42>
			g_WrongPassRead = 1;
		}

	}

}
    1e24:	0f 90       	pop	r0
    1e26:	0f 90       	pop	r0
    1e28:	cf 91       	pop	r28
    1e2a:	df 91       	pop	r29
    1e2c:	08 95       	ret

00001e2e <__udivmodhi4>:
    1e2e:	aa 1b       	sub	r26, r26
    1e30:	bb 1b       	sub	r27, r27
    1e32:	51 e1       	ldi	r21, 0x11	; 17
    1e34:	07 c0       	rjmp	.+14     	; 0x1e44 <__udivmodhi4_ep>

00001e36 <__udivmodhi4_loop>:
    1e36:	aa 1f       	adc	r26, r26
    1e38:	bb 1f       	adc	r27, r27
    1e3a:	a6 17       	cp	r26, r22
    1e3c:	b7 07       	cpc	r27, r23
    1e3e:	10 f0       	brcs	.+4      	; 0x1e44 <__udivmodhi4_ep>
    1e40:	a6 1b       	sub	r26, r22
    1e42:	b7 0b       	sbc	r27, r23

00001e44 <__udivmodhi4_ep>:
    1e44:	88 1f       	adc	r24, r24
    1e46:	99 1f       	adc	r25, r25
    1e48:	5a 95       	dec	r21
    1e4a:	a9 f7       	brne	.-22     	; 0x1e36 <__udivmodhi4_loop>
    1e4c:	80 95       	com	r24
    1e4e:	90 95       	com	r25
    1e50:	bc 01       	movw	r22, r24
    1e52:	cd 01       	movw	r24, r26
    1e54:	08 95       	ret

00001e56 <__udivmodsi4>:
    1e56:	a1 e2       	ldi	r26, 0x21	; 33
    1e58:	1a 2e       	mov	r1, r26
    1e5a:	aa 1b       	sub	r26, r26
    1e5c:	bb 1b       	sub	r27, r27
    1e5e:	fd 01       	movw	r30, r26
    1e60:	0d c0       	rjmp	.+26     	; 0x1e7c <__udivmodsi4_ep>

00001e62 <__udivmodsi4_loop>:
    1e62:	aa 1f       	adc	r26, r26
    1e64:	bb 1f       	adc	r27, r27
    1e66:	ee 1f       	adc	r30, r30
    1e68:	ff 1f       	adc	r31, r31
    1e6a:	a2 17       	cp	r26, r18
    1e6c:	b3 07       	cpc	r27, r19
    1e6e:	e4 07       	cpc	r30, r20
    1e70:	f5 07       	cpc	r31, r21
    1e72:	20 f0       	brcs	.+8      	; 0x1e7c <__udivmodsi4_ep>
    1e74:	a2 1b       	sub	r26, r18
    1e76:	b3 0b       	sbc	r27, r19
    1e78:	e4 0b       	sbc	r30, r20
    1e7a:	f5 0b       	sbc	r31, r21

00001e7c <__udivmodsi4_ep>:
    1e7c:	66 1f       	adc	r22, r22
    1e7e:	77 1f       	adc	r23, r23
    1e80:	88 1f       	adc	r24, r24
    1e82:	99 1f       	adc	r25, r25
    1e84:	1a 94       	dec	r1
    1e86:	69 f7       	brne	.-38     	; 0x1e62 <__udivmodsi4_loop>
    1e88:	60 95       	com	r22
    1e8a:	70 95       	com	r23
    1e8c:	80 95       	com	r24
    1e8e:	90 95       	com	r25
    1e90:	9b 01       	movw	r18, r22
    1e92:	ac 01       	movw	r20, r24
    1e94:	bd 01       	movw	r22, r26
    1e96:	cf 01       	movw	r24, r30
    1e98:	08 95       	ret

00001e9a <__prologue_saves__>:
    1e9a:	2f 92       	push	r2
    1e9c:	3f 92       	push	r3
    1e9e:	4f 92       	push	r4
    1ea0:	5f 92       	push	r5
    1ea2:	6f 92       	push	r6
    1ea4:	7f 92       	push	r7
    1ea6:	8f 92       	push	r8
    1ea8:	9f 92       	push	r9
    1eaa:	af 92       	push	r10
    1eac:	bf 92       	push	r11
    1eae:	cf 92       	push	r12
    1eb0:	df 92       	push	r13
    1eb2:	ef 92       	push	r14
    1eb4:	ff 92       	push	r15
    1eb6:	0f 93       	push	r16
    1eb8:	1f 93       	push	r17
    1eba:	cf 93       	push	r28
    1ebc:	df 93       	push	r29
    1ebe:	cd b7       	in	r28, 0x3d	; 61
    1ec0:	de b7       	in	r29, 0x3e	; 62
    1ec2:	ca 1b       	sub	r28, r26
    1ec4:	db 0b       	sbc	r29, r27
    1ec6:	0f b6       	in	r0, 0x3f	; 63
    1ec8:	f8 94       	cli
    1eca:	de bf       	out	0x3e, r29	; 62
    1ecc:	0f be       	out	0x3f, r0	; 63
    1ece:	cd bf       	out	0x3d, r28	; 61
    1ed0:	09 94       	ijmp

00001ed2 <__epilogue_restores__>:
    1ed2:	2a 88       	ldd	r2, Y+18	; 0x12
    1ed4:	39 88       	ldd	r3, Y+17	; 0x11
    1ed6:	48 88       	ldd	r4, Y+16	; 0x10
    1ed8:	5f 84       	ldd	r5, Y+15	; 0x0f
    1eda:	6e 84       	ldd	r6, Y+14	; 0x0e
    1edc:	7d 84       	ldd	r7, Y+13	; 0x0d
    1ede:	8c 84       	ldd	r8, Y+12	; 0x0c
    1ee0:	9b 84       	ldd	r9, Y+11	; 0x0b
    1ee2:	aa 84       	ldd	r10, Y+10	; 0x0a
    1ee4:	b9 84       	ldd	r11, Y+9	; 0x09
    1ee6:	c8 84       	ldd	r12, Y+8	; 0x08
    1ee8:	df 80       	ldd	r13, Y+7	; 0x07
    1eea:	ee 80       	ldd	r14, Y+6	; 0x06
    1eec:	fd 80       	ldd	r15, Y+5	; 0x05
    1eee:	0c 81       	ldd	r16, Y+4	; 0x04
    1ef0:	1b 81       	ldd	r17, Y+3	; 0x03
    1ef2:	aa 81       	ldd	r26, Y+2	; 0x02
    1ef4:	b9 81       	ldd	r27, Y+1	; 0x01
    1ef6:	ce 0f       	add	r28, r30
    1ef8:	d1 1d       	adc	r29, r1
    1efa:	0f b6       	in	r0, 0x3f	; 63
    1efc:	f8 94       	cli
    1efe:	de bf       	out	0x3e, r29	; 62
    1f00:	0f be       	out	0x3f, r0	; 63
    1f02:	cd bf       	out	0x3d, r28	; 61
    1f04:	ed 01       	movw	r28, r26
    1f06:	08 95       	ret

00001f08 <_exit>:
    1f08:	f8 94       	cli

00001f0a <__stop_program>:
    1f0a:	ff cf       	rjmp	.-2      	; 0x1f0a <__stop_program>
